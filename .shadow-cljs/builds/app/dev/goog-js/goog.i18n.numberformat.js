["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/i18n/numberformat.js"],"~:js","goog.provide(\"goog.i18n.NumberFormat\");\ngoog.provide(\"goog.i18n.NumberFormat.CurrencyStyle\");\ngoog.provide(\"goog.i18n.NumberFormat.Format\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.i18n.CompactNumberFormatSymbols\");\ngoog.require(\"goog.i18n.NumberFormatSymbols\");\ngoog.require(\"goog.i18n.NumberFormatSymbols_u_nu_latn\");\ngoog.require(\"goog.i18n.currency\");\ngoog.require(\"goog.math\");\ngoog.require(\"goog.string\");\n/**\n * @constructor\n * @param {(number|string)} pattern\n * @param {string=} opt_currency\n * @param {number=} opt_currencyStyle\n */\ngoog.i18n.NumberFormat = function(pattern, opt_currency, opt_currencyStyle) {\n  /** @private @type {(string|undefined)} */ this.intlCurrencyCode_ = opt_currency;\n  /** @private @type {number} */ this.currencyStyle_ = opt_currencyStyle || goog.i18n.NumberFormat.CurrencyStyle.LOCAL;\n  /** @private @type {number} */ this.maximumIntegerDigits_ = 40;\n  /** @private @type {number} */ this.minimumIntegerDigits_ = 1;\n  /** @private @type {number} */ this.significantDigits_ = 0;\n  /** @private @type {number} */ this.maximumFractionDigits_ = 3;\n  /** @private @type {number} */ this.minimumFractionDigits_ = 0;\n  /** @private @type {number} */ this.minExponentDigits_ = 0;\n  /** @private @type {boolean} */ this.useSignForPositiveExponent_ = false;\n  /** @private @type {boolean} */ this.showTrailingZeros_ = false;\n  /** @private @type {string} */ this.positivePrefix_ = \"\";\n  /** @private @type {string} */ this.positiveSuffix_ = \"\";\n  /** @private @type {string} */ this.negativePrefix_ = \"-\";\n  /** @private @type {string} */ this.negativeSuffix_ = \"\";\n  /** @private @type {number} */ this.multiplier_ = 1;\n  /** @private @type {!boolean} */ this.negativePercentSignExpected_ = false;\n  /** @private @type {!Array<number>} */ this.groupingArray_ = [];\n  /** @private @type {boolean} */ this.decimalSeparatorAlwaysShown_ = false;\n  /** @private @type {boolean} */ this.useExponentialNotation_ = false;\n  /** @private @type {goog.i18n.NumberFormat.CompactStyle} */ this.compactStyle_ = goog.i18n.NumberFormat.CompactStyle.NONE;\n  /** @private @type {?number} */ this.baseFormattingNumber_ = null;\n  /** @private @type {string} */ this.pattern_;\n  if (typeof pattern == \"number\") {\n    this.applyStandardPattern_(pattern);\n  } else {\n    this.applyPattern_(pattern);\n  }\n};\n/** @enum {number} */ goog.i18n.NumberFormat.Format = {DECIMAL:1, SCIENTIFIC:2, PERCENT:3, CURRENCY:4, COMPACT_SHORT:5, COMPACT_LONG:6};\n/** @enum {number} */ goog.i18n.NumberFormat.CurrencyStyle = {LOCAL:0, PORTABLE:1, GLOBAL:2};\n/** @enum {number} */ goog.i18n.NumberFormat.CompactStyle = {NONE:0, SHORT:1, LONG:2};\n/** @private @type {boolean} */ goog.i18n.NumberFormat.enforceAsciiDigits_ = false;\n/**\n * @param {boolean} doEnforce\n */\ngoog.i18n.NumberFormat.setEnforceAsciiDigits = function(doEnforce) {\n  goog.i18n.NumberFormat.enforceAsciiDigits_ = doEnforce;\n};\n/**\n * @return {boolean}\n */\ngoog.i18n.NumberFormat.isEnforceAsciiDigits = function() {\n  return goog.i18n.NumberFormat.enforceAsciiDigits_;\n};\n/**\n * @private\n * @return {!Object}\n */\ngoog.i18n.NumberFormat.getNumberFormatSymbols_ = function() {\n  return goog.i18n.NumberFormat.enforceAsciiDigits_ ? goog.i18n.NumberFormatSymbols_u_nu_latn : goog.i18n.NumberFormatSymbols;\n};\n/**\n * @private\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.getCurrencyCode_ = function() {\n  return this.intlCurrencyCode_ || goog.i18n.NumberFormat.getNumberFormatSymbols_().DEF_CURRENCY_CODE;\n};\n/**\n * @param {number} min\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setMinimumFractionDigits = function(min) {\n  if (this.significantDigits_ > 0 && min > 0) {\n    throw Error(\"Can't combine significant digits and minimum fraction digits\");\n  }\n  this.minimumFractionDigits_ = min;\n  return this;\n};\n/**\n * @param {number} max\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setMaximumFractionDigits = function(max) {\n  if (max > 308) {\n    throw Error(\"Unsupported maximum fraction digits: \" + max);\n  }\n  this.maximumFractionDigits_ = max;\n  return this;\n};\n/**\n * @param {number} number\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setSignificantDigits = function(number) {\n  if (this.minimumFractionDigits_ > 0 && number >= 0) {\n    throw Error(\"Can't combine significant digits and minimum fraction digits\");\n  }\n  this.significantDigits_ = number;\n  return this;\n};\n/**\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getSignificantDigits = function() {\n  return this.significantDigits_;\n};\n/**\n * @param {boolean} showTrailingZeros\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setShowTrailingZeros = function(showTrailingZeros) {\n  this.showTrailingZeros_ = showTrailingZeros;\n  return this;\n};\n/**\n * @param {?number} baseFormattingNumber\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setBaseFormatting = function(baseFormattingNumber) {\n  goog.asserts.assert(goog.isNull(baseFormattingNumber) || isFinite(baseFormattingNumber));\n  this.baseFormattingNumber_ = baseFormattingNumber;\n  return this;\n};\n/**\n * @return {?number}\n */\ngoog.i18n.NumberFormat.prototype.getBaseFormatting = function() {\n  return this.baseFormattingNumber_;\n};\n/**\n * @private\n * @param {string} pattern\n */\ngoog.i18n.NumberFormat.prototype.applyPattern_ = function(pattern) {\n  this.pattern_ = pattern.replace(/ /g, \" \");\n  var pos = [0];\n  this.positivePrefix_ = this.parseAffix_(pattern, pos);\n  var trunkStart = pos[0];\n  this.parseTrunk_(pattern, pos);\n  var trunkLen = pos[0] - trunkStart;\n  this.positiveSuffix_ = this.parseAffix_(pattern, pos);\n  if (pos[0] < pattern.length && pattern.charAt(pos[0]) == goog.i18n.NumberFormat.PATTERN_SEPARATOR_) {\n    pos[0]++;\n    if (this.multiplier_ != 1) {\n      this.negativePercentSignExpected_ = true;\n    }\n    this.negativePrefix_ = this.parseAffix_(pattern, pos);\n    pos[0] += trunkLen;\n    this.negativeSuffix_ = this.parseAffix_(pattern, pos);\n  } else {\n    this.negativePrefix_ += this.positivePrefix_;\n    this.negativeSuffix_ += this.positiveSuffix_;\n  }\n};\n/**\n * @private\n * @param {number} patternType\n */\ngoog.i18n.NumberFormat.prototype.applyStandardPattern_ = function(patternType) {\n  switch(patternType) {\n    case goog.i18n.NumberFormat.Format.DECIMAL:\n      this.applyPattern_(goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.SCIENTIFIC:\n      this.applyPattern_(goog.i18n.NumberFormat.getNumberFormatSymbols_().SCIENTIFIC_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.PERCENT:\n      this.applyPattern_(goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.CURRENCY:\n      this.applyPattern_(goog.i18n.currency.adjustPrecision(goog.i18n.NumberFormat.getNumberFormatSymbols_().CURRENCY_PATTERN, this.getCurrencyCode_()));\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_SHORT:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.SHORT);\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_LONG:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.LONG);\n      break;\n    default:\n      throw Error(\"Unsupported pattern type.\");\n  }\n};\n/**\n * @private\n * @param {goog.i18n.NumberFormat.CompactStyle} style\n */\ngoog.i18n.NumberFormat.prototype.applyCompactStyle_ = function(style) {\n  this.compactStyle_ = style;\n  this.applyPattern_(goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_PATTERN);\n  this.setMinimumFractionDigits(0);\n  this.setMaximumFractionDigits(2);\n  this.setSignificantDigits(2);\n};\n/**\n * @param {string} text\n * @param {Array<number>=} opt_pos\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.parse = function(text, opt_pos) {\n  var pos = opt_pos || [0];\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw Error(\"Parsing of compact numbers is unimplemented\");\n  }\n  var ret = NaN;\n  text = text.replace(/ /g, \" \");\n  var gotPositive = text.indexOf(this.positivePrefix_, pos[0]) == pos[0];\n  var gotNegative = text.indexOf(this.negativePrefix_, pos[0]) == pos[0];\n  if (gotPositive && gotNegative) {\n    if (this.positivePrefix_.length > this.negativePrefix_.length) {\n      gotNegative = false;\n    } else {\n      if (this.positivePrefix_.length < this.negativePrefix_.length) {\n        gotPositive = false;\n      }\n    }\n  }\n  if (gotPositive) {\n    pos[0] += this.positivePrefix_.length;\n  } else {\n    if (gotNegative) {\n      pos[0] += this.negativePrefix_.length;\n    }\n  }\n  if (text.indexOf(goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY, pos[0]) == pos[0]) {\n    pos[0] += goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY.length;\n    ret = Infinity;\n  } else {\n    ret = this.parseNumber_(text, pos);\n  }\n  if (gotPositive) {\n    if (!(text.indexOf(this.positiveSuffix_, pos[0]) == pos[0])) {\n      return NaN;\n    }\n    pos[0] += this.positiveSuffix_.length;\n  } else {\n    if (gotNegative) {\n      if (!(text.indexOf(this.negativeSuffix_, pos[0]) == pos[0])) {\n        return NaN;\n      }\n      pos[0] += this.negativeSuffix_.length;\n    }\n  }\n  return gotNegative ? -ret : ret;\n};\n/**\n * @private\n * @param {string} text\n * @param {Array<number>} pos\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.parseNumber_ = function(text, pos) {\n  var sawDecimal = false;\n  var sawExponent = false;\n  var sawDigit = false;\n  var exponentPos = -1;\n  var scale = 1;\n  var decimal = goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_SEP;\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\n  var exponentChar = goog.i18n.NumberFormat.getNumberFormatSymbols_().EXP_SYMBOL;\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw Error(\"Parsing of compact style numbers is not implemented\");\n  }\n  var normalizedText = \"\";\n  for (; pos[0] < text.length; pos[0]++) {\n    var ch = text.charAt(pos[0]);\n    var digit = this.getDigit_(ch);\n    if (digit >= 0 && digit <= 9) {\n      normalizedText += digit;\n      sawDigit = true;\n    } else {\n      if (ch == decimal.charAt(0)) {\n        if (sawDecimal || sawExponent) {\n          break;\n        }\n        normalizedText += \".\";\n        sawDecimal = true;\n      } else {\n        if (ch == grouping.charAt(0) && (\" \" != grouping.charAt(0) || pos[0] + 1 < text.length && this.getDigit_(text.charAt(pos[0] + 1)) >= 0)) {\n          if (sawDecimal || sawExponent) {\n            break;\n          }\n          continue;\n        } else {\n          if (ch == exponentChar.charAt(0)) {\n            if (sawExponent) {\n              break;\n            }\n            normalizedText += \"E\";\n            sawExponent = true;\n            exponentPos = pos[0];\n          } else {\n            if (ch == \"+\" || ch == \"-\") {\n              if (sawDigit && exponentPos != pos[0] - 1) {\n                break;\n              }\n              normalizedText += ch;\n            } else {\n              if (this.multiplier_ == 1 && ch == goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT.charAt(0)) {\n                if (scale != 1) {\n                  break;\n                }\n                scale = 100;\n                if (sawDigit) {\n                  pos[0]++;\n                  break;\n                }\n              } else {\n                if (this.multiplier_ == 1 && ch == goog.i18n.NumberFormat.getNumberFormatSymbols_().PERMILL.charAt(0)) {\n                  if (scale != 1) {\n                    break;\n                  }\n                  scale = 1000;\n                  if (sawDigit) {\n                    pos[0]++;\n                    break;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (this.multiplier_ != 1) {\n    scale = this.multiplier_;\n  }\n  return parseFloat(normalizedText) / scale;\n};\n/**\n * @param {number} number\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.format = function(number) {\n  if (isNaN(number)) {\n    return goog.i18n.NumberFormat.getNumberFormatSymbols_().NAN;\n  }\n  var parts = [];\n  var baseFormattingNumber = goog.isNull(this.baseFormattingNumber_) ? number : this.baseFormattingNumber_;\n  var unit = this.getUnitAfterRounding_(baseFormattingNumber, number);\n  number /= Math.pow(10, unit.divisorBase);\n  parts.push(unit.prefix);\n  var isNegative = number < 0.0 || number == 0.0 && 1 / number < 0.0;\n  parts.push(isNegative ? this.negativePrefix_ : this.positivePrefix_);\n  if (!isFinite(number)) {\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY);\n  } else {\n    number *= isNegative ? -1 : 1;\n    number *= this.multiplier_;\n    this.useExponentialNotation_ ? this.subformatExponential_(number, parts) : this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n  }\n  parts.push(isNegative ? this.negativeSuffix_ : this.positiveSuffix_);\n  parts.push(unit.suffix);\n  return parts.join(\"\");\n};\n/**\n * @private\n * @param {number} number\n * @return {{intValue:number,fracValue:number}}\n */\ngoog.i18n.NumberFormat.prototype.roundNumber_ = function(number) {\n  var power = Math.pow(10, this.maximumFractionDigits_);\n  var shiftedNumber = this.significantDigits_ <= 0 ? Math.round(number * power) : Math.round(this.roundToSignificantDigits_(number * power, this.significantDigits_, this.maximumFractionDigits_));\n  var intValue, fracValue;\n  if (isFinite(shiftedNumber)) {\n    intValue = Math.floor(shiftedNumber / power);\n    fracValue = Math.floor(shiftedNumber - intValue * power);\n  } else {\n    intValue = number;\n    fracValue = 0;\n  }\n  return {intValue:intValue, fracValue:fracValue};\n};\n/**\n * @private\n * @param {!Array<string>} parts\n * @param {number} zeroCode\n * @param {string} intPart\n * @param {!Array<number>} groupingArray\n * @param {number} repeatedDigitLen\n * @return {!Array<string>}\n */\ngoog.i18n.NumberFormat.formatNumberGroupingRepeatingDigitsParts_ = function(parts, zeroCode, intPart, groupingArray, repeatedDigitLen) {\n  var nonRepeatedGroupCompleteCount = 0;\n  var currentGroupSizeIndex = 0;\n  var currentGroupSize = 0;\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\n  var digitLen = intPart.length;\n  for (var i = 0; i < digitLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(i)) * 1));\n    if (digitLen - i > 1) {\n      currentGroupSize = groupingArray[currentGroupSizeIndex];\n      if (i < repeatedDigitLen) {\n        var repeatedDigitIndex = repeatedDigitLen - i;\n        if (currentGroupSize === 1 || currentGroupSize > 0 && repeatedDigitIndex % currentGroupSize === 1) {\n          parts.push(grouping);\n        }\n      } else {\n        if (currentGroupSizeIndex < groupingArray.length) {\n          if (i === repeatedDigitLen) {\n            currentGroupSizeIndex += 1;\n          } else {\n            if (currentGroupSize === i - repeatedDigitLen - nonRepeatedGroupCompleteCount + 1) {\n              parts.push(grouping);\n              nonRepeatedGroupCompleteCount += currentGroupSize;\n              currentGroupSizeIndex += 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return parts;\n};\n/**\n * @private\n * @param {!Array<string>} parts\n * @param {number} zeroCode\n * @param {string} intPart\n * @param {!Array<number>} groupingArray\n * @return {!Array<string>}\n */\ngoog.i18n.NumberFormat.formatNumberGroupingNonRepeatingDigitsParts_ = function(parts, zeroCode, intPart, groupingArray) {\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\n  var currentGroupSizeIndex;\n  var currentGroupSize = 0;\n  var digitLenLeft = intPart.length;\n  var rightToLeftParts = [];\n  for (currentGroupSizeIndex = groupingArray.length - 1; currentGroupSizeIndex >= 0 && digitLenLeft > 0; currentGroupSizeIndex--) {\n    currentGroupSize = groupingArray[currentGroupSizeIndex];\n    for (var rightDigitIndex = 0; rightDigitIndex < currentGroupSize && digitLenLeft - rightDigitIndex - 1 >= 0; rightDigitIndex++) {\n      rightToLeftParts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(digitLenLeft - rightDigitIndex - 1)) * 1));\n    }\n    digitLenLeft -= currentGroupSize;\n    if (digitLenLeft > 0) {\n      rightToLeftParts.push(grouping);\n    }\n  }\n  parts.push.apply(parts, rightToLeftParts.reverse());\n  return parts;\n};\n/**\n * @private\n * @param {number} number\n * @param {number} minIntDigits\n * @param {Array<string>} parts\n */\ngoog.i18n.NumberFormat.prototype.subformatFixed_ = function(number, minIntDigits, parts) {\n  if (this.minimumFractionDigits_ > this.maximumFractionDigits_) {\n    throw Error(\"Min value must be less than max value\");\n  }\n  if (!parts) {\n    parts = [];\n  }\n  var rounded = this.roundNumber_(number);\n  var intValue = rounded.intValue;\n  var fracValue = rounded.fracValue;\n  var numIntDigits = intValue == 0 ? 0 : this.intLog10_(intValue) + 1;\n  var fractionPresent = this.minimumFractionDigits_ > 0 || fracValue > 0 || this.showTrailingZeros_ && numIntDigits < this.significantDigits_;\n  var minimumFractionDigits = this.minimumFractionDigits_;\n  if (fractionPresent) {\n    if (this.showTrailingZeros_ && this.significantDigits_ > 0) {\n      minimumFractionDigits = this.significantDigits_ - numIntDigits;\n    } else {\n      minimumFractionDigits = this.minimumFractionDigits_;\n    }\n  }\n  var intPart = \"\";\n  var translatableInt = intValue;\n  while (translatableInt > 1E20) {\n    intPart = \"0\" + intPart;\n    translatableInt = Math.round(translatableInt / 10);\n  }\n  intPart = translatableInt + intPart;\n  var decimal = goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_SEP;\n  var zeroCode = goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\n  var digitLen = intPart.length;\n  var nonRepeatedGroupCount = 0;\n  if (intValue > 0 || minIntDigits > 0) {\n    for (var i = digitLen; i < minIntDigits; i++) {\n      parts.push(String.fromCharCode(zeroCode));\n    }\n    if (this.groupingArray_.length >= 2) {\n      for (var j = 1; j < this.groupingArray_.length; j++) {\n        nonRepeatedGroupCount += this.groupingArray_[j];\n      }\n    }\n    var repeatedDigitLen = digitLen - nonRepeatedGroupCount;\n    if (repeatedDigitLen > 0) {\n      parts = goog.i18n.NumberFormat.formatNumberGroupingRepeatingDigitsParts_(parts, zeroCode, intPart, this.groupingArray_, repeatedDigitLen);\n    } else {\n      parts = goog.i18n.NumberFormat.formatNumberGroupingNonRepeatingDigitsParts_(parts, zeroCode, intPart, this.groupingArray_);\n    }\n  } else {\n    if (!fractionPresent) {\n      parts.push(String.fromCharCode(zeroCode));\n    }\n  }\n  if (this.decimalSeparatorAlwaysShown_ || fractionPresent) {\n    parts.push(decimal);\n  }\n  var fracPart = String(fracValue);\n  var fracPartSplit = fracPart.split(\"e+\");\n  if (fracPartSplit.length == 2) {\n    var floatFrac = parseFloat(fracPartSplit[0]);\n    fracPart = String(this.roundToSignificantDigits_(floatFrac, this.significantDigits_, 1));\n    fracPart = fracPart.replace(\".\", \"\");\n    var exp = parseInt(fracPartSplit[1], 10);\n    fracPart += goog.string.repeat(\"0\", exp - fracPart.length + 1);\n  }\n  if (this.maximumFractionDigits_ + 1 > fracPart.length) {\n    var zeroesToAdd = this.maximumFractionDigits_ - fracPart.length;\n    fracPart = \"1\" + goog.string.repeat(\"0\", zeroesToAdd) + fracPart;\n  }\n  var fracLen = fracPart.length;\n  while (fracPart.charAt(fracLen - 1) == \"0\" && fracLen > minimumFractionDigits + 1) {\n    fracLen--;\n  }\n  for (var i = 1; i < fracLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(fracPart.charAt(i)) * 1));\n  }\n};\n/**\n * @private\n * @param {number} exponent\n * @param {Array<string>} parts\n */\ngoog.i18n.NumberFormat.prototype.addExponentPart_ = function(exponent, parts) {\n  parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().EXP_SYMBOL);\n  if (exponent < 0) {\n    exponent = -exponent;\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().MINUS_SIGN);\n  } else {\n    if (this.useSignForPositiveExponent_) {\n      parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().PLUS_SIGN);\n    }\n  }\n  var exponentDigits = \"\" + exponent;\n  var zeroChar = goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT;\n  for (var i = exponentDigits.length; i < this.minExponentDigits_; i++) {\n    parts.push(zeroChar);\n  }\n  parts.push(exponentDigits);\n};\n/**\n * @private\n * @param {number} value\n * @param {number} exponent\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getMantissa_ = function(value, exponent) {\n  var divisor = Math.pow(10, exponent);\n  if (isFinite(divisor) && divisor !== 0) {\n    return value / divisor;\n  } else {\n    divisor = Math.pow(10, Math.floor(exponent / 2));\n    var result = value / divisor / divisor;\n    if (exponent % 2 == 1) {\n      if (exponent > 0) {\n        result /= 10;\n      } else {\n        result *= 10;\n      }\n    }\n    return result;\n  }\n};\n/**\n * @private\n * @param {number} number\n * @param {Array<string>} parts\n */\ngoog.i18n.NumberFormat.prototype.subformatExponential_ = function(number, parts) {\n  if (number == 0.0) {\n    this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n    this.addExponentPart_(0, parts);\n    return;\n  }\n  var exponent = goog.math.safeFloor(Math.log(number) / Math.log(10));\n  number = this.getMantissa_(number, exponent);\n  var minIntDigits = this.minimumIntegerDigits_;\n  if (this.maximumIntegerDigits_ > 1 && this.maximumIntegerDigits_ > this.minimumIntegerDigits_) {\n    while (exponent % this.maximumIntegerDigits_ != 0) {\n      number *= 10;\n      exponent--;\n    }\n    minIntDigits = 1;\n  } else {\n    if (this.minimumIntegerDigits_ < 1) {\n      exponent++;\n      number /= 10;\n    } else {\n      exponent -= this.minimumIntegerDigits_ - 1;\n      number *= Math.pow(10, this.minimumIntegerDigits_ - 1);\n    }\n  }\n  this.subformatFixed_(number, minIntDigits, parts);\n  this.addExponentPart_(exponent, parts);\n};\n/**\n * @private\n * @param {string} ch\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getDigit_ = function(ch) {\n  var code = ch.charCodeAt(0);\n  if (48 <= code && code < 58) {\n    return code - 48;\n  } else {\n    var zeroCode = goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\n    return zeroCode <= code && code < zeroCode + 10 ? code - zeroCode : -1;\n  }\n};\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_ = \"0\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_ = \",\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_ = \".\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_PER_MILLE_ = \"‰\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_PERCENT_ = \"%\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_DIGIT_ = \"#\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_SEPARATOR_ = \";\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_EXPONENT_ = \"E\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_PLUS_ = \"+\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_ = \"¤\";\n/** @private @type {string} */ goog.i18n.NumberFormat.QUOTE_ = \"'\";\n/**\n * @private\n * @param {string} pattern\n * @param {Array<number>} pos\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.parseAffix_ = function(pattern, pos) {\n  var affix = \"\";\n  var inQuote = false;\n  var len = pattern.length;\n  for (; pos[0] < len; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    if (ch == goog.i18n.NumberFormat.QUOTE_) {\n      if (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.QUOTE_) {\n        pos[0]++;\n        affix += \"'\";\n      } else {\n        inQuote = !inQuote;\n      }\n      continue;\n    }\n    if (inQuote) {\n      affix += ch;\n    } else {\n      switch(ch) {\n        case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_SEPARATOR_:\n          return affix;\n        case goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_:\n          if (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_) {\n            pos[0]++;\n            affix += this.getCurrencyCode_();\n          } else {\n            switch(this.currencyStyle_) {\n              case goog.i18n.NumberFormat.CurrencyStyle.LOCAL:\n                affix += goog.i18n.currency.getLocalCurrencySign(this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.GLOBAL:\n                affix += goog.i18n.currency.getGlobalCurrencySign(this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.PORTABLE:\n                affix += goog.i18n.currency.getPortableCurrencySign(this.getCurrencyCode_());\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PERCENT_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw Error(\"Too many percent/permill\");\n          } else {\n            if (this.negativePercentSignExpected_ && this.multiplier_ != 100) {\n              throw Error(\"Inconsistent use of percent/permill characters\");\n            }\n          }\n          this.multiplier_ = 100;\n          this.negativePercentSignExpected_ = false;\n          affix += goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT;\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PER_MILLE_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw Error(\"Too many percent/permill\");\n          } else {\n            if (this.negativePercentSignExpected_ && this.multiplier_ != 1000) {\n              throw Error(\"Inconsistent use of percent/permill characters\");\n            }\n          }\n          this.multiplier_ = 1000;\n          this.negativePercentSignExpected_ = false;\n          affix += goog.i18n.NumberFormat.getNumberFormatSymbols_().PERMILL;\n          break;\n        default:\n          affix += ch;\n      }\n    }\n  }\n  return affix;\n};\n/**\n * @private\n * @param {string} pattern\n * @param {Array<number>} pos\n */\ngoog.i18n.NumberFormat.prototype.parseTrunk_ = function(pattern, pos) {\n  var decimalPos = -1;\n  var digitLeftCount = 0;\n  var zeroDigitCount = 0;\n  var digitRightCount = 0;\n  var groupingCount = -1;\n  var len = pattern.length;\n  for (var loop = true; pos[0] < len && loop; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    switch(ch) {\n      case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        if (zeroDigitCount > 0) {\n          digitRightCount++;\n        } else {\n          digitLeftCount++;\n        }\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        if (digitRightCount > 0) {\n          throw Error('Unexpected \"0\" in pattern \"' + pattern + '\"');\n        }\n        zeroDigitCount++;\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        if (groupingCount > 0) {\n          this.groupingArray_.push(groupingCount);\n        }\n        groupingCount = 0;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        if (decimalPos >= 0) {\n          throw Error('Multiple decimal separators in pattern \"' + pattern + '\"');\n        }\n        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_EXPONENT_:\n        if (this.useExponentialNotation_) {\n          throw Error('Multiple exponential symbols in pattern \"' + pattern + '\"');\n        }\n        this.useExponentialNotation_ = true;\n        this.minExponentDigits_ = 0;\n        if (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.PATTERN_PLUS_) {\n          pos[0]++;\n          this.useSignForPositiveExponent_ = true;\n        }\n        while (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_) {\n          pos[0]++;\n          this.minExponentDigits_++;\n        }\n        if (digitLeftCount + zeroDigitCount < 1 || this.minExponentDigits_ < 1) {\n          throw Error('Malformed exponential pattern \"' + pattern + '\"');\n        }\n        loop = false;\n        break;\n      default:\n        pos[0]--;\n        loop = false;\n        break;\n    }\n  }\n  if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {\n    var n = decimalPos;\n    if (n == 0) {\n      n++;\n    }\n    digitRightCount = digitLeftCount - n;\n    digitLeftCount = n - 1;\n    zeroDigitCount = 1;\n  }\n  if (decimalPos < 0 && digitRightCount > 0 || decimalPos >= 0 && (decimalPos < digitLeftCount || decimalPos > digitLeftCount + zeroDigitCount) || groupingCount == 0) {\n    throw Error('Malformed pattern \"' + pattern + '\"');\n  }\n  var totalDigits = digitLeftCount + zeroDigitCount + digitRightCount;\n  this.maximumFractionDigits_ = decimalPos >= 0 ? totalDigits - decimalPos : 0;\n  if (decimalPos >= 0) {\n    this.minimumFractionDigits_ = digitLeftCount + zeroDigitCount - decimalPos;\n    if (this.minimumFractionDigits_ < 0) {\n      this.minimumFractionDigits_ = 0;\n    }\n  }\n  var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : totalDigits;\n  this.minimumIntegerDigits_ = effectiveDecimalPos - digitLeftCount;\n  if (this.useExponentialNotation_) {\n    this.maximumIntegerDigits_ = digitLeftCount + this.minimumIntegerDigits_;\n    if (this.maximumFractionDigits_ == 0 && this.minimumIntegerDigits_ == 0) {\n      this.minimumIntegerDigits_ = 1;\n    }\n  }\n  this.groupingArray_.push(Math.max(0, groupingCount));\n  this.decimalSeparatorAlwaysShown_ = decimalPos == 0 || decimalPos == totalDigits;\n};\n/** @typedef {{prefix:string,suffix:string,divisorBase:number}} */ goog.i18n.NumberFormat.CompactNumberUnit;\n/** @private @type {!goog.i18n.NumberFormat.CompactNumberUnit} */ goog.i18n.NumberFormat.NULL_UNIT_ = {prefix:\"\", suffix:\"\", divisorBase:0};\n/**\n * @private\n * @param {number} base\n * @param {string} plurality\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit}\n */\ngoog.i18n.NumberFormat.prototype.getUnitFor_ = function(base, plurality) {\n  var table = this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.SHORT ? goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN : goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_LONG_PATTERN;\n  if (!goog.isDefAndNotNull(table)) {\n    table = goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN;\n  }\n  if (base < 3) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  } else {\n    base = Math.min(14, base);\n    var patterns = table[Math.pow(10, base)];\n    var previousNonNullBase = base - 1;\n    while (!patterns && previousNonNullBase >= 3) {\n      patterns = table[Math.pow(10, previousNonNullBase)];\n      previousNonNullBase--;\n    }\n    if (!patterns) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n    var pattern = patterns[plurality];\n    if (!pattern || pattern == \"0\") {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n    var parts = /([^0]*)(0+)(.*)/.exec(pattern);\n    if (!parts) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n    return {prefix:parts[1], suffix:parts[3], divisorBase:previousNonNullBase + 1 - (parts[2].length - 1)};\n  }\n};\n/**\n * @private\n * @param {number} formattingNumber\n * @param {number} pluralityNumber\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit}\n */\ngoog.i18n.NumberFormat.prototype.getUnitAfterRounding_ = function(formattingNumber, pluralityNumber) {\n  if (this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.NONE) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  }\n  formattingNumber = Math.abs(formattingNumber);\n  pluralityNumber = Math.abs(pluralityNumber);\n  var initialPlurality = this.pluralForm_(formattingNumber);\n  var base = formattingNumber <= 1 ? 0 : this.intLog10_(formattingNumber);\n  var initialDivisor = this.getUnitFor_(base, initialPlurality).divisorBase;\n  var pluralityAttempt = pluralityNumber / Math.pow(10, initialDivisor);\n  var pluralityRounded = this.roundNumber_(pluralityAttempt);\n  var formattingAttempt = formattingNumber / Math.pow(10, initialDivisor);\n  var formattingRounded = this.roundNumber_(formattingAttempt);\n  var finalPlurality = this.pluralForm_(pluralityRounded.intValue + pluralityRounded.fracValue);\n  return this.getUnitFor_(initialDivisor + this.intLog10_(formattingRounded.intValue), finalPlurality);\n};\n/**\n * @private\n * @param {number} number\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.intLog10_ = function(number) {\n  if (!isFinite(number)) {\n    return number > 0 ? number : 0;\n  }\n  var i = 0;\n  while ((number /= 10) >= 1) {\n    i++;\n  }\n  return i;\n};\n/**\n * @private\n * @param {number} number\n * @param {number} significantDigits\n * @param {number} scale\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.roundToSignificantDigits_ = function(number, significantDigits, scale) {\n  if (!number) {\n    return number;\n  }\n  var digits = this.intLog10_(number);\n  var magnitude = significantDigits - digits - 1;\n  if (magnitude < -scale) {\n    var point = Math.pow(10, scale);\n    return Math.round(number / point) * point;\n  }\n  var power = Math.pow(10, magnitude);\n  var shifted = Math.round(number * power);\n  return shifted / power;\n};\n/**\n * @private\n * @param {number} quantity\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.pluralForm_ = function(quantity) {\n  return \"other\";\n};\n/**\n * @return {boolean}\n */\ngoog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue = function() {\n  var posCurrSymbol = this.pattern_.indexOf(\"¤\");\n  var posPound = this.pattern_.indexOf(\"#\");\n  var posZero = this.pattern_.indexOf(\"0\");\n  var posCurrValue = Number.MAX_VALUE;\n  if (posPound >= 0 && posPound < posCurrValue) {\n    posCurrValue = posPound;\n  }\n  if (posZero >= 0 && posZero < posCurrValue) {\n    posCurrValue = posZero;\n  }\n  return posCurrSymbol < posCurrValue;\n};\n","~:source","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Number format/parse library with locale support.\n */\n\n\n/**\n * Namespace for locale number format functions\n */\ngoog.provide('goog.i18n.NumberFormat');\ngoog.provide('goog.i18n.NumberFormat.CurrencyStyle');\ngoog.provide('goog.i18n.NumberFormat.Format');\n\ngoog.require('goog.asserts');\ngoog.require('goog.i18n.CompactNumberFormatSymbols');\ngoog.require('goog.i18n.NumberFormatSymbols');\ngoog.require('goog.i18n.NumberFormatSymbols_u_nu_latn');\ngoog.require('goog.i18n.currency');\ngoog.require('goog.math');\ngoog.require('goog.string');\n\n\n\n/**\n * Constructor of NumberFormat.\n * @param {number|string} pattern The number that indicates a predefined\n *     number format pattern.\n * @param {string=} opt_currency Optional international currency\n *     code. This determines the currency code/symbol used in format/parse. If\n *     not given, the currency code for current locale will be used.\n * @param {number=} opt_currencyStyle currency style, value defined in\n *        goog.i18n.NumberFormat.CurrencyStyle.\n * @constructor\n */\ngoog.i18n.NumberFormat = function(pattern, opt_currency, opt_currencyStyle) {\n  /** @private {string|undefined} */\n  this.intlCurrencyCode_ = opt_currency;\n\n  /** @private {number} */\n  this.currencyStyle_ =\n      opt_currencyStyle || goog.i18n.NumberFormat.CurrencyStyle.LOCAL;\n\n  /** @private {number} */\n  this.maximumIntegerDigits_ = 40;\n  /** @private {number} */\n  this.minimumIntegerDigits_ = 1;\n  /** @private {number} */\n  this.significantDigits_ = 0;  // invariant, <= maximumFractionDigits\n  /** @private {number} */\n  this.maximumFractionDigits_ = 3;  // invariant, >= minFractionDigits\n  /** @private {number} */\n  this.minimumFractionDigits_ = 0;\n  /** @private {number} */\n  this.minExponentDigits_ = 0;\n  /** @private {boolean} */\n  this.useSignForPositiveExponent_ = false;\n\n  /**\n   * Whether to show trailing zeros in the fraction when significantDigits_ is\n   * positive.\n   * @private {boolean}\n   */\n  this.showTrailingZeros_ = false;\n\n  /** @private {string} */\n  this.positivePrefix_ = '';\n  /** @private {string} */\n  this.positiveSuffix_ = '';\n  /** @private {string} */\n  this.negativePrefix_ = '-';\n  /** @private {string} */\n  this.negativeSuffix_ = '';\n\n  // The multiplier for use in percent, per mille, etc.\n  /** @private {number} */\n  this.multiplier_ = 1;\n\n  /**\n   * True if the percent/permill sign of the negative pattern is expected.\n   * @private {!boolean}\n   */\n  this.negativePercentSignExpected_ = false;\n\n  /**\n   * The grouping array is used to store the values of each number group\n   * following left of the decimal place. For example, a number group with\n   * goog.i18n.NumberFormat('#,##,###') should have [3,2] where 2 is the\n   * repeated number group following a fixed number grouping of size 3.\n   * @private {!Array<number>}\n   */\n  this.groupingArray_ = [];\n\n  /** @private {boolean} */\n  this.decimalSeparatorAlwaysShown_ = false;\n  /** @private {boolean} */\n  this.useExponentialNotation_ = false;\n  /** @private {goog.i18n.NumberFormat.CompactStyle} */\n  this.compactStyle_ = goog.i18n.NumberFormat.CompactStyle.NONE;\n\n  /**\n   * The number to base the formatting on when using compact styles, or null\n   * if formatting should not be based on another number.\n   * @type {?number}\n   * @private\n   */\n  this.baseFormattingNumber_ = null;\n\n  /** @private {string} */\n  this.pattern_;\n\n  if (typeof pattern == 'number') {\n    this.applyStandardPattern_(pattern);\n  } else {\n    this.applyPattern_(pattern);\n  }\n};\n\n\n/**\n * Standard number formatting patterns.\n * @enum {number}\n */\ngoog.i18n.NumberFormat.Format = {\n  DECIMAL: 1,\n  SCIENTIFIC: 2,\n  PERCENT: 3,\n  CURRENCY: 4,\n  COMPACT_SHORT: 5,\n  COMPACT_LONG: 6\n};\n\n\n/**\n * Currency styles.\n * @enum {number}\n */\ngoog.i18n.NumberFormat.CurrencyStyle = {\n  LOCAL: 0,     // currency style as it is used in its circulating country.\n  PORTABLE: 1,  // currency style that differentiate it from other popular ones.\n  GLOBAL: 2     // currency style that is unique among all currencies.\n};\n\n\n/**\n * Compacting styles.\n * @enum {number}\n */\ngoog.i18n.NumberFormat.CompactStyle = {\n  NONE: 0,   // Don't compact.\n  SHORT: 1,  // Short compact form, such as 1.2B.\n  LONG: 2    // Long compact form, such as 1.2 billion.\n};\n\n\n/**\n * If the usage of Ascii digits should be enforced.\n * @type {boolean}\n * @private\n */\ngoog.i18n.NumberFormat.enforceAsciiDigits_ = false;\n\n\n/**\n * Set if the usage of Ascii digits in formatting should be enforced.\n * @param {boolean} doEnforce Boolean value about if Ascii digits should be\n *     enforced.\n */\ngoog.i18n.NumberFormat.setEnforceAsciiDigits = function(doEnforce) {\n  goog.i18n.NumberFormat.enforceAsciiDigits_ = doEnforce;\n};\n\n\n/**\n * Return if Ascii digits is enforced.\n * @return {boolean} If Ascii digits is enforced.\n */\ngoog.i18n.NumberFormat.isEnforceAsciiDigits = function() {\n  return goog.i18n.NumberFormat.enforceAsciiDigits_;\n};\n\n\n/**\n * Returns the current NumberFormatSymbols.\n * @return {!Object}\n * @private\n */\ngoog.i18n.NumberFormat.getNumberFormatSymbols_ = function() {\n  return goog.i18n.NumberFormat.enforceAsciiDigits_ ?\n      goog.i18n.NumberFormatSymbols_u_nu_latn :\n      goog.i18n.NumberFormatSymbols;\n};\n\n\n/**\n * Returns the currency code.\n * @return {string}\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getCurrencyCode_ = function() {\n  return this.intlCurrencyCode_ ||\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().DEF_CURRENCY_CODE;\n};\n\n\n/**\n * Sets minimum number of fraction digits.\n * @param {number} min the minimum.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setMinimumFractionDigits = function(min) {\n  if (this.significantDigits_ > 0 && min > 0) {\n    throw Error(\n        'Can\\'t combine significant digits and minimum fraction digits');\n  }\n  this.minimumFractionDigits_ = min;\n  return this;\n};\n\n\n/**\n * Sets maximum number of fraction digits.\n * @param {number} max the maximum.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setMaximumFractionDigits = function(max) {\n  if (max > 308) {\n    // Math.pow(10, 309) becomes Infinity which breaks the logic in this class.\n    throw Error('Unsupported maximum fraction digits: ' + max);\n  }\n  this.maximumFractionDigits_ = max;\n  return this;\n};\n\n\n/**\n * Sets number of significant digits to show. Only fractions will be rounded.\n * Regardless of the number of significant digits set, the number of fractional\n * digits shown will always be capped by the maximum number of fractional digits\n * set on {@link #setMaximumFractionDigits}.\n * @param {number} number The number of significant digits to include.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setSignificantDigits = function(number) {\n  if (this.minimumFractionDigits_ > 0 && number >= 0) {\n    throw Error(\n        'Can\\'t combine significant digits and minimum fraction digits');\n  }\n  this.significantDigits_ = number;\n  return this;\n};\n\n\n/**\n * Gets number of significant digits to show. Only fractions will be rounded.\n * @return {number} The number of significant digits to include.\n */\ngoog.i18n.NumberFormat.prototype.getSignificantDigits = function() {\n  return this.significantDigits_;\n};\n\n\n/**\n * Sets whether trailing fraction zeros should be shown when significantDigits_\n * is positive. If this is true and significantDigits_ is 2, 1 will be formatted\n * as '1.0'.\n * @param {boolean} showTrailingZeros Whether trailing zeros should be shown.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setShowTrailingZeros = function(\n    showTrailingZeros) {\n  this.showTrailingZeros_ = showTrailingZeros;\n  return this;\n};\n\n\n/**\n * Sets a number to base the formatting on when compact style formatting is\n * used. If this is null, the formatting should be based only on the number to\n * be formatting.\n *\n * This base formatting number can be used to format the target number as\n * another number would be formatted. For example, 100,000 is normally formatted\n * as \"100K\" in the COMPACT_SHORT format. To instead format it as '0.1M', the\n * base number could be set to 1,000,000 in order to force all numbers to be\n * formatted in millions. Similarly, 1,000,000,000 would normally be formatted\n * as '1B' and setting the base formatting number to 1,000,000, would cause it\n * to be formatted instead as '1,000M'.\n *\n * @param {?number} baseFormattingNumber The number to base formatting on, or\n * null if formatting should not be based on another number.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setBaseFormatting = function(\n    baseFormattingNumber) {\n  goog.asserts.assert(\n      goog.isNull(baseFormattingNumber) || isFinite(baseFormattingNumber));\n  this.baseFormattingNumber_ = baseFormattingNumber;\n  return this;\n};\n\n\n/**\n * Gets the number on which compact formatting is currently based, or null if\n * no such number is set. See setBaseFormatting() for more information.\n * @return {?number}\n */\ngoog.i18n.NumberFormat.prototype.getBaseFormatting = function() {\n  return this.baseFormattingNumber_;\n};\n\n\n/**\n * Apply provided pattern, result are stored in member variables.\n *\n * @param {string} pattern String pattern being applied.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.applyPattern_ = function(pattern) {\n  this.pattern_ = pattern.replace(/ /g, '\\u00a0');\n  var pos = [0];\n\n  this.positivePrefix_ = this.parseAffix_(pattern, pos);\n  var trunkStart = pos[0];\n  this.parseTrunk_(pattern, pos);\n  var trunkLen = pos[0] - trunkStart;\n  this.positiveSuffix_ = this.parseAffix_(pattern, pos);\n  if (pos[0] < pattern.length &&\n      pattern.charAt(pos[0]) == goog.i18n.NumberFormat.PATTERN_SEPARATOR_) {\n    pos[0]++;\n    if (this.multiplier_ != 1) this.negativePercentSignExpected_ = true;\n    this.negativePrefix_ = this.parseAffix_(pattern, pos);\n    // we assume this part is identical to positive part.\n    // user must make sure the pattern is correctly constructed.\n    pos[0] += trunkLen;\n    this.negativeSuffix_ = this.parseAffix_(pattern, pos);\n  } else {\n    // if no negative affix specified, they share the same positive affix\n    this.negativePrefix_ += this.positivePrefix_;\n    this.negativeSuffix_ += this.positiveSuffix_;\n  }\n};\n\n\n/**\n * Apply a predefined pattern to NumberFormat object.\n * @param {number} patternType The number that indicates a predefined number\n *     format pattern.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.applyStandardPattern_ = function(patternType) {\n  switch (patternType) {\n    case goog.i18n.NumberFormat.Format.DECIMAL:\n      this.applyPattern_(\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.SCIENTIFIC:\n      this.applyPattern_(\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().SCIENTIFIC_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.PERCENT:\n      this.applyPattern_(\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.CURRENCY:\n      this.applyPattern_(goog.i18n.currency.adjustPrecision(\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().CURRENCY_PATTERN,\n          this.getCurrencyCode_()));\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_SHORT:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.SHORT);\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_LONG:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.LONG);\n      break;\n    default:\n      throw Error('Unsupported pattern type.');\n  }\n};\n\n\n/**\n * Apply a predefined pattern for shorthand formats.\n * @param {goog.i18n.NumberFormat.CompactStyle} style the compact style to\n *     set defaults for.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.applyCompactStyle_ = function(style) {\n  this.compactStyle_ = style;\n  this.applyPattern_(\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_PATTERN);\n  this.setMinimumFractionDigits(0);\n  this.setMaximumFractionDigits(2);\n  this.setSignificantDigits(2);\n};\n\n\n/**\n * Parses text string to produce a Number.\n *\n * This method attempts to parse text starting from position \"opt_pos\" if it\n * is given. Otherwise the parse will start from the beginning of the text.\n * When opt_pos presents, opt_pos will be updated to the character next to where\n * parsing stops after the call. If an error occurs, opt_pos won't be updated.\n *\n * @param {string} text The string to be parsed.\n * @param {Array<number>=} opt_pos Position to pass in and get back.\n * @return {number} Parsed number. This throws an error if the text cannot be\n *     parsed.\n */\ngoog.i18n.NumberFormat.prototype.parse = function(text, opt_pos) {\n  var pos = opt_pos || [0];\n\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw Error('Parsing of compact numbers is unimplemented');\n  }\n\n  var ret = NaN;\n\n  // we don't want to handle 2 kind of space in parsing, normalize it to nbsp\n  text = text.replace(/ /g, '\\u00a0');\n\n  var gotPositive = text.indexOf(this.positivePrefix_, pos[0]) == pos[0];\n  var gotNegative = text.indexOf(this.negativePrefix_, pos[0]) == pos[0];\n\n  // check for the longest match\n  if (gotPositive && gotNegative) {\n    if (this.positivePrefix_.length > this.negativePrefix_.length) {\n      gotNegative = false;\n    } else if (this.positivePrefix_.length < this.negativePrefix_.length) {\n      gotPositive = false;\n    }\n  }\n\n  if (gotPositive) {\n    pos[0] += this.positivePrefix_.length;\n  } else if (gotNegative) {\n    pos[0] += this.negativePrefix_.length;\n  }\n\n  // process digits or Inf, find decimal position\n  if (text.indexOf(\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY, pos[0]) ==\n      pos[0]) {\n    pos[0] += goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY.length;\n    ret = Infinity;\n  } else {\n    ret = this.parseNumber_(text, pos);\n  }\n\n  // check for suffix\n  if (gotPositive) {\n    if (!(text.indexOf(this.positiveSuffix_, pos[0]) == pos[0])) {\n      return NaN;\n    }\n    pos[0] += this.positiveSuffix_.length;\n  } else if (gotNegative) {\n    if (!(text.indexOf(this.negativeSuffix_, pos[0]) == pos[0])) {\n      return NaN;\n    }\n    pos[0] += this.negativeSuffix_.length;\n  }\n\n  return gotNegative ? -ret : ret;\n};\n\n\n/**\n * This function will parse a \"localized\" text into a Number. It needs to\n * handle locale specific decimal, grouping, exponent and digits.\n *\n * @param {string} text The text that need to be parsed.\n * @param {Array<number>} pos  In/out parsing position. In case of failure,\n *    pos value won't be changed.\n * @return {number} Number value, or NaN if nothing can be parsed.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.parseNumber_ = function(text, pos) {\n  var sawDecimal = false;\n  var sawExponent = false;\n  var sawDigit = false;\n  var exponentPos = -1;\n  var scale = 1;\n  var decimal = goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_SEP;\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\n  var exponentChar =\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().EXP_SYMBOL;\n\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw Error('Parsing of compact style numbers is not implemented');\n  }\n\n  var normalizedText = '';\n  for (; pos[0] < text.length; pos[0]++) {\n    var ch = text.charAt(pos[0]);\n    var digit = this.getDigit_(ch);\n    if (digit >= 0 && digit <= 9) {\n      normalizedText += digit;\n      sawDigit = true;\n    } else if (ch == decimal.charAt(0)) {\n      if (sawDecimal || sawExponent) {\n        break;\n      }\n      normalizedText += '.';\n      sawDecimal = true;\n    } else if (\n        ch == grouping.charAt(0) &&\n        ('\\u00a0' != grouping.charAt(0) ||\n         pos[0] + 1 < text.length &&\n             this.getDigit_(text.charAt(pos[0] + 1)) >= 0)) {\n      // Got a grouping character here. When grouping character is nbsp, need\n      // to make sure the character following it is a digit.\n      if (sawDecimal || sawExponent) {\n        break;\n      }\n      continue;\n    } else if (ch == exponentChar.charAt(0)) {\n      if (sawExponent) {\n        break;\n      }\n      normalizedText += 'E';\n      sawExponent = true;\n      exponentPos = pos[0];\n    } else if (ch == '+' || ch == '-') {\n      // Stop parsing if a '+' or '-' sign is found after digits have been found\n      // but it's not located right after an exponent sign.\n      if (sawDigit && exponentPos != pos[0] - 1) {\n        break;\n      }\n      normalizedText += ch;\n    } else if (\n        this.multiplier_ == 1 &&\n        ch ==\n            goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT.charAt(\n                0)) {\n      // Parse the percent character as part of the number only when it's\n      // not already included in the pattern.\n      if (scale != 1) {\n        break;\n      }\n      scale = 100;\n      if (sawDigit) {\n        pos[0]++;  // eat this character if parse end here\n        break;\n      }\n    } else if (\n        this.multiplier_ == 1 &&\n        ch ==\n            goog.i18n.NumberFormat.getNumberFormatSymbols_().PERMILL.charAt(\n                0)) {\n      // Parse the permill character as part of the number only when it's\n      // not already included in the pattern.\n      if (scale != 1) {\n        break;\n      }\n      scale = 1000;\n      if (sawDigit) {\n        pos[0]++;  // eat this character if parse end here\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n\n  // Scale the number when the percent/permill character was included in\n  // the pattern.\n  if (this.multiplier_ != 1) {\n    scale = this.multiplier_;\n  }\n\n  return parseFloat(normalizedText) / scale;\n};\n\n\n/**\n * Formats a Number to produce a string.\n *\n * @param {number} number The Number to be formatted.\n * @return {string} The formatted number string.\n */\ngoog.i18n.NumberFormat.prototype.format = function(number) {\n  if (isNaN(number)) {\n    return goog.i18n.NumberFormat.getNumberFormatSymbols_().NAN;\n  }\n\n  var parts = [];\n  var baseFormattingNumber = goog.isNull(this.baseFormattingNumber_) ?\n      number :\n      this.baseFormattingNumber_;\n  var unit = this.getUnitAfterRounding_(baseFormattingNumber, number);\n  number /= Math.pow(10, unit.divisorBase);\n\n  parts.push(unit.prefix);\n\n  // in icu code, it is commented that certain computation need to keep the\n  // negative sign for 0.\n  var isNegative = number < 0.0 || number == 0.0 && 1 / number < 0.0;\n\n  parts.push(isNegative ? this.negativePrefix_ : this.positivePrefix_);\n\n  if (!isFinite(number)) {\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY);\n  } else {\n    // convert number to non-negative value\n    number *= isNegative ? -1 : 1;\n\n    number *= this.multiplier_;\n    this.useExponentialNotation_ ?\n        this.subformatExponential_(number, parts) :\n        this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n  }\n\n  parts.push(isNegative ? this.negativeSuffix_ : this.positiveSuffix_);\n  parts.push(unit.suffix);\n\n  return parts.join('');\n};\n\n\n/**\n * Round a number into an integer and fractional part\n * based on the rounding rules for this NumberFormat.\n * @param {number} number The number to round.\n * @return {{intValue: number, fracValue: number}} The integer and fractional\n *     part after rounding.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.roundNumber_ = function(number) {\n  var power = Math.pow(10, this.maximumFractionDigits_);\n  var shiftedNumber = this.significantDigits_ <= 0 ?\n      Math.round(number * power) :\n      Math.round(\n          this.roundToSignificantDigits_(\n              number * power, this.significantDigits_,\n              this.maximumFractionDigits_));\n\n  var intValue, fracValue;\n  if (isFinite(shiftedNumber)) {\n    intValue = Math.floor(shiftedNumber / power);\n    fracValue = Math.floor(shiftedNumber - intValue * power);\n  } else {\n    intValue = number;\n    fracValue = 0;\n  }\n  return {intValue: intValue, fracValue: fracValue};\n};\n\n\n/**\n * Formats a number with the appropriate groupings when there are repeating\n * digits present. Repeating digits exists when the length of the digits left\n * of the decimal place exceeds the number of non-repeating digits.\n *\n * Formats a number by iterating through the integer number (intPart) from the\n * most left of the decimal place by inserting the appropriate number grouping\n * separator for the repeating digits until all of the repeating digits is\n * iterated. Then iterate through the non-repeating digits by inserting the\n * appropriate number grouping separator until all the non-repeating digits\n * is iterated through.\n *\n * In the number grouping concept, anything left of the decimal\n * place is followed by non-repeating digits and then repeating digits. If the\n * pattern is #,##,###, then we first (from the left of the decimal place) have\n * a non-repeating digit of size 3 followed by repeating digits of size 2\n * separated by a thousand separator. If the length of the digits are six or\n * more, there may be repeating digits required. For example, the value of\n * 12345678 would format as 1,23,45,678 where the repeating digit is length 2.\n *\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\n *  number including the values and separators.\n * @param {number} zeroCode The value of the zero digit whether or not\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\n * @param {string} intPart The integer representation of the number to be\n *  formatted and referenced.\n * @param {!Array<number>} groupingArray The array of numbers to determine the\n *  grouping of repeated and non-repeated digits.\n * @param {number} repeatedDigitLen The length of the repeated digits left of\n *  the non-repeating digits left of the decimal.\n * @return {!Array<string>} Returns the resulting parts variable containing\n *  how numbers are to be grouped and appear.\n * @private\n */\ngoog.i18n.NumberFormat.formatNumberGroupingRepeatingDigitsParts_ = function(\n    parts, zeroCode, intPart, groupingArray, repeatedDigitLen) {\n  // Keep track of how much has been completed on the non repeated groups\n  var nonRepeatedGroupCompleteCount = 0;\n  var currentGroupSizeIndex = 0;\n  var currentGroupSize = 0;\n\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\n  var digitLen = intPart.length;\n\n  // There are repeating digits and non-repeating digits\n  for (var i = 0; i < digitLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(i)) * 1));\n    if (digitLen - i > 1) {\n      currentGroupSize = groupingArray[currentGroupSizeIndex];\n      if (i < repeatedDigitLen) {\n        // Process the left side (the repeated number groups)\n        var repeatedDigitIndex = repeatedDigitLen - i;\n        // Edge case if there's a number grouping asking for \"1\" group at\n        // a time; otherwise, if the remainder is 1, there's the separator\n        if (currentGroupSize === 1 ||\n            (currentGroupSize > 0 &&\n             (repeatedDigitIndex % currentGroupSize) === 1)) {\n          parts.push(grouping);\n        }\n      } else if (currentGroupSizeIndex < groupingArray.length) {\n        // Process the right side (the non-repeated fixed number groups)\n        if (i === repeatedDigitLen) {\n          // Increase the group index because a separator\n          // has previously added in the earlier logic\n          currentGroupSizeIndex += 1;\n        } else if (\n            currentGroupSize ===\n            i - repeatedDigitLen - nonRepeatedGroupCompleteCount + 1) {\n          // Otherwise, just iterate to the right side and\n          // add a separator once the length matches to the expected\n          parts.push(grouping);\n          // Keep track of what has been completed on the right\n          nonRepeatedGroupCompleteCount += currentGroupSize;\n          currentGroupSizeIndex += 1;  // Get to the next number grouping\n        }\n      }\n    }\n  }\n  return parts;\n};\n\n\n/**\n * Formats a number with the appropriate groupings when there are no repeating\n * digits present. Non-repeating digits exists when the length of the digits\n * left of the decimal place is equal or lesser than the length of\n * non-repeating digits.\n *\n * Formats a number by iterating through the integer number (intPart) from the\n * right most non-repeating number group of the decimal place. For each group,\n * inserting the appropriate number grouping separator for the non-repeating\n * digits until the number is completely iterated.\n *\n * In the number grouping concept, anything left of the decimal\n * place is followed by non-repeating digits and then repeating digits. If the\n * pattern is #,##,###, then we first (from the left of the decimal place) have\n * a non-repeating digit of size 3 followed by repeating digits of size 2\n * separated by a thousand separator. If the length of the digits are five or\n * less, there won't be any repeating digits required. For example, the value\n * of 12345 would be formatted as 12,345 where the non-repeating digit is of\n * length 3.\n *\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\n *  number including the values and separators.\n * @param {number} zeroCode The value of the zero digit whether or not\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\n * @param {string} intPart The integer representation of the number to be\n *  formatted and referenced.\n * @param {!Array<number>} groupingArray The array of numbers to determine the\n *  grouping of repeated and non-repeated digits.\n * @return {!Array<string>} Returns the resulting parts variable containing\n *  how numbers are to be grouped and appear.\n * @private\n */\ngoog.i18n.NumberFormat.formatNumberGroupingNonRepeatingDigitsParts_ = function(\n    parts, zeroCode, intPart, groupingArray) {\n  // Keep track of how much has been completed on the non repeated groups\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\n  var currentGroupSizeIndex;\n  var currentGroupSize = 0;\n  var digitLenLeft = intPart.length;\n  var rightToLeftParts = [];\n\n  // Start from the right most non-repeating group and work inwards\n  for (currentGroupSizeIndex = groupingArray.length - 1;\n       currentGroupSizeIndex >= 0 && digitLenLeft > 0;\n       currentGroupSizeIndex--) {\n    currentGroupSize = groupingArray[currentGroupSizeIndex];\n    // Iterate from the right most digit\n    for (var rightDigitIndex = 0; rightDigitIndex < currentGroupSize &&\n         ((digitLenLeft - rightDigitIndex - 1) >= 0);\n         rightDigitIndex++) {\n      rightToLeftParts.push(\n          String.fromCharCode(\n              zeroCode +\n              Number(intPart.charAt(digitLenLeft - rightDigitIndex - 1)) * 1));\n    }\n    // Update the number of digits left\n    digitLenLeft -= currentGroupSize;\n    if (digitLenLeft > 0) {\n      rightToLeftParts.push(grouping);\n    }\n  }\n  // Reverse and push onto the remaining parts\n  parts.push.apply(parts, rightToLeftParts.reverse());\n\n  return parts;\n};\n\n\n/**\n * Formats a Number in fraction format.\n *\n * @param {number} number\n * @param {number} minIntDigits Minimum integer digits.\n * @param {Array<string>} parts\n *     This array holds the pieces of formatted string.\n *     This function will add its formatted pieces to the array.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.subformatFixed_ = function(\n    number, minIntDigits, parts) {\n  if (this.minimumFractionDigits_ > this.maximumFractionDigits_) {\n    throw Error('Min value must be less than max value');\n  }\n\n  if (!parts) {\n    parts = [];\n  }\n\n  var rounded = this.roundNumber_(number);\n  var intValue = rounded.intValue;\n  var fracValue = rounded.fracValue;\n\n  var numIntDigits = (intValue == 0) ? 0 : this.intLog10_(intValue) + 1;\n  var fractionPresent = this.minimumFractionDigits_ > 0 || fracValue > 0 ||\n      (this.showTrailingZeros_ && numIntDigits < this.significantDigits_);\n  var minimumFractionDigits = this.minimumFractionDigits_;\n  if (fractionPresent) {\n    if (this.showTrailingZeros_ && this.significantDigits_ > 0) {\n      minimumFractionDigits = this.significantDigits_ - numIntDigits;\n    } else {\n      minimumFractionDigits = this.minimumFractionDigits_;\n    }\n  }\n\n  var intPart = '';\n  var translatableInt = intValue;\n  while (translatableInt > 1E20) {\n    // here it goes beyond double precision, add '0' make it look better\n    intPart = '0' + intPart;\n    translatableInt = Math.round(translatableInt / 10);\n  }\n  intPart = translatableInt + intPart;\n\n  var decimal = goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_SEP;\n  var zeroCode =\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\n  var digitLen = intPart.length;\n  var nonRepeatedGroupCount = 0;\n\n  if (intValue > 0 || minIntDigits > 0) {\n    for (var i = digitLen; i < minIntDigits; i++) {\n      parts.push(String.fromCharCode(zeroCode));\n    }\n\n    // If there's more than 1 number grouping,\n    // figure out the length of the non-repeated groupings (on the right)\n    if (this.groupingArray_.length >= 2) {\n      for (var j = 1; j < this.groupingArray_.length; j++) {\n        nonRepeatedGroupCount += this.groupingArray_[j];\n      }\n    }\n\n    // Anything left of the fixed number grouping is repeated,\n    // figure out the length of repeated groupings (on the left)\n    var repeatedDigitLen = digitLen - nonRepeatedGroupCount;\n    if (repeatedDigitLen > 0) {\n      // There are repeating digits and non-repeating digits\n      parts = goog.i18n.NumberFormat.formatNumberGroupingRepeatingDigitsParts_(\n          parts, zeroCode, intPart, this.groupingArray_, repeatedDigitLen);\n    } else {\n      // There are no repeating digits and only non-repeating digits\n      parts =\n          goog.i18n.NumberFormat.formatNumberGroupingNonRepeatingDigitsParts_(\n              parts, zeroCode, intPart, this.groupingArray_);\n    }\n  } else if (!fractionPresent) {\n    // If there is no fraction present, and we haven't printed any\n    // integer digits, then print a zero.\n    parts.push(String.fromCharCode(zeroCode));\n  }\n\n  // Output the decimal separator if we always do so.\n  if (this.decimalSeparatorAlwaysShown_ || fractionPresent) {\n    parts.push(decimal);\n  }\n\n  var fracPart = String(fracValue);\n  // Handle case where fracPart is in scientific notation.\n  var fracPartSplit = fracPart.split('e+');\n  if (fracPartSplit.length == 2) {\n    // Only keep significant digits.\n    var floatFrac = parseFloat(fracPartSplit[0]);\n    fracPart = String(\n        this.roundToSignificantDigits_(floatFrac, this.significantDigits_, 1));\n    fracPart = fracPart.replace('.', '');\n    // Append zeroes based on the exponent.\n    var exp = parseInt(fracPartSplit[1], 10);\n    fracPart += goog.string.repeat('0', exp - fracPart.length + 1);\n  }\n\n  // Add Math.pow(10, this.maximumFractionDigits) to fracPart. Uses string ops\n  // to avoid complexity with scientific notation and overflows.\n  if (this.maximumFractionDigits_ + 1 > fracPart.length) {\n    var zeroesToAdd = this.maximumFractionDigits_ - fracPart.length;\n    fracPart = '1' + goog.string.repeat('0', zeroesToAdd) + fracPart;\n  }\n\n  var fracLen = fracPart.length;\n  while (fracPart.charAt(fracLen - 1) == '0' &&\n         fracLen > minimumFractionDigits + 1) {\n    fracLen--;\n  }\n\n  for (var i = 1; i < fracLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(fracPart.charAt(i)) * 1));\n  }\n};\n\n\n/**\n * Formats exponent part of a Number.\n *\n * @param {number} exponent Exponential value.\n * @param {Array<string>} parts The array that holds the pieces of formatted\n *     string. This function will append more formatted pieces to the array.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.addExponentPart_ = function(exponent, parts) {\n  parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().EXP_SYMBOL);\n\n  if (exponent < 0) {\n    exponent = -exponent;\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().MINUS_SIGN);\n  } else if (this.useSignForPositiveExponent_) {\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().PLUS_SIGN);\n  }\n\n  var exponentDigits = '' + exponent;\n  var zeroChar = goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT;\n  for (var i = exponentDigits.length; i < this.minExponentDigits_; i++) {\n    parts.push(zeroChar);\n  }\n  parts.push(exponentDigits);\n};\n\n/**\n * Returns the mantissa for the given value and its exponent.\n *\n * @param {number} value\n * @param {number} exponent\n * @return {number}\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getMantissa_ = function(value, exponent) {\n  var divisor = Math.pow(10, exponent);\n  if (isFinite(divisor) && divisor !== 0) {\n    return value / divisor;\n  } else {\n    // If the exponent is too big pow returns 0. In such a case we calculate\n    // half of the divisor and apply it twice.\n    divisor = Math.pow(10, Math.floor(exponent / 2));\n    var result = value / divisor / divisor;\n    if (exponent % 2 == 1) {  // Correcting for odd exponents.\n      if (exponent > 0) {\n        result /= 10;\n      } else {\n        result *= 10;\n      }\n    }\n    return result;\n  }\n};\n\n/**\n * Formats Number in exponential format.\n *\n * @param {number} number Value need to be formatted.\n * @param {Array<string>} parts The array that holds the pieces of formatted\n *     string. This function will append more formatted pieces to the array.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.subformatExponential_ = function(\n    number, parts) {\n  if (number == 0.0) {\n    this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n    this.addExponentPart_(0, parts);\n    return;\n  }\n\n  var exponent = goog.math.safeFloor(Math.log(number) / Math.log(10));\n  number = this.getMantissa_(number, exponent);\n\n  var minIntDigits = this.minimumIntegerDigits_;\n  if (this.maximumIntegerDigits_ > 1 &&\n      this.maximumIntegerDigits_ > this.minimumIntegerDigits_) {\n    // A repeating range is defined; adjust to it as follows.\n    // If repeat == 3, we have 6,5,4=>3; 3,2,1=>0; 0,-1,-2=>-3;\n    // -3,-4,-5=>-6, etc. This takes into account that the\n    // exponent we have here is off by one from what we expect;\n    // it is for the format 0.MMMMMx10^n.\n    while ((exponent % this.maximumIntegerDigits_) != 0) {\n      number *= 10;\n      exponent--;\n    }\n    minIntDigits = 1;\n  } else {\n    // No repeating range is defined; use minimum integer digits.\n    if (this.minimumIntegerDigits_ < 1) {\n      exponent++;\n      number /= 10;\n    } else {\n      exponent -= this.minimumIntegerDigits_ - 1;\n      number *= Math.pow(10, this.minimumIntegerDigits_ - 1);\n    }\n  }\n  this.subformatFixed_(number, minIntDigits, parts);\n  this.addExponentPart_(exponent, parts);\n};\n\n\n/**\n * Returns the digit value of current character. The character could be either\n * '0' to '9', or a locale specific digit.\n *\n * @param {string} ch Character that represents a digit.\n * @return {number} The digit value, or -1 on error.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getDigit_ = function(ch) {\n  var code = ch.charCodeAt(0);\n  // between '0' to '9'\n  if (48 <= code && code < 58) {\n    return code - 48;\n  } else {\n    var zeroCode =\n        goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(\n            0);\n    return zeroCode <= code && code < zeroCode + 10 ? code - zeroCode : -1;\n  }\n};\n\n\n// ----------------------------------------------------------------------\n// CONSTANTS\n// ----------------------------------------------------------------------\n// Constants for characters used in programmatic (unlocalized) patterns.\n/**\n * A zero digit character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_ = '0';\n\n\n/**\n * A grouping separator character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_ = ',';\n\n\n/**\n * A decimal separator character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_ = '.';\n\n\n/**\n * A per mille character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_PER_MILLE_ = '\\u2030';\n\n\n/**\n * A percent character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_PERCENT_ = '%';\n\n\n/**\n * A digit character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_DIGIT_ = '#';\n\n\n/**\n * A separator character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_SEPARATOR_ = ';';\n\n\n/**\n * An exponent character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_EXPONENT_ = 'E';\n\n\n/**\n * A plus character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_PLUS_ = '+';\n\n\n/**\n * A generic currency sign character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_ = '\\u00A4';\n\n\n/**\n * A quote character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.QUOTE_ = '\\'';\n\n\n/**\n * Parses affix part of pattern.\n *\n * @param {string} pattern Pattern string that need to be parsed.\n * @param {Array<number>} pos One element position array to set and receive\n *     parsing position.\n *\n * @return {string} Affix received from parsing.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.parseAffix_ = function(pattern, pos) {\n  var affix = '';\n  var inQuote = false;\n  var len = pattern.length;\n\n  for (; pos[0] < len; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    if (ch == goog.i18n.NumberFormat.QUOTE_) {\n      if (pos[0] + 1 < len &&\n          pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.QUOTE_) {\n        pos[0]++;\n        affix += '\\'';  // 'don''t'\n      } else {\n        inQuote = !inQuote;\n      }\n      continue;\n    }\n\n    if (inQuote) {\n      affix += ch;\n    } else {\n      switch (ch) {\n        case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_SEPARATOR_:\n          return affix;\n        case goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_:\n          if ((pos[0] + 1) < len &&\n              pattern.charAt(pos[0] + 1) ==\n                  goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_) {\n            pos[0]++;\n            affix += this.getCurrencyCode_();\n          } else {\n            switch (this.currencyStyle_) {\n              case goog.i18n.NumberFormat.CurrencyStyle.LOCAL:\n                affix += goog.i18n.currency.getLocalCurrencySign(\n                    this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.GLOBAL:\n                affix += goog.i18n.currency.getGlobalCurrencySign(\n                    this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.PORTABLE:\n                affix += goog.i18n.currency.getPortableCurrencySign(\n                    this.getCurrencyCode_());\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PERCENT_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw Error('Too many percent/permill');\n          } else if (\n              this.negativePercentSignExpected_ && this.multiplier_ != 100) {\n            throw Error('Inconsistent use of percent/permill characters');\n          }\n          this.multiplier_ = 100;\n          this.negativePercentSignExpected_ = false;\n          affix += goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT;\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PER_MILLE_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw Error('Too many percent/permill');\n          } else if (\n              this.negativePercentSignExpected_ && this.multiplier_ != 1000) {\n            throw Error('Inconsistent use of percent/permill characters');\n          }\n          this.multiplier_ = 1000;\n          this.negativePercentSignExpected_ = false;\n          affix += goog.i18n.NumberFormat.getNumberFormatSymbols_().PERMILL;\n          break;\n        default:\n          affix += ch;\n      }\n    }\n  }\n\n  return affix;\n};\n\n\n/**\n * Parses the trunk part of a pattern.\n *\n * @param {string} pattern Pattern string that need to be parsed.\n * @param {Array<number>} pos One element position array to set and receive\n *     parsing position.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.parseTrunk_ = function(pattern, pos) {\n  var decimalPos = -1;\n  var digitLeftCount = 0;\n  var zeroDigitCount = 0;\n  var digitRightCount = 0;\n  var groupingCount = -1;\n  var len = pattern.length;\n  for (var loop = true; pos[0] < len && loop; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    switch (ch) {\n      case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        if (zeroDigitCount > 0) {\n          digitRightCount++;\n        } else {\n          digitLeftCount++;\n        }\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        if (digitRightCount > 0) {\n          throw Error('Unexpected \"0\" in pattern \"' + pattern + '\"');\n        }\n        zeroDigitCount++;\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        if (groupingCount > 0) {\n          this.groupingArray_.push(groupingCount);\n        }\n        groupingCount = 0;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        if (decimalPos >= 0) {\n          throw Error(\n              'Multiple decimal separators in pattern \"' + pattern + '\"');\n        }\n        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_EXPONENT_:\n        if (this.useExponentialNotation_) {\n          throw Error(\n              'Multiple exponential symbols in pattern \"' + pattern + '\"');\n        }\n        this.useExponentialNotation_ = true;\n        this.minExponentDigits_ = 0;\n\n        // exponent pattern can have a optional '+'.\n        if ((pos[0] + 1) < len &&\n            pattern.charAt(pos[0] + 1) ==\n                goog.i18n.NumberFormat.PATTERN_PLUS_) {\n          pos[0]++;\n          this.useSignForPositiveExponent_ = true;\n        }\n\n        // Use lookahead to parse out the exponential part\n        // of the pattern, then jump into phase 2.\n        while ((pos[0] + 1) < len &&\n               pattern.charAt(pos[0] + 1) ==\n                   goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_) {\n          pos[0]++;\n          this.minExponentDigits_++;\n        }\n\n        if ((digitLeftCount + zeroDigitCount) < 1 ||\n            this.minExponentDigits_ < 1) {\n          throw Error('Malformed exponential pattern \"' + pattern + '\"');\n        }\n        loop = false;\n        break;\n      default:\n        pos[0]--;\n        loop = false;\n        break;\n    }\n  }\n\n  if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {\n    // Handle '###.###' and '###.' and '.###'\n    var n = decimalPos;\n    if (n == 0) {  // Handle '.###'\n      n++;\n    }\n    digitRightCount = digitLeftCount - n;\n    digitLeftCount = n - 1;\n    zeroDigitCount = 1;\n  }\n\n  // Do syntax checking on the digits.\n  if (decimalPos < 0 && digitRightCount > 0 ||\n      decimalPos >= 0 && (decimalPos < digitLeftCount ||\n                          decimalPos > digitLeftCount + zeroDigitCount) ||\n      groupingCount == 0) {\n    throw Error('Malformed pattern \"' + pattern + '\"');\n  }\n  var totalDigits = digitLeftCount + zeroDigitCount + digitRightCount;\n\n  this.maximumFractionDigits_ = decimalPos >= 0 ? totalDigits - decimalPos : 0;\n  if (decimalPos >= 0) {\n    this.minimumFractionDigits_ = digitLeftCount + zeroDigitCount - decimalPos;\n    if (this.minimumFractionDigits_ < 0) {\n      this.minimumFractionDigits_ = 0;\n    }\n  }\n\n  // The effectiveDecimalPos is the position the decimal is at or would be at\n  // if there is no decimal. Note that if decimalPos<0, then digitTotalCount ==\n  // digitLeftCount + zeroDigitCount.\n  var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : totalDigits;\n  this.minimumIntegerDigits_ = effectiveDecimalPos - digitLeftCount;\n  if (this.useExponentialNotation_) {\n    this.maximumIntegerDigits_ = digitLeftCount + this.minimumIntegerDigits_;\n\n    // in exponential display, we need to at least show something.\n    if (this.maximumFractionDigits_ == 0 && this.minimumIntegerDigits_ == 0) {\n      this.minimumIntegerDigits_ = 1;\n    }\n  }\n\n  // Add another number grouping at the end\n  this.groupingArray_.push(Math.max(0, groupingCount));\n  this.decimalSeparatorAlwaysShown_ =\n      decimalPos == 0 || decimalPos == totalDigits;\n};\n\n\n/**\n * Alias for the compact format 'unit' object.\n * @typedef {{\n *     prefix: string,\n *     suffix: string,\n *     divisorBase: number\n * }}\n */\ngoog.i18n.NumberFormat.CompactNumberUnit;\n\n\n/**\n * The empty unit, corresponding to a base of 0.\n * @private {!goog.i18n.NumberFormat.CompactNumberUnit}\n */\ngoog.i18n.NumberFormat.NULL_UNIT_ = {\n  prefix: '',\n  suffix: '',\n  divisorBase: 0\n};\n\n\n/**\n * Get compact unit for a certain number of digits\n *\n * @param {number} base The number of digits to get the unit for.\n * @param {string} plurality The plurality of the number.\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The compact unit.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getUnitFor_ = function(base, plurality) {\n  var table = this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.SHORT ?\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN :\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_LONG_PATTERN;\n\n  if (!goog.isDefAndNotNull(table)) {\n    table = goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN;\n  }\n\n  if (base < 3) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  } else {\n    base = Math.min(14, base);\n    var patterns = table[Math.pow(10, base)];\n    var previousNonNullBase = base - 1;\n    while (!patterns && previousNonNullBase >= 3) {\n      patterns = table[Math.pow(10, previousNonNullBase)];\n      previousNonNullBase--;\n    }\n    if (!patterns) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n\n    var pattern = patterns[plurality];\n    if (!pattern || pattern == '0') {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n\n    var parts = /([^0]*)(0+)(.*)/.exec(pattern);\n    if (!parts) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n\n    return {\n      prefix: parts[1],\n      suffix: parts[3],\n      divisorBase: (previousNonNullBase + 1) - (parts[2].length - 1)\n    };\n  }\n};\n\n\n/**\n * Get the compact unit divisor, accounting for rounding of the quantity.\n *\n * @param {number} formattingNumber The number to base the formatting on. The\n *     unit will be calculated from this number.\n * @param {number} pluralityNumber The number to use for calculating the\n *     plurality.\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The unit after rounding.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getUnitAfterRounding_ = function(\n    formattingNumber, pluralityNumber) {\n  if (this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.NONE) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  }\n\n  formattingNumber = Math.abs(formattingNumber);\n  pluralityNumber = Math.abs(pluralityNumber);\n\n  var initialPlurality = this.pluralForm_(formattingNumber);\n  // Compute the exponent from the formattingNumber, to compute the unit.\n  var base = formattingNumber <= 1 ? 0 : this.intLog10_(formattingNumber);\n  var initialDivisor = this.getUnitFor_(base, initialPlurality).divisorBase;\n  // Round both numbers based on the unit used.\n  var pluralityAttempt = pluralityNumber / Math.pow(10, initialDivisor);\n  var pluralityRounded = this.roundNumber_(pluralityAttempt);\n  var formattingAttempt = formattingNumber / Math.pow(10, initialDivisor);\n  var formattingRounded = this.roundNumber_(formattingAttempt);\n  // Compute the plurality of the pluralityNumber when formatted using the name\n  // units as the formattingNumber.\n  var finalPlurality =\n      this.pluralForm_(pluralityRounded.intValue + pluralityRounded.fracValue);\n  // Get the final unit, using the rounded formatting number to get the correct\n  // unit, and the plurality computed from the pluralityNumber.\n  return this.getUnitFor_(\n      initialDivisor + this.intLog10_(formattingRounded.intValue),\n      finalPlurality);\n};\n\n\n/**\n * Get the integer base 10 logarithm of a number.\n *\n * @param {number} number The number to log.\n * @return {number} The lowest integer n such that 10^n >= number.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.intLog10_ = function(number) {\n  // Handle infinity.\n  if (!isFinite(number)) {\n    return number > 0 ? number : 0;\n  }\n  // Turns out Math.log(1000000)/Math.LN10 is strictly less than 6.\n  var i = 0;\n  while ((number /= 10) >= 1) i++;\n  return i;\n};\n\n\n/**\n * Round to a certain number of significant digits.\n *\n * @param {number} number The number to round.\n * @param {number} significantDigits The number of significant digits\n *     to round to.\n * @param {number} scale Treat number as fixed point times 10^scale.\n * @return {number} The rounded number.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.roundToSignificantDigits_ = function(\n    number, significantDigits, scale) {\n  if (!number) return number;\n\n  var digits = this.intLog10_(number);\n  var magnitude = significantDigits - digits - 1;\n\n  // Only round fraction, not (potentially shifted) integers.\n  if (magnitude < -scale) {\n    var point = Math.pow(10, scale);\n    return Math.round(number / point) * point;\n  }\n\n  var power = Math.pow(10, magnitude);\n  var shifted = Math.round(number * power);\n  return shifted / power;\n};\n\n\n/**\n * Get the plural form of a number.\n * @param {number} quantity The quantity to find plurality of.\n * @return {string} One of 'zero', 'one', 'two', 'few', 'many', 'other'.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.pluralForm_ = function(quantity) {\n  /* TODO: Implement */\n  return 'other';\n};\n\n\n/**\n * Checks if the currency symbol comes before the value ($12) or after (12$)\n * Handy for applications that need to have separate UI fields for the currency\n * value and symbol, especially for input: Price: [USD] [123.45]\n * The currency symbol might be a combo box, or a label.\n *\n * @return {boolean} true if currency is before value.\n */\ngoog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue = function() {\n  var posCurrSymbol = this.pattern_.indexOf('\\u00A4');  // '¤' Currency sign\n  var posPound = this.pattern_.indexOf('#');\n  var posZero = this.pattern_.indexOf('0');\n\n  // posCurrValue is the first '#' or '0' found.\n  // If none of them is found (not possible, but still),\n  // the result is true (postCurrSymbol < MAX_VALUE)\n  // That is OK, matches the en_US and ROOT locales.\n  var posCurrValue = Number.MAX_VALUE;\n  if (posPound >= 0 && posPound < posCurrValue) {\n    posCurrValue = posPound;\n  }\n  if (posZero >= 0 && posZero < posCurrValue) {\n    posCurrValue = posZero;\n  }\n\n  // No need to test, it is guaranteed that both these symbols exist.\n  // If not, we have bigger problems than this.\n  return posCurrSymbol < posCurrValue;\n};\n","~:compiled-at",1574163696252,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.i18n.numberformat.js\",\n\"lineCount\":938,\n\"mappings\":\"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\",\n\"sources\":[\"goog/i18n/numberformat.js\"],\n\"sourcesContent\":[\"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Number format/parse library with locale support.\\n */\\n\\n\\n/**\\n * Namespace for locale number format functions\\n */\\ngoog.provide('goog.i18n.NumberFormat');\\ngoog.provide('goog.i18n.NumberFormat.CurrencyStyle');\\ngoog.provide('goog.i18n.NumberFormat.Format');\\n\\ngoog.require('goog.asserts');\\ngoog.require('goog.i18n.CompactNumberFormatSymbols');\\ngoog.require('goog.i18n.NumberFormatSymbols');\\ngoog.require('goog.i18n.NumberFormatSymbols_u_nu_latn');\\ngoog.require('goog.i18n.currency');\\ngoog.require('goog.math');\\ngoog.require('goog.string');\\n\\n\\n\\n/**\\n * Constructor of NumberFormat.\\n * @param {number|string} pattern The number that indicates a predefined\\n *     number format pattern.\\n * @param {string=} opt_currency Optional international currency\\n *     code. This determines the currency code/symbol used in format/parse. If\\n *     not given, the currency code for current locale will be used.\\n * @param {number=} opt_currencyStyle currency style, value defined in\\n *        goog.i18n.NumberFormat.CurrencyStyle.\\n * @constructor\\n */\\ngoog.i18n.NumberFormat = function(pattern, opt_currency, opt_currencyStyle) {\\n  /** @private {string|undefined} */\\n  this.intlCurrencyCode_ = opt_currency;\\n\\n  /** @private {number} */\\n  this.currencyStyle_ =\\n      opt_currencyStyle || goog.i18n.NumberFormat.CurrencyStyle.LOCAL;\\n\\n  /** @private {number} */\\n  this.maximumIntegerDigits_ = 40;\\n  /** @private {number} */\\n  this.minimumIntegerDigits_ = 1;\\n  /** @private {number} */\\n  this.significantDigits_ = 0;  // invariant, <= maximumFractionDigits\\n  /** @private {number} */\\n  this.maximumFractionDigits_ = 3;  // invariant, >= minFractionDigits\\n  /** @private {number} */\\n  this.minimumFractionDigits_ = 0;\\n  /** @private {number} */\\n  this.minExponentDigits_ = 0;\\n  /** @private {boolean} */\\n  this.useSignForPositiveExponent_ = false;\\n\\n  /**\\n   * Whether to show trailing zeros in the fraction when significantDigits_ is\\n   * positive.\\n   * @private {boolean}\\n   */\\n  this.showTrailingZeros_ = false;\\n\\n  /** @private {string} */\\n  this.positivePrefix_ = '';\\n  /** @private {string} */\\n  this.positiveSuffix_ = '';\\n  /** @private {string} */\\n  this.negativePrefix_ = '-';\\n  /** @private {string} */\\n  this.negativeSuffix_ = '';\\n\\n  // The multiplier for use in percent, per mille, etc.\\n  /** @private {number} */\\n  this.multiplier_ = 1;\\n\\n  /**\\n   * True if the percent/permill sign of the negative pattern is expected.\\n   * @private {!boolean}\\n   */\\n  this.negativePercentSignExpected_ = false;\\n\\n  /**\\n   * The grouping array is used to store the values of each number group\\n   * following left of the decimal place. For example, a number group with\\n   * goog.i18n.NumberFormat('#,##,###') should have [3,2] where 2 is the\\n   * repeated number group following a fixed number grouping of size 3.\\n   * @private {!Array<number>}\\n   */\\n  this.groupingArray_ = [];\\n\\n  /** @private {boolean} */\\n  this.decimalSeparatorAlwaysShown_ = false;\\n  /** @private {boolean} */\\n  this.useExponentialNotation_ = false;\\n  /** @private {goog.i18n.NumberFormat.CompactStyle} */\\n  this.compactStyle_ = goog.i18n.NumberFormat.CompactStyle.NONE;\\n\\n  /**\\n   * The number to base the formatting on when using compact styles, or null\\n   * if formatting should not be based on another number.\\n   * @type {?number}\\n   * @private\\n   */\\n  this.baseFormattingNumber_ = null;\\n\\n  /** @private {string} */\\n  this.pattern_;\\n\\n  if (typeof pattern == 'number') {\\n    this.applyStandardPattern_(pattern);\\n  } else {\\n    this.applyPattern_(pattern);\\n  }\\n};\\n\\n\\n/**\\n * Standard number formatting patterns.\\n * @enum {number}\\n */\\ngoog.i18n.NumberFormat.Format = {\\n  DECIMAL: 1,\\n  SCIENTIFIC: 2,\\n  PERCENT: 3,\\n  CURRENCY: 4,\\n  COMPACT_SHORT: 5,\\n  COMPACT_LONG: 6\\n};\\n\\n\\n/**\\n * Currency styles.\\n * @enum {number}\\n */\\ngoog.i18n.NumberFormat.CurrencyStyle = {\\n  LOCAL: 0,     // currency style as it is used in its circulating country.\\n  PORTABLE: 1,  // currency style that differentiate it from other popular ones.\\n  GLOBAL: 2     // currency style that is unique among all currencies.\\n};\\n\\n\\n/**\\n * Compacting styles.\\n * @enum {number}\\n */\\ngoog.i18n.NumberFormat.CompactStyle = {\\n  NONE: 0,   // Don't compact.\\n  SHORT: 1,  // Short compact form, such as 1.2B.\\n  LONG: 2    // Long compact form, such as 1.2 billion.\\n};\\n\\n\\n/**\\n * If the usage of Ascii digits should be enforced.\\n * @type {boolean}\\n * @private\\n */\\ngoog.i18n.NumberFormat.enforceAsciiDigits_ = false;\\n\\n\\n/**\\n * Set if the usage of Ascii digits in formatting should be enforced.\\n * @param {boolean} doEnforce Boolean value about if Ascii digits should be\\n *     enforced.\\n */\\ngoog.i18n.NumberFormat.setEnforceAsciiDigits = function(doEnforce) {\\n  goog.i18n.NumberFormat.enforceAsciiDigits_ = doEnforce;\\n};\\n\\n\\n/**\\n * Return if Ascii digits is enforced.\\n * @return {boolean} If Ascii digits is enforced.\\n */\\ngoog.i18n.NumberFormat.isEnforceAsciiDigits = function() {\\n  return goog.i18n.NumberFormat.enforceAsciiDigits_;\\n};\\n\\n\\n/**\\n * Returns the current NumberFormatSymbols.\\n * @return {!Object}\\n * @private\\n */\\ngoog.i18n.NumberFormat.getNumberFormatSymbols_ = function() {\\n  return goog.i18n.NumberFormat.enforceAsciiDigits_ ?\\n      goog.i18n.NumberFormatSymbols_u_nu_latn :\\n      goog.i18n.NumberFormatSymbols;\\n};\\n\\n\\n/**\\n * Returns the currency code.\\n * @return {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getCurrencyCode_ = function() {\\n  return this.intlCurrencyCode_ ||\\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().DEF_CURRENCY_CODE;\\n};\\n\\n\\n/**\\n * Sets minimum number of fraction digits.\\n * @param {number} min the minimum.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setMinimumFractionDigits = function(min) {\\n  if (this.significantDigits_ > 0 && min > 0) {\\n    throw Error(\\n        'Can\\\\'t combine significant digits and minimum fraction digits');\\n  }\\n  this.minimumFractionDigits_ = min;\\n  return this;\\n};\\n\\n\\n/**\\n * Sets maximum number of fraction digits.\\n * @param {number} max the maximum.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setMaximumFractionDigits = function(max) {\\n  if (max > 308) {\\n    // Math.pow(10, 309) becomes Infinity which breaks the logic in this class.\\n    throw Error('Unsupported maximum fraction digits: ' + max);\\n  }\\n  this.maximumFractionDigits_ = max;\\n  return this;\\n};\\n\\n\\n/**\\n * Sets number of significant digits to show. Only fractions will be rounded.\\n * Regardless of the number of significant digits set, the number of fractional\\n * digits shown will always be capped by the maximum number of fractional digits\\n * set on {@link #setMaximumFractionDigits}.\\n * @param {number} number The number of significant digits to include.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setSignificantDigits = function(number) {\\n  if (this.minimumFractionDigits_ > 0 && number >= 0) {\\n    throw Error(\\n        'Can\\\\'t combine significant digits and minimum fraction digits');\\n  }\\n  this.significantDigits_ = number;\\n  return this;\\n};\\n\\n\\n/**\\n * Gets number of significant digits to show. Only fractions will be rounded.\\n * @return {number} The number of significant digits to include.\\n */\\ngoog.i18n.NumberFormat.prototype.getSignificantDigits = function() {\\n  return this.significantDigits_;\\n};\\n\\n\\n/**\\n * Sets whether trailing fraction zeros should be shown when significantDigits_\\n * is positive. If this is true and significantDigits_ is 2, 1 will be formatted\\n * as '1.0'.\\n * @param {boolean} showTrailingZeros Whether trailing zeros should be shown.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setShowTrailingZeros = function(\\n    showTrailingZeros) {\\n  this.showTrailingZeros_ = showTrailingZeros;\\n  return this;\\n};\\n\\n\\n/**\\n * Sets a number to base the formatting on when compact style formatting is\\n * used. If this is null, the formatting should be based only on the number to\\n * be formatting.\\n *\\n * This base formatting number can be used to format the target number as\\n * another number would be formatted. For example, 100,000 is normally formatted\\n * as \\\"100K\\\" in the COMPACT_SHORT format. To instead format it as '0.1M', the\\n * base number could be set to 1,000,000 in order to force all numbers to be\\n * formatted in millions. Similarly, 1,000,000,000 would normally be formatted\\n * as '1B' and setting the base formatting number to 1,000,000, would cause it\\n * to be formatted instead as '1,000M'.\\n *\\n * @param {?number} baseFormattingNumber The number to base formatting on, or\\n * null if formatting should not be based on another number.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setBaseFormatting = function(\\n    baseFormattingNumber) {\\n  goog.asserts.assert(\\n      goog.isNull(baseFormattingNumber) || isFinite(baseFormattingNumber));\\n  this.baseFormattingNumber_ = baseFormattingNumber;\\n  return this;\\n};\\n\\n\\n/**\\n * Gets the number on which compact formatting is currently based, or null if\\n * no such number is set. See setBaseFormatting() for more information.\\n * @return {?number}\\n */\\ngoog.i18n.NumberFormat.prototype.getBaseFormatting = function() {\\n  return this.baseFormattingNumber_;\\n};\\n\\n\\n/**\\n * Apply provided pattern, result are stored in member variables.\\n *\\n * @param {string} pattern String pattern being applied.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.applyPattern_ = function(pattern) {\\n  this.pattern_ = pattern.replace(/ /g, '\\\\u00a0');\\n  var pos = [0];\\n\\n  this.positivePrefix_ = this.parseAffix_(pattern, pos);\\n  var trunkStart = pos[0];\\n  this.parseTrunk_(pattern, pos);\\n  var trunkLen = pos[0] - trunkStart;\\n  this.positiveSuffix_ = this.parseAffix_(pattern, pos);\\n  if (pos[0] < pattern.length &&\\n      pattern.charAt(pos[0]) == goog.i18n.NumberFormat.PATTERN_SEPARATOR_) {\\n    pos[0]++;\\n    if (this.multiplier_ != 1) this.negativePercentSignExpected_ = true;\\n    this.negativePrefix_ = this.parseAffix_(pattern, pos);\\n    // we assume this part is identical to positive part.\\n    // user must make sure the pattern is correctly constructed.\\n    pos[0] += trunkLen;\\n    this.negativeSuffix_ = this.parseAffix_(pattern, pos);\\n  } else {\\n    // if no negative affix specified, they share the same positive affix\\n    this.negativePrefix_ += this.positivePrefix_;\\n    this.negativeSuffix_ += this.positiveSuffix_;\\n  }\\n};\\n\\n\\n/**\\n * Apply a predefined pattern to NumberFormat object.\\n * @param {number} patternType The number that indicates a predefined number\\n *     format pattern.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.applyStandardPattern_ = function(patternType) {\\n  switch (patternType) {\\n    case goog.i18n.NumberFormat.Format.DECIMAL:\\n      this.applyPattern_(\\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_PATTERN);\\n      break;\\n    case goog.i18n.NumberFormat.Format.SCIENTIFIC:\\n      this.applyPattern_(\\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().SCIENTIFIC_PATTERN);\\n      break;\\n    case goog.i18n.NumberFormat.Format.PERCENT:\\n      this.applyPattern_(\\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT_PATTERN);\\n      break;\\n    case goog.i18n.NumberFormat.Format.CURRENCY:\\n      this.applyPattern_(goog.i18n.currency.adjustPrecision(\\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().CURRENCY_PATTERN,\\n          this.getCurrencyCode_()));\\n      break;\\n    case goog.i18n.NumberFormat.Format.COMPACT_SHORT:\\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.SHORT);\\n      break;\\n    case goog.i18n.NumberFormat.Format.COMPACT_LONG:\\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.LONG);\\n      break;\\n    default:\\n      throw Error('Unsupported pattern type.');\\n  }\\n};\\n\\n\\n/**\\n * Apply a predefined pattern for shorthand formats.\\n * @param {goog.i18n.NumberFormat.CompactStyle} style the compact style to\\n *     set defaults for.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.applyCompactStyle_ = function(style) {\\n  this.compactStyle_ = style;\\n  this.applyPattern_(\\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_PATTERN);\\n  this.setMinimumFractionDigits(0);\\n  this.setMaximumFractionDigits(2);\\n  this.setSignificantDigits(2);\\n};\\n\\n\\n/**\\n * Parses text string to produce a Number.\\n *\\n * This method attempts to parse text starting from position \\\"opt_pos\\\" if it\\n * is given. Otherwise the parse will start from the beginning of the text.\\n * When opt_pos presents, opt_pos will be updated to the character next to where\\n * parsing stops after the call. If an error occurs, opt_pos won't be updated.\\n *\\n * @param {string} text The string to be parsed.\\n * @param {Array<number>=} opt_pos Position to pass in and get back.\\n * @return {number} Parsed number. This throws an error if the text cannot be\\n *     parsed.\\n */\\ngoog.i18n.NumberFormat.prototype.parse = function(text, opt_pos) {\\n  var pos = opt_pos || [0];\\n\\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\\n    throw Error('Parsing of compact numbers is unimplemented');\\n  }\\n\\n  var ret = NaN;\\n\\n  // we don't want to handle 2 kind of space in parsing, normalize it to nbsp\\n  text = text.replace(/ /g, '\\\\u00a0');\\n\\n  var gotPositive = text.indexOf(this.positivePrefix_, pos[0]) == pos[0];\\n  var gotNegative = text.indexOf(this.negativePrefix_, pos[0]) == pos[0];\\n\\n  // check for the longest match\\n  if (gotPositive && gotNegative) {\\n    if (this.positivePrefix_.length > this.negativePrefix_.length) {\\n      gotNegative = false;\\n    } else if (this.positivePrefix_.length < this.negativePrefix_.length) {\\n      gotPositive = false;\\n    }\\n  }\\n\\n  if (gotPositive) {\\n    pos[0] += this.positivePrefix_.length;\\n  } else if (gotNegative) {\\n    pos[0] += this.negativePrefix_.length;\\n  }\\n\\n  // process digits or Inf, find decimal position\\n  if (text.indexOf(\\n          goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY, pos[0]) ==\\n      pos[0]) {\\n    pos[0] += goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY.length;\\n    ret = Infinity;\\n  } else {\\n    ret = this.parseNumber_(text, pos);\\n  }\\n\\n  // check for suffix\\n  if (gotPositive) {\\n    if (!(text.indexOf(this.positiveSuffix_, pos[0]) == pos[0])) {\\n      return NaN;\\n    }\\n    pos[0] += this.positiveSuffix_.length;\\n  } else if (gotNegative) {\\n    if (!(text.indexOf(this.negativeSuffix_, pos[0]) == pos[0])) {\\n      return NaN;\\n    }\\n    pos[0] += this.negativeSuffix_.length;\\n  }\\n\\n  return gotNegative ? -ret : ret;\\n};\\n\\n\\n/**\\n * This function will parse a \\\"localized\\\" text into a Number. It needs to\\n * handle locale specific decimal, grouping, exponent and digits.\\n *\\n * @param {string} text The text that need to be parsed.\\n * @param {Array<number>} pos  In/out parsing position. In case of failure,\\n *    pos value won't be changed.\\n * @return {number} Number value, or NaN if nothing can be parsed.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.parseNumber_ = function(text, pos) {\\n  var sawDecimal = false;\\n  var sawExponent = false;\\n  var sawDigit = false;\\n  var exponentPos = -1;\\n  var scale = 1;\\n  var decimal = goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_SEP;\\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\\n  var exponentChar =\\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().EXP_SYMBOL;\\n\\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\\n    throw Error('Parsing of compact style numbers is not implemented');\\n  }\\n\\n  var normalizedText = '';\\n  for (; pos[0] < text.length; pos[0]++) {\\n    var ch = text.charAt(pos[0]);\\n    var digit = this.getDigit_(ch);\\n    if (digit >= 0 && digit <= 9) {\\n      normalizedText += digit;\\n      sawDigit = true;\\n    } else if (ch == decimal.charAt(0)) {\\n      if (sawDecimal || sawExponent) {\\n        break;\\n      }\\n      normalizedText += '.';\\n      sawDecimal = true;\\n    } else if (\\n        ch == grouping.charAt(0) &&\\n        ('\\\\u00a0' != grouping.charAt(0) ||\\n         pos[0] + 1 < text.length &&\\n             this.getDigit_(text.charAt(pos[0] + 1)) >= 0)) {\\n      // Got a grouping character here. When grouping character is nbsp, need\\n      // to make sure the character following it is a digit.\\n      if (sawDecimal || sawExponent) {\\n        break;\\n      }\\n      continue;\\n    } else if (ch == exponentChar.charAt(0)) {\\n      if (sawExponent) {\\n        break;\\n      }\\n      normalizedText += 'E';\\n      sawExponent = true;\\n      exponentPos = pos[0];\\n    } else if (ch == '+' || ch == '-') {\\n      // Stop parsing if a '+' or '-' sign is found after digits have been found\\n      // but it's not located right after an exponent sign.\\n      if (sawDigit && exponentPos != pos[0] - 1) {\\n        break;\\n      }\\n      normalizedText += ch;\\n    } else if (\\n        this.multiplier_ == 1 &&\\n        ch ==\\n            goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT.charAt(\\n                0)) {\\n      // Parse the percent character as part of the number only when it's\\n      // not already included in the pattern.\\n      if (scale != 1) {\\n        break;\\n      }\\n      scale = 100;\\n      if (sawDigit) {\\n        pos[0]++;  // eat this character if parse end here\\n        break;\\n      }\\n    } else if (\\n        this.multiplier_ == 1 &&\\n        ch ==\\n            goog.i18n.NumberFormat.getNumberFormatSymbols_().PERMILL.charAt(\\n                0)) {\\n      // Parse the permill character as part of the number only when it's\\n      // not already included in the pattern.\\n      if (scale != 1) {\\n        break;\\n      }\\n      scale = 1000;\\n      if (sawDigit) {\\n        pos[0]++;  // eat this character if parse end here\\n        break;\\n      }\\n    } else {\\n      break;\\n    }\\n  }\\n\\n  // Scale the number when the percent/permill character was included in\\n  // the pattern.\\n  if (this.multiplier_ != 1) {\\n    scale = this.multiplier_;\\n  }\\n\\n  return parseFloat(normalizedText) / scale;\\n};\\n\\n\\n/**\\n * Formats a Number to produce a string.\\n *\\n * @param {number} number The Number to be formatted.\\n * @return {string} The formatted number string.\\n */\\ngoog.i18n.NumberFormat.prototype.format = function(number) {\\n  if (isNaN(number)) {\\n    return goog.i18n.NumberFormat.getNumberFormatSymbols_().NAN;\\n  }\\n\\n  var parts = [];\\n  var baseFormattingNumber = goog.isNull(this.baseFormattingNumber_) ?\\n      number :\\n      this.baseFormattingNumber_;\\n  var unit = this.getUnitAfterRounding_(baseFormattingNumber, number);\\n  number /= Math.pow(10, unit.divisorBase);\\n\\n  parts.push(unit.prefix);\\n\\n  // in icu code, it is commented that certain computation need to keep the\\n  // negative sign for 0.\\n  var isNegative = number < 0.0 || number == 0.0 && 1 / number < 0.0;\\n\\n  parts.push(isNegative ? this.negativePrefix_ : this.positivePrefix_);\\n\\n  if (!isFinite(number)) {\\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().INFINITY);\\n  } else {\\n    // convert number to non-negative value\\n    number *= isNegative ? -1 : 1;\\n\\n    number *= this.multiplier_;\\n    this.useExponentialNotation_ ?\\n        this.subformatExponential_(number, parts) :\\n        this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\\n  }\\n\\n  parts.push(isNegative ? this.negativeSuffix_ : this.positiveSuffix_);\\n  parts.push(unit.suffix);\\n\\n  return parts.join('');\\n};\\n\\n\\n/**\\n * Round a number into an integer and fractional part\\n * based on the rounding rules for this NumberFormat.\\n * @param {number} number The number to round.\\n * @return {{intValue: number, fracValue: number}} The integer and fractional\\n *     part after rounding.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.roundNumber_ = function(number) {\\n  var power = Math.pow(10, this.maximumFractionDigits_);\\n  var shiftedNumber = this.significantDigits_ <= 0 ?\\n      Math.round(number * power) :\\n      Math.round(\\n          this.roundToSignificantDigits_(\\n              number * power, this.significantDigits_,\\n              this.maximumFractionDigits_));\\n\\n  var intValue, fracValue;\\n  if (isFinite(shiftedNumber)) {\\n    intValue = Math.floor(shiftedNumber / power);\\n    fracValue = Math.floor(shiftedNumber - intValue * power);\\n  } else {\\n    intValue = number;\\n    fracValue = 0;\\n  }\\n  return {intValue: intValue, fracValue: fracValue};\\n};\\n\\n\\n/**\\n * Formats a number with the appropriate groupings when there are repeating\\n * digits present. Repeating digits exists when the length of the digits left\\n * of the decimal place exceeds the number of non-repeating digits.\\n *\\n * Formats a number by iterating through the integer number (intPart) from the\\n * most left of the decimal place by inserting the appropriate number grouping\\n * separator for the repeating digits until all of the repeating digits is\\n * iterated. Then iterate through the non-repeating digits by inserting the\\n * appropriate number grouping separator until all the non-repeating digits\\n * is iterated through.\\n *\\n * In the number grouping concept, anything left of the decimal\\n * place is followed by non-repeating digits and then repeating digits. If the\\n * pattern is #,##,###, then we first (from the left of the decimal place) have\\n * a non-repeating digit of size 3 followed by repeating digits of size 2\\n * separated by a thousand separator. If the length of the digits are six or\\n * more, there may be repeating digits required. For example, the value of\\n * 12345678 would format as 1,23,45,678 where the repeating digit is length 2.\\n *\\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\\n *  number including the values and separators.\\n * @param {number} zeroCode The value of the zero digit whether or not\\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\\n * @param {string} intPart The integer representation of the number to be\\n *  formatted and referenced.\\n * @param {!Array<number>} groupingArray The array of numbers to determine the\\n *  grouping of repeated and non-repeated digits.\\n * @param {number} repeatedDigitLen The length of the repeated digits left of\\n *  the non-repeating digits left of the decimal.\\n * @return {!Array<string>} Returns the resulting parts variable containing\\n *  how numbers are to be grouped and appear.\\n * @private\\n */\\ngoog.i18n.NumberFormat.formatNumberGroupingRepeatingDigitsParts_ = function(\\n    parts, zeroCode, intPart, groupingArray, repeatedDigitLen) {\\n  // Keep track of how much has been completed on the non repeated groups\\n  var nonRepeatedGroupCompleteCount = 0;\\n  var currentGroupSizeIndex = 0;\\n  var currentGroupSize = 0;\\n\\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\\n  var digitLen = intPart.length;\\n\\n  // There are repeating digits and non-repeating digits\\n  for (var i = 0; i < digitLen; i++) {\\n    parts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(i)) * 1));\\n    if (digitLen - i > 1) {\\n      currentGroupSize = groupingArray[currentGroupSizeIndex];\\n      if (i < repeatedDigitLen) {\\n        // Process the left side (the repeated number groups)\\n        var repeatedDigitIndex = repeatedDigitLen - i;\\n        // Edge case if there's a number grouping asking for \\\"1\\\" group at\\n        // a time; otherwise, if the remainder is 1, there's the separator\\n        if (currentGroupSize === 1 ||\\n            (currentGroupSize > 0 &&\\n             (repeatedDigitIndex % currentGroupSize) === 1)) {\\n          parts.push(grouping);\\n        }\\n      } else if (currentGroupSizeIndex < groupingArray.length) {\\n        // Process the right side (the non-repeated fixed number groups)\\n        if (i === repeatedDigitLen) {\\n          // Increase the group index because a separator\\n          // has previously added in the earlier logic\\n          currentGroupSizeIndex += 1;\\n        } else if (\\n            currentGroupSize ===\\n            i - repeatedDigitLen - nonRepeatedGroupCompleteCount + 1) {\\n          // Otherwise, just iterate to the right side and\\n          // add a separator once the length matches to the expected\\n          parts.push(grouping);\\n          // Keep track of what has been completed on the right\\n          nonRepeatedGroupCompleteCount += currentGroupSize;\\n          currentGroupSizeIndex += 1;  // Get to the next number grouping\\n        }\\n      }\\n    }\\n  }\\n  return parts;\\n};\\n\\n\\n/**\\n * Formats a number with the appropriate groupings when there are no repeating\\n * digits present. Non-repeating digits exists when the length of the digits\\n * left of the decimal place is equal or lesser than the length of\\n * non-repeating digits.\\n *\\n * Formats a number by iterating through the integer number (intPart) from the\\n * right most non-repeating number group of the decimal place. For each group,\\n * inserting the appropriate number grouping separator for the non-repeating\\n * digits until the number is completely iterated.\\n *\\n * In the number grouping concept, anything left of the decimal\\n * place is followed by non-repeating digits and then repeating digits. If the\\n * pattern is #,##,###, then we first (from the left of the decimal place) have\\n * a non-repeating digit of size 3 followed by repeating digits of size 2\\n * separated by a thousand separator. If the length of the digits are five or\\n * less, there won't be any repeating digits required. For example, the value\\n * of 12345 would be formatted as 12,345 where the non-repeating digit is of\\n * length 3.\\n *\\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\\n *  number including the values and separators.\\n * @param {number} zeroCode The value of the zero digit whether or not\\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\\n * @param {string} intPart The integer representation of the number to be\\n *  formatted and referenced.\\n * @param {!Array<number>} groupingArray The array of numbers to determine the\\n *  grouping of repeated and non-repeated digits.\\n * @return {!Array<string>} Returns the resulting parts variable containing\\n *  how numbers are to be grouped and appear.\\n * @private\\n */\\ngoog.i18n.NumberFormat.formatNumberGroupingNonRepeatingDigitsParts_ = function(\\n    parts, zeroCode, intPart, groupingArray) {\\n  // Keep track of how much has been completed on the non repeated groups\\n  var grouping = goog.i18n.NumberFormat.getNumberFormatSymbols_().GROUP_SEP;\\n  var currentGroupSizeIndex;\\n  var currentGroupSize = 0;\\n  var digitLenLeft = intPart.length;\\n  var rightToLeftParts = [];\\n\\n  // Start from the right most non-repeating group and work inwards\\n  for (currentGroupSizeIndex = groupingArray.length - 1;\\n       currentGroupSizeIndex >= 0 && digitLenLeft > 0;\\n       currentGroupSizeIndex--) {\\n    currentGroupSize = groupingArray[currentGroupSizeIndex];\\n    // Iterate from the right most digit\\n    for (var rightDigitIndex = 0; rightDigitIndex < currentGroupSize &&\\n         ((digitLenLeft - rightDigitIndex - 1) >= 0);\\n         rightDigitIndex++) {\\n      rightToLeftParts.push(\\n          String.fromCharCode(\\n              zeroCode +\\n              Number(intPart.charAt(digitLenLeft - rightDigitIndex - 1)) * 1));\\n    }\\n    // Update the number of digits left\\n    digitLenLeft -= currentGroupSize;\\n    if (digitLenLeft > 0) {\\n      rightToLeftParts.push(grouping);\\n    }\\n  }\\n  // Reverse and push onto the remaining parts\\n  parts.push.apply(parts, rightToLeftParts.reverse());\\n\\n  return parts;\\n};\\n\\n\\n/**\\n * Formats a Number in fraction format.\\n *\\n * @param {number} number\\n * @param {number} minIntDigits Minimum integer digits.\\n * @param {Array<string>} parts\\n *     This array holds the pieces of formatted string.\\n *     This function will add its formatted pieces to the array.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.subformatFixed_ = function(\\n    number, minIntDigits, parts) {\\n  if (this.minimumFractionDigits_ > this.maximumFractionDigits_) {\\n    throw Error('Min value must be less than max value');\\n  }\\n\\n  if (!parts) {\\n    parts = [];\\n  }\\n\\n  var rounded = this.roundNumber_(number);\\n  var intValue = rounded.intValue;\\n  var fracValue = rounded.fracValue;\\n\\n  var numIntDigits = (intValue == 0) ? 0 : this.intLog10_(intValue) + 1;\\n  var fractionPresent = this.minimumFractionDigits_ > 0 || fracValue > 0 ||\\n      (this.showTrailingZeros_ && numIntDigits < this.significantDigits_);\\n  var minimumFractionDigits = this.minimumFractionDigits_;\\n  if (fractionPresent) {\\n    if (this.showTrailingZeros_ && this.significantDigits_ > 0) {\\n      minimumFractionDigits = this.significantDigits_ - numIntDigits;\\n    } else {\\n      minimumFractionDigits = this.minimumFractionDigits_;\\n    }\\n  }\\n\\n  var intPart = '';\\n  var translatableInt = intValue;\\n  while (translatableInt > 1E20) {\\n    // here it goes beyond double precision, add '0' make it look better\\n    intPart = '0' + intPart;\\n    translatableInt = Math.round(translatableInt / 10);\\n  }\\n  intPart = translatableInt + intPart;\\n\\n  var decimal = goog.i18n.NumberFormat.getNumberFormatSymbols_().DECIMAL_SEP;\\n  var zeroCode =\\n      goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\\n  var digitLen = intPart.length;\\n  var nonRepeatedGroupCount = 0;\\n\\n  if (intValue > 0 || minIntDigits > 0) {\\n    for (var i = digitLen; i < minIntDigits; i++) {\\n      parts.push(String.fromCharCode(zeroCode));\\n    }\\n\\n    // If there's more than 1 number grouping,\\n    // figure out the length of the non-repeated groupings (on the right)\\n    if (this.groupingArray_.length >= 2) {\\n      for (var j = 1; j < this.groupingArray_.length; j++) {\\n        nonRepeatedGroupCount += this.groupingArray_[j];\\n      }\\n    }\\n\\n    // Anything left of the fixed number grouping is repeated,\\n    // figure out the length of repeated groupings (on the left)\\n    var repeatedDigitLen = digitLen - nonRepeatedGroupCount;\\n    if (repeatedDigitLen > 0) {\\n      // There are repeating digits and non-repeating digits\\n      parts = goog.i18n.NumberFormat.formatNumberGroupingRepeatingDigitsParts_(\\n          parts, zeroCode, intPart, this.groupingArray_, repeatedDigitLen);\\n    } else {\\n      // There are no repeating digits and only non-repeating digits\\n      parts =\\n          goog.i18n.NumberFormat.formatNumberGroupingNonRepeatingDigitsParts_(\\n              parts, zeroCode, intPart, this.groupingArray_);\\n    }\\n  } else if (!fractionPresent) {\\n    // If there is no fraction present, and we haven't printed any\\n    // integer digits, then print a zero.\\n    parts.push(String.fromCharCode(zeroCode));\\n  }\\n\\n  // Output the decimal separator if we always do so.\\n  if (this.decimalSeparatorAlwaysShown_ || fractionPresent) {\\n    parts.push(decimal);\\n  }\\n\\n  var fracPart = String(fracValue);\\n  // Handle case where fracPart is in scientific notation.\\n  var fracPartSplit = fracPart.split('e+');\\n  if (fracPartSplit.length == 2) {\\n    // Only keep significant digits.\\n    var floatFrac = parseFloat(fracPartSplit[0]);\\n    fracPart = String(\\n        this.roundToSignificantDigits_(floatFrac, this.significantDigits_, 1));\\n    fracPart = fracPart.replace('.', '');\\n    // Append zeroes based on the exponent.\\n    var exp = parseInt(fracPartSplit[1], 10);\\n    fracPart += goog.string.repeat('0', exp - fracPart.length + 1);\\n  }\\n\\n  // Add Math.pow(10, this.maximumFractionDigits) to fracPart. Uses string ops\\n  // to avoid complexity with scientific notation and overflows.\\n  if (this.maximumFractionDigits_ + 1 > fracPart.length) {\\n    var zeroesToAdd = this.maximumFractionDigits_ - fracPart.length;\\n    fracPart = '1' + goog.string.repeat('0', zeroesToAdd) + fracPart;\\n  }\\n\\n  var fracLen = fracPart.length;\\n  while (fracPart.charAt(fracLen - 1) == '0' &&\\n         fracLen > minimumFractionDigits + 1) {\\n    fracLen--;\\n  }\\n\\n  for (var i = 1; i < fracLen; i++) {\\n    parts.push(String.fromCharCode(zeroCode + Number(fracPart.charAt(i)) * 1));\\n  }\\n};\\n\\n\\n/**\\n * Formats exponent part of a Number.\\n *\\n * @param {number} exponent Exponential value.\\n * @param {Array<string>} parts The array that holds the pieces of formatted\\n *     string. This function will append more formatted pieces to the array.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.addExponentPart_ = function(exponent, parts) {\\n  parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().EXP_SYMBOL);\\n\\n  if (exponent < 0) {\\n    exponent = -exponent;\\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().MINUS_SIGN);\\n  } else if (this.useSignForPositiveExponent_) {\\n    parts.push(goog.i18n.NumberFormat.getNumberFormatSymbols_().PLUS_SIGN);\\n  }\\n\\n  var exponentDigits = '' + exponent;\\n  var zeroChar = goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT;\\n  for (var i = exponentDigits.length; i < this.minExponentDigits_; i++) {\\n    parts.push(zeroChar);\\n  }\\n  parts.push(exponentDigits);\\n};\\n\\n/**\\n * Returns the mantissa for the given value and its exponent.\\n *\\n * @param {number} value\\n * @param {number} exponent\\n * @return {number}\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getMantissa_ = function(value, exponent) {\\n  var divisor = Math.pow(10, exponent);\\n  if (isFinite(divisor) && divisor !== 0) {\\n    return value / divisor;\\n  } else {\\n    // If the exponent is too big pow returns 0. In such a case we calculate\\n    // half of the divisor and apply it twice.\\n    divisor = Math.pow(10, Math.floor(exponent / 2));\\n    var result = value / divisor / divisor;\\n    if (exponent % 2 == 1) {  // Correcting for odd exponents.\\n      if (exponent > 0) {\\n        result /= 10;\\n      } else {\\n        result *= 10;\\n      }\\n    }\\n    return result;\\n  }\\n};\\n\\n/**\\n * Formats Number in exponential format.\\n *\\n * @param {number} number Value need to be formatted.\\n * @param {Array<string>} parts The array that holds the pieces of formatted\\n *     string. This function will append more formatted pieces to the array.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.subformatExponential_ = function(\\n    number, parts) {\\n  if (number == 0.0) {\\n    this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\\n    this.addExponentPart_(0, parts);\\n    return;\\n  }\\n\\n  var exponent = goog.math.safeFloor(Math.log(number) / Math.log(10));\\n  number = this.getMantissa_(number, exponent);\\n\\n  var minIntDigits = this.minimumIntegerDigits_;\\n  if (this.maximumIntegerDigits_ > 1 &&\\n      this.maximumIntegerDigits_ > this.minimumIntegerDigits_) {\\n    // A repeating range is defined; adjust to it as follows.\\n    // If repeat == 3, we have 6,5,4=>3; 3,2,1=>0; 0,-1,-2=>-3;\\n    // -3,-4,-5=>-6, etc. This takes into account that the\\n    // exponent we have here is off by one from what we expect;\\n    // it is for the format 0.MMMMMx10^n.\\n    while ((exponent % this.maximumIntegerDigits_) != 0) {\\n      number *= 10;\\n      exponent--;\\n    }\\n    minIntDigits = 1;\\n  } else {\\n    // No repeating range is defined; use minimum integer digits.\\n    if (this.minimumIntegerDigits_ < 1) {\\n      exponent++;\\n      number /= 10;\\n    } else {\\n      exponent -= this.minimumIntegerDigits_ - 1;\\n      number *= Math.pow(10, this.minimumIntegerDigits_ - 1);\\n    }\\n  }\\n  this.subformatFixed_(number, minIntDigits, parts);\\n  this.addExponentPart_(exponent, parts);\\n};\\n\\n\\n/**\\n * Returns the digit value of current character. The character could be either\\n * '0' to '9', or a locale specific digit.\\n *\\n * @param {string} ch Character that represents a digit.\\n * @return {number} The digit value, or -1 on error.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getDigit_ = function(ch) {\\n  var code = ch.charCodeAt(0);\\n  // between '0' to '9'\\n  if (48 <= code && code < 58) {\\n    return code - 48;\\n  } else {\\n    var zeroCode =\\n        goog.i18n.NumberFormat.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(\\n            0);\\n    return zeroCode <= code && code < zeroCode + 10 ? code - zeroCode : -1;\\n  }\\n};\\n\\n\\n// ----------------------------------------------------------------------\\n// CONSTANTS\\n// ----------------------------------------------------------------------\\n// Constants for characters used in programmatic (unlocalized) patterns.\\n/**\\n * A zero digit character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_ = '0';\\n\\n\\n/**\\n * A grouping separator character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_ = ',';\\n\\n\\n/**\\n * A decimal separator character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_ = '.';\\n\\n\\n/**\\n * A per mille character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_PER_MILLE_ = '\\\\u2030';\\n\\n\\n/**\\n * A percent character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_PERCENT_ = '%';\\n\\n\\n/**\\n * A digit character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_DIGIT_ = '#';\\n\\n\\n/**\\n * A separator character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_SEPARATOR_ = ';';\\n\\n\\n/**\\n * An exponent character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_EXPONENT_ = 'E';\\n\\n\\n/**\\n * A plus character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_PLUS_ = '+';\\n\\n\\n/**\\n * A generic currency sign character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_ = '\\\\u00A4';\\n\\n\\n/**\\n * A quote character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.QUOTE_ = '\\\\'';\\n\\n\\n/**\\n * Parses affix part of pattern.\\n *\\n * @param {string} pattern Pattern string that need to be parsed.\\n * @param {Array<number>} pos One element position array to set and receive\\n *     parsing position.\\n *\\n * @return {string} Affix received from parsing.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.parseAffix_ = function(pattern, pos) {\\n  var affix = '';\\n  var inQuote = false;\\n  var len = pattern.length;\\n\\n  for (; pos[0] < len; pos[0]++) {\\n    var ch = pattern.charAt(pos[0]);\\n    if (ch == goog.i18n.NumberFormat.QUOTE_) {\\n      if (pos[0] + 1 < len &&\\n          pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.QUOTE_) {\\n        pos[0]++;\\n        affix += '\\\\'';  // 'don''t'\\n      } else {\\n        inQuote = !inQuote;\\n      }\\n      continue;\\n    }\\n\\n    if (inQuote) {\\n      affix += ch;\\n    } else {\\n      switch (ch) {\\n        case goog.i18n.NumberFormat.PATTERN_DIGIT_:\\n        case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\\n        case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\\n        case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\\n        case goog.i18n.NumberFormat.PATTERN_SEPARATOR_:\\n          return affix;\\n        case goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_:\\n          if ((pos[0] + 1) < len &&\\n              pattern.charAt(pos[0] + 1) ==\\n                  goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_) {\\n            pos[0]++;\\n            affix += this.getCurrencyCode_();\\n          } else {\\n            switch (this.currencyStyle_) {\\n              case goog.i18n.NumberFormat.CurrencyStyle.LOCAL:\\n                affix += goog.i18n.currency.getLocalCurrencySign(\\n                    this.getCurrencyCode_());\\n                break;\\n              case goog.i18n.NumberFormat.CurrencyStyle.GLOBAL:\\n                affix += goog.i18n.currency.getGlobalCurrencySign(\\n                    this.getCurrencyCode_());\\n                break;\\n              case goog.i18n.NumberFormat.CurrencyStyle.PORTABLE:\\n                affix += goog.i18n.currency.getPortableCurrencySign(\\n                    this.getCurrencyCode_());\\n                break;\\n              default:\\n                break;\\n            }\\n          }\\n          break;\\n        case goog.i18n.NumberFormat.PATTERN_PERCENT_:\\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\\n            throw Error('Too many percent/permill');\\n          } else if (\\n              this.negativePercentSignExpected_ && this.multiplier_ != 100) {\\n            throw Error('Inconsistent use of percent/permill characters');\\n          }\\n          this.multiplier_ = 100;\\n          this.negativePercentSignExpected_ = false;\\n          affix += goog.i18n.NumberFormat.getNumberFormatSymbols_().PERCENT;\\n          break;\\n        case goog.i18n.NumberFormat.PATTERN_PER_MILLE_:\\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\\n            throw Error('Too many percent/permill');\\n          } else if (\\n              this.negativePercentSignExpected_ && this.multiplier_ != 1000) {\\n            throw Error('Inconsistent use of percent/permill characters');\\n          }\\n          this.multiplier_ = 1000;\\n          this.negativePercentSignExpected_ = false;\\n          affix += goog.i18n.NumberFormat.getNumberFormatSymbols_().PERMILL;\\n          break;\\n        default:\\n          affix += ch;\\n      }\\n    }\\n  }\\n\\n  return affix;\\n};\\n\\n\\n/**\\n * Parses the trunk part of a pattern.\\n *\\n * @param {string} pattern Pattern string that need to be parsed.\\n * @param {Array<number>} pos One element position array to set and receive\\n *     parsing position.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.parseTrunk_ = function(pattern, pos) {\\n  var decimalPos = -1;\\n  var digitLeftCount = 0;\\n  var zeroDigitCount = 0;\\n  var digitRightCount = 0;\\n  var groupingCount = -1;\\n  var len = pattern.length;\\n  for (var loop = true; pos[0] < len && loop; pos[0]++) {\\n    var ch = pattern.charAt(pos[0]);\\n    switch (ch) {\\n      case goog.i18n.NumberFormat.PATTERN_DIGIT_:\\n        if (zeroDigitCount > 0) {\\n          digitRightCount++;\\n        } else {\\n          digitLeftCount++;\\n        }\\n        if (groupingCount >= 0 && decimalPos < 0) {\\n          groupingCount++;\\n        }\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\\n        if (digitRightCount > 0) {\\n          throw Error('Unexpected \\\"0\\\" in pattern \\\"' + pattern + '\\\"');\\n        }\\n        zeroDigitCount++;\\n        if (groupingCount >= 0 && decimalPos < 0) {\\n          groupingCount++;\\n        }\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\\n        if (groupingCount > 0) {\\n          this.groupingArray_.push(groupingCount);\\n        }\\n        groupingCount = 0;\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\\n        if (decimalPos >= 0) {\\n          throw Error(\\n              'Multiple decimal separators in pattern \\\"' + pattern + '\\\"');\\n        }\\n        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_EXPONENT_:\\n        if (this.useExponentialNotation_) {\\n          throw Error(\\n              'Multiple exponential symbols in pattern \\\"' + pattern + '\\\"');\\n        }\\n        this.useExponentialNotation_ = true;\\n        this.minExponentDigits_ = 0;\\n\\n        // exponent pattern can have a optional '+'.\\n        if ((pos[0] + 1) < len &&\\n            pattern.charAt(pos[0] + 1) ==\\n                goog.i18n.NumberFormat.PATTERN_PLUS_) {\\n          pos[0]++;\\n          this.useSignForPositiveExponent_ = true;\\n        }\\n\\n        // Use lookahead to parse out the exponential part\\n        // of the pattern, then jump into phase 2.\\n        while ((pos[0] + 1) < len &&\\n               pattern.charAt(pos[0] + 1) ==\\n                   goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_) {\\n          pos[0]++;\\n          this.minExponentDigits_++;\\n        }\\n\\n        if ((digitLeftCount + zeroDigitCount) < 1 ||\\n            this.minExponentDigits_ < 1) {\\n          throw Error('Malformed exponential pattern \\\"' + pattern + '\\\"');\\n        }\\n        loop = false;\\n        break;\\n      default:\\n        pos[0]--;\\n        loop = false;\\n        break;\\n    }\\n  }\\n\\n  if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {\\n    // Handle '###.###' and '###.' and '.###'\\n    var n = decimalPos;\\n    if (n == 0) {  // Handle '.###'\\n      n++;\\n    }\\n    digitRightCount = digitLeftCount - n;\\n    digitLeftCount = n - 1;\\n    zeroDigitCount = 1;\\n  }\\n\\n  // Do syntax checking on the digits.\\n  if (decimalPos < 0 && digitRightCount > 0 ||\\n      decimalPos >= 0 && (decimalPos < digitLeftCount ||\\n                          decimalPos > digitLeftCount + zeroDigitCount) ||\\n      groupingCount == 0) {\\n    throw Error('Malformed pattern \\\"' + pattern + '\\\"');\\n  }\\n  var totalDigits = digitLeftCount + zeroDigitCount + digitRightCount;\\n\\n  this.maximumFractionDigits_ = decimalPos >= 0 ? totalDigits - decimalPos : 0;\\n  if (decimalPos >= 0) {\\n    this.minimumFractionDigits_ = digitLeftCount + zeroDigitCount - decimalPos;\\n    if (this.minimumFractionDigits_ < 0) {\\n      this.minimumFractionDigits_ = 0;\\n    }\\n  }\\n\\n  // The effectiveDecimalPos is the position the decimal is at or would be at\\n  // if there is no decimal. Note that if decimalPos<0, then digitTotalCount ==\\n  // digitLeftCount + zeroDigitCount.\\n  var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : totalDigits;\\n  this.minimumIntegerDigits_ = effectiveDecimalPos - digitLeftCount;\\n  if (this.useExponentialNotation_) {\\n    this.maximumIntegerDigits_ = digitLeftCount + this.minimumIntegerDigits_;\\n\\n    // in exponential display, we need to at least show something.\\n    if (this.maximumFractionDigits_ == 0 && this.minimumIntegerDigits_ == 0) {\\n      this.minimumIntegerDigits_ = 1;\\n    }\\n  }\\n\\n  // Add another number grouping at the end\\n  this.groupingArray_.push(Math.max(0, groupingCount));\\n  this.decimalSeparatorAlwaysShown_ =\\n      decimalPos == 0 || decimalPos == totalDigits;\\n};\\n\\n\\n/**\\n * Alias for the compact format 'unit' object.\\n * @typedef {{\\n *     prefix: string,\\n *     suffix: string,\\n *     divisorBase: number\\n * }}\\n */\\ngoog.i18n.NumberFormat.CompactNumberUnit;\\n\\n\\n/**\\n * The empty unit, corresponding to a base of 0.\\n * @private {!goog.i18n.NumberFormat.CompactNumberUnit}\\n */\\ngoog.i18n.NumberFormat.NULL_UNIT_ = {\\n  prefix: '',\\n  suffix: '',\\n  divisorBase: 0\\n};\\n\\n\\n/**\\n * Get compact unit for a certain number of digits\\n *\\n * @param {number} base The number of digits to get the unit for.\\n * @param {string} plurality The plurality of the number.\\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The compact unit.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getUnitFor_ = function(base, plurality) {\\n  var table = this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.SHORT ?\\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN :\\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_LONG_PATTERN;\\n\\n  if (!goog.isDefAndNotNull(table)) {\\n    table = goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN;\\n  }\\n\\n  if (base < 3) {\\n    return goog.i18n.NumberFormat.NULL_UNIT_;\\n  } else {\\n    base = Math.min(14, base);\\n    var patterns = table[Math.pow(10, base)];\\n    var previousNonNullBase = base - 1;\\n    while (!patterns && previousNonNullBase >= 3) {\\n      patterns = table[Math.pow(10, previousNonNullBase)];\\n      previousNonNullBase--;\\n    }\\n    if (!patterns) {\\n      return goog.i18n.NumberFormat.NULL_UNIT_;\\n    }\\n\\n    var pattern = patterns[plurality];\\n    if (!pattern || pattern == '0') {\\n      return goog.i18n.NumberFormat.NULL_UNIT_;\\n    }\\n\\n    var parts = /([^0]*)(0+)(.*)/.exec(pattern);\\n    if (!parts) {\\n      return goog.i18n.NumberFormat.NULL_UNIT_;\\n    }\\n\\n    return {\\n      prefix: parts[1],\\n      suffix: parts[3],\\n      divisorBase: (previousNonNullBase + 1) - (parts[2].length - 1)\\n    };\\n  }\\n};\\n\\n\\n/**\\n * Get the compact unit divisor, accounting for rounding of the quantity.\\n *\\n * @param {number} formattingNumber The number to base the formatting on. The\\n *     unit will be calculated from this number.\\n * @param {number} pluralityNumber The number to use for calculating the\\n *     plurality.\\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The unit after rounding.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getUnitAfterRounding_ = function(\\n    formattingNumber, pluralityNumber) {\\n  if (this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.NONE) {\\n    return goog.i18n.NumberFormat.NULL_UNIT_;\\n  }\\n\\n  formattingNumber = Math.abs(formattingNumber);\\n  pluralityNumber = Math.abs(pluralityNumber);\\n\\n  var initialPlurality = this.pluralForm_(formattingNumber);\\n  // Compute the exponent from the formattingNumber, to compute the unit.\\n  var base = formattingNumber <= 1 ? 0 : this.intLog10_(formattingNumber);\\n  var initialDivisor = this.getUnitFor_(base, initialPlurality).divisorBase;\\n  // Round both numbers based on the unit used.\\n  var pluralityAttempt = pluralityNumber / Math.pow(10, initialDivisor);\\n  var pluralityRounded = this.roundNumber_(pluralityAttempt);\\n  var formattingAttempt = formattingNumber / Math.pow(10, initialDivisor);\\n  var formattingRounded = this.roundNumber_(formattingAttempt);\\n  // Compute the plurality of the pluralityNumber when formatted using the name\\n  // units as the formattingNumber.\\n  var finalPlurality =\\n      this.pluralForm_(pluralityRounded.intValue + pluralityRounded.fracValue);\\n  // Get the final unit, using the rounded formatting number to get the correct\\n  // unit, and the plurality computed from the pluralityNumber.\\n  return this.getUnitFor_(\\n      initialDivisor + this.intLog10_(formattingRounded.intValue),\\n      finalPlurality);\\n};\\n\\n\\n/**\\n * Get the integer base 10 logarithm of a number.\\n *\\n * @param {number} number The number to log.\\n * @return {number} The lowest integer n such that 10^n >= number.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.intLog10_ = function(number) {\\n  // Handle infinity.\\n  if (!isFinite(number)) {\\n    return number > 0 ? number : 0;\\n  }\\n  // Turns out Math.log(1000000)/Math.LN10 is strictly less than 6.\\n  var i = 0;\\n  while ((number /= 10) >= 1) i++;\\n  return i;\\n};\\n\\n\\n/**\\n * Round to a certain number of significant digits.\\n *\\n * @param {number} number The number to round.\\n * @param {number} significantDigits The number of significant digits\\n *     to round to.\\n * @param {number} scale Treat number as fixed point times 10^scale.\\n * @return {number} The rounded number.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.roundToSignificantDigits_ = function(\\n    number, significantDigits, scale) {\\n  if (!number) return number;\\n\\n  var digits = this.intLog10_(number);\\n  var magnitude = significantDigits - digits - 1;\\n\\n  // Only round fraction, not (potentially shifted) integers.\\n  if (magnitude < -scale) {\\n    var point = Math.pow(10, scale);\\n    return Math.round(number / point) * point;\\n  }\\n\\n  var power = Math.pow(10, magnitude);\\n  var shifted = Math.round(number * power);\\n  return shifted / power;\\n};\\n\\n\\n/**\\n * Get the plural form of a number.\\n * @param {number} quantity The quantity to find plurality of.\\n * @return {string} One of 'zero', 'one', 'two', 'few', 'many', 'other'.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.pluralForm_ = function(quantity) {\\n  /* TODO: Implement */\\n  return 'other';\\n};\\n\\n\\n/**\\n * Checks if the currency symbol comes before the value ($12) or after (12$)\\n * Handy for applications that need to have separate UI fields for the currency\\n * value and symbol, especially for input: Price: [USD] [123.45]\\n * The currency symbol might be a combo box, or a label.\\n *\\n * @return {boolean} true if currency is before value.\\n */\\ngoog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue = function() {\\n  var posCurrSymbol = this.pattern_.indexOf('\\\\u00A4');  // '\\u00a4' Currency sign\\n  var posPound = this.pattern_.indexOf('#');\\n  var posZero = this.pattern_.indexOf('0');\\n\\n  // posCurrValue is the first '#' or '0' found.\\n  // If none of them is found (not possible, but still),\\n  // the result is true (postCurrSymbol < MAX_VALUE)\\n  // That is OK, matches the en_US and ROOT locales.\\n  var posCurrValue = Number.MAX_VALUE;\\n  if (posPound >= 0 && posPound < posCurrValue) {\\n    posCurrValue = posPound;\\n  }\\n  if (posZero >= 0 && posZero < posCurrValue) {\\n    posCurrValue = posZero;\\n  }\\n\\n  // No need to test, it is guaranteed that both these symbols exist.\\n  // If not, we have bigger problems than this.\\n  return posCurrSymbol < posCurrValue;\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"i18n\",\"NumberFormat\",\"goog.i18n.NumberFormat\",\"pattern\",\"opt_currency\",\"opt_currencyStyle\",\"intlCurrencyCode_\",\"currencyStyle_\",\"CurrencyStyle\",\"LOCAL\",\"maximumIntegerDigits_\",\"minimumIntegerDigits_\",\"significantDigits_\",\"maximumFractionDigits_\",\"minimumFractionDigits_\",\"minExponentDigits_\",\"useSignForPositiveExponent_\",\"showTrailingZeros_\",\"positivePrefix_\",\"positiveSuffix_\",\"negativePrefix_\",\"negativeSuffix_\",\"multiplier_\",\"negativePercentSignExpected_\",\"groupingArray_\",\"decimalSeparatorAlwaysShown_\",\"useExponentialNotation_\",\"compactStyle_\",\"CompactStyle\",\"NONE\",\"baseFormattingNumber_\",\"pattern_\",\"applyStandardPattern_\",\"applyPattern_\",\"Format\",\"DECIMAL\",\"SCIENTIFIC\",\"PERCENT\",\"CURRENCY\",\"COMPACT_SHORT\",\"COMPACT_LONG\",\"PORTABLE\",\"GLOBAL\",\"SHORT\",\"LONG\",\"enforceAsciiDigits_\",\"setEnforceAsciiDigits\",\"goog.i18n.NumberFormat.setEnforceAsciiDigits\",\"doEnforce\",\"isEnforceAsciiDigits\",\"goog.i18n.NumberFormat.isEnforceAsciiDigits\",\"getNumberFormatSymbols_\",\"goog.i18n.NumberFormat.getNumberFormatSymbols_\",\"NumberFormatSymbols_u_nu_latn\",\"NumberFormatSymbols\",\"prototype\",\"getCurrencyCode_\",\"goog.i18n.NumberFormat.prototype.getCurrencyCode_\",\"DEF_CURRENCY_CODE\",\"setMinimumFractionDigits\",\"goog.i18n.NumberFormat.prototype.setMinimumFractionDigits\",\"min\",\"Error\",\"setMaximumFractionDigits\",\"goog.i18n.NumberFormat.prototype.setMaximumFractionDigits\",\"max\",\"setSignificantDigits\",\"goog.i18n.NumberFormat.prototype.setSignificantDigits\",\"number\",\"getSignificantDigits\",\"goog.i18n.NumberFormat.prototype.getSignificantDigits\",\"setShowTrailingZeros\",\"goog.i18n.NumberFormat.prototype.setShowTrailingZeros\",\"showTrailingZeros\",\"setBaseFormatting\",\"goog.i18n.NumberFormat.prototype.setBaseFormatting\",\"baseFormattingNumber\",\"asserts\",\"assert\",\"isNull\",\"isFinite\",\"getBaseFormatting\",\"goog.i18n.NumberFormat.prototype.getBaseFormatting\",\"goog.i18n.NumberFormat.prototype.applyPattern_\",\"replace\",\"pos\",\"parseAffix_\",\"trunkStart\",\"parseTrunk_\",\"trunkLen\",\"length\",\"charAt\",\"PATTERN_SEPARATOR_\",\"goog.i18n.NumberFormat.prototype.applyStandardPattern_\",\"patternType\",\"DECIMAL_PATTERN\",\"SCIENTIFIC_PATTERN\",\"PERCENT_PATTERN\",\"currency\",\"adjustPrecision\",\"CURRENCY_PATTERN\",\"applyCompactStyle_\",\"goog.i18n.NumberFormat.prototype.applyCompactStyle_\",\"style\",\"parse\",\"goog.i18n.NumberFormat.prototype.parse\",\"text\",\"opt_pos\",\"ret\",\"NaN\",\"gotPositive\",\"indexOf\",\"gotNegative\",\"INFINITY\",\"Infinity\",\"parseNumber_\",\"goog.i18n.NumberFormat.prototype.parseNumber_\",\"sawDecimal\",\"sawExponent\",\"sawDigit\",\"exponentPos\",\"scale\",\"decimal\",\"DECIMAL_SEP\",\"grouping\",\"GROUP_SEP\",\"exponentChar\",\"EXP_SYMBOL\",\"normalizedText\",\"ch\",\"digit\",\"getDigit_\",\"PERMILL\",\"parseFloat\",\"format\",\"goog.i18n.NumberFormat.prototype.format\",\"isNaN\",\"NAN\",\"parts\",\"unit\",\"getUnitAfterRounding_\",\"Math\",\"pow\",\"divisorBase\",\"push\",\"prefix\",\"isNegative\",\"subformatExponential_\",\"subformatFixed_\",\"suffix\",\"join\",\"roundNumber_\",\"goog.i18n.NumberFormat.prototype.roundNumber_\",\"power\",\"shiftedNumber\",\"round\",\"roundToSignificantDigits_\",\"intValue\",\"fracValue\",\"floor\",\"formatNumberGroupingRepeatingDigitsParts_\",\"goog.i18n.NumberFormat.formatNumberGroupingRepeatingDigitsParts_\",\"zeroCode\",\"intPart\",\"groupingArray\",\"repeatedDigitLen\",\"nonRepeatedGroupCompleteCount\",\"currentGroupSizeIndex\",\"currentGroupSize\",\"digitLen\",\"i\",\"String\",\"fromCharCode\",\"Number\",\"repeatedDigitIndex\",\"formatNumberGroupingNonRepeatingDigitsParts_\",\"goog.i18n.NumberFormat.formatNumberGroupingNonRepeatingDigitsParts_\",\"digitLenLeft\",\"rightToLeftParts\",\"rightDigitIndex\",\"apply\",\"reverse\",\"goog.i18n.NumberFormat.prototype.subformatFixed_\",\"minIntDigits\",\"rounded\",\"numIntDigits\",\"intLog10_\",\"fractionPresent\",\"minimumFractionDigits\",\"translatableInt\",\"ZERO_DIGIT\",\"charCodeAt\",\"nonRepeatedGroupCount\",\"j\",\"fracPart\",\"fracPartSplit\",\"split\",\"floatFrac\",\"exp\",\"parseInt\",\"string\",\"repeat\",\"zeroesToAdd\",\"fracLen\",\"addExponentPart_\",\"goog.i18n.NumberFormat.prototype.addExponentPart_\",\"exponent\",\"MINUS_SIGN\",\"PLUS_SIGN\",\"exponentDigits\",\"zeroChar\",\"getMantissa_\",\"goog.i18n.NumberFormat.prototype.getMantissa_\",\"value\",\"divisor\",\"result\",\"goog.i18n.NumberFormat.prototype.subformatExponential_\",\"math\",\"safeFloor\",\"log\",\"goog.i18n.NumberFormat.prototype.getDigit_\",\"code\",\"PATTERN_ZERO_DIGIT_\",\"PATTERN_GROUPING_SEPARATOR_\",\"PATTERN_DECIMAL_SEPARATOR_\",\"PATTERN_PER_MILLE_\",\"PATTERN_PERCENT_\",\"PATTERN_DIGIT_\",\"PATTERN_EXPONENT_\",\"PATTERN_PLUS_\",\"PATTERN_CURRENCY_SIGN_\",\"QUOTE_\",\"goog.i18n.NumberFormat.prototype.parseAffix_\",\"affix\",\"inQuote\",\"len\",\"getLocalCurrencySign\",\"getGlobalCurrencySign\",\"getPortableCurrencySign\",\"goog.i18n.NumberFormat.prototype.parseTrunk_\",\"decimalPos\",\"digitLeftCount\",\"zeroDigitCount\",\"digitRightCount\",\"groupingCount\",\"loop\",\"n\",\"totalDigits\",\"effectiveDecimalPos\",\"CompactNumberUnit\",\"NULL_UNIT_\",\"getUnitFor_\",\"goog.i18n.NumberFormat.prototype.getUnitFor_\",\"base\",\"plurality\",\"table\",\"CompactNumberFormatSymbols\",\"COMPACT_DECIMAL_SHORT_PATTERN\",\"COMPACT_DECIMAL_LONG_PATTERN\",\"isDefAndNotNull\",\"patterns\",\"previousNonNullBase\",\"exec\",\"goog.i18n.NumberFormat.prototype.getUnitAfterRounding_\",\"formattingNumber\",\"pluralityNumber\",\"abs\",\"initialPlurality\",\"pluralForm_\",\"initialDivisor\",\"pluralityAttempt\",\"pluralityRounded\",\"formattingAttempt\",\"formattingRounded\",\"finalPlurality\",\"goog.i18n.NumberFormat.prototype.intLog10_\",\"goog.i18n.NumberFormat.prototype.roundToSignificantDigits_\",\"significantDigits\",\"digits\",\"magnitude\",\"point\",\"shifted\",\"goog.i18n.NumberFormat.prototype.pluralForm_\",\"quantity\",\"isCurrencyCodeBeforeValue\",\"goog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue\",\"posCurrSymbol\",\"posPound\",\"posZero\",\"posCurrValue\",\"MAX_VALUE\"]\n}\n"]