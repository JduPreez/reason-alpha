["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/net/xhrio.js"],"~:js","goog.provide(\"goog.net.XhrIo\");\ngoog.provide(\"goog.net.XhrIo.ResponseType\");\ngoog.require(\"goog.Timer\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.debug.entryPointRegistry\");\ngoog.require(\"goog.events.EventTarget\");\ngoog.require(\"goog.json.hybrid\");\ngoog.require(\"goog.log\");\ngoog.require(\"goog.net.ErrorCode\");\ngoog.require(\"goog.net.EventType\");\ngoog.require(\"goog.net.HttpStatus\");\ngoog.require(\"goog.net.XmlHttp\");\ngoog.require(\"goog.string\");\ngoog.require(\"goog.structs\");\ngoog.require(\"goog.structs.Map\");\ngoog.require(\"goog.uri.utils\");\ngoog.require(\"goog.userAgent\");\ngoog.forwardDeclare(\"goog.Uri\");\n/**\n * @constructor\n * @extends {goog.events.EventTarget}\n * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory\n */\ngoog.net.XhrIo = function(opt_xmlHttpFactory) {\n  goog.net.XhrIo.base(this, \"constructor\");\n  /** @type {!goog.structs.Map} */ this.headers = new goog.structs.Map;\n  /** @private @type {goog.net.XmlHttpFactory} */ this.xmlHttpFactory_ = opt_xmlHttpFactory || null;\n  /** @private @type {boolean} */ this.active_ = false;\n  /** @private @type {?goog.net.XhrLike.OrNative} */ this.xhr_ = null;\n  /** @private @type {Object} */ this.xhrOptions_ = null;\n  /** @private @type {(string|goog.Uri)} */ this.lastUri_ = \"\";\n  /** @private @type {string} */ this.lastMethod_ = \"\";\n  /** @private @type {!goog.net.ErrorCode} */ this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\n  /** @private @type {(Error|string)} */ this.lastError_ = \"\";\n  /** @private @type {boolean} */ this.errorDispatched_ = false;\n  /** @private @type {boolean} */ this.inSend_ = false;\n  /** @private @type {boolean} */ this.inOpen_ = false;\n  /** @private @type {boolean} */ this.inAbort_ = false;\n  /** @private @type {number} */ this.timeoutInterval_ = 0;\n  /** @private @type {?number} */ this.timeoutId_ = null;\n  /** @private @type {goog.net.XhrIo.ResponseType} */ this.responseType_ = goog.net.XhrIo.ResponseType.DEFAULT;\n  /** @private @type {boolean} */ this.withCredentials_ = false;\n  /** @private @type {boolean} */ this.progressEventsEnabled_ = false;\n  /** @private @type {boolean} */ this.useXhr2Timeout_ = false;\n};\ngoog.inherits(goog.net.XhrIo, goog.events.EventTarget);\n/** @enum {string} */ goog.net.XhrIo.ResponseType = {DEFAULT:\"\", TEXT:\"text\", DOCUMENT:\"document\", BLOB:\"blob\", ARRAY_BUFFER:\"arraybuffer\"};\n/** @private @const @type {?goog.log.Logger} */ goog.net.XhrIo.prototype.logger_ = goog.log.getLogger(\"goog.net.XhrIo\");\n/** @type {string} */ goog.net.XhrIo.CONTENT_TYPE_HEADER = \"Content-Type\";\n/** @type {string} */ goog.net.XhrIo.CONTENT_TRANSFER_ENCODING = \"Content-Transfer-Encoding\";\n/** @type {!RegExp} */ goog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;\ngoog.net.XhrIo.METHODS_WITH_FORM_DATA = [\"POST\", \"PUT\"];\n/** @type {string} */ goog.net.XhrIo.FORM_CONTENT_TYPE = \"application/x-www-form-urlencoded;charset\\x3dutf-8\";\n/** @private @const @type {string} */ goog.net.XhrIo.XHR2_TIMEOUT_ = \"timeout\";\n/** @private @const @type {string} */ goog.net.XhrIo.XHR2_ON_TIMEOUT_ = \"ontimeout\";\n/** @private @type {!Array<!goog.net.XhrIo>} */ goog.net.XhrIo.sendInstances_ = [];\n/**\n * @param {(string|goog.Uri)} url\n * @param {?function(this:goog.net.XhrIo,?)=} opt_callback\n * @param {string=} opt_method\n * @param {(ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string)=} opt_content\n * @param {(Object|goog.structs.Map)=} opt_headers\n * @param {number=} opt_timeoutInterval\n * @param {boolean=} opt_withCredentials\n * @return {!goog.net.XhrIo}\n */\ngoog.net.XhrIo.send = function(url, opt_callback, opt_method, opt_content, opt_headers, opt_timeoutInterval, opt_withCredentials) {\n  var x = new goog.net.XhrIo;\n  goog.net.XhrIo.sendInstances_.push(x);\n  if (opt_callback) {\n    x.listen(goog.net.EventType.COMPLETE, opt_callback);\n  }\n  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);\n  if (opt_timeoutInterval) {\n    x.setTimeoutInterval(opt_timeoutInterval);\n  }\n  if (opt_withCredentials) {\n    x.setWithCredentials(opt_withCredentials);\n  }\n  x.send(url, opt_method, opt_content, opt_headers);\n  return x;\n};\ngoog.net.XhrIo.cleanup = function() {\n  var instances = goog.net.XhrIo.sendInstances_;\n  while (instances.length) {\n    instances.pop().dispose();\n  }\n};\n/**\n * @param {goog.debug.ErrorHandler} errorHandler\n */\ngoog.net.XhrIo.protectEntryPoints = function(errorHandler) {\n  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = errorHandler.protectEntryPoint(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\n};\n/** @private */ goog.net.XhrIo.prototype.cleanupSend_ = function() {\n  this.dispose();\n  goog.array.remove(goog.net.XhrIo.sendInstances_, this);\n};\n/**\n * @return {number}\n */\ngoog.net.XhrIo.prototype.getTimeoutInterval = function() {\n  return this.timeoutInterval_;\n};\n/**\n * @param {number} ms\n */\ngoog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {\n  this.timeoutInterval_ = Math.max(0, ms);\n};\n/**\n * @param {goog.net.XhrIo.ResponseType} type\n */\ngoog.net.XhrIo.prototype.setResponseType = function(type) {\n  this.responseType_ = type;\n};\n/**\n * @return {goog.net.XhrIo.ResponseType}\n */\ngoog.net.XhrIo.prototype.getResponseType = function() {\n  return this.responseType_;\n};\n/**\n * @param {boolean} withCredentials\n */\ngoog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {\n  this.withCredentials_ = withCredentials;\n};\n/**\n * @return {boolean}\n */\ngoog.net.XhrIo.prototype.getWithCredentials = function() {\n  return this.withCredentials_;\n};\n/**\n * @param {boolean} enabled\n */\ngoog.net.XhrIo.prototype.setProgressEventsEnabled = function(enabled) {\n  this.progressEventsEnabled_ = enabled;\n};\n/**\n * @return {boolean}\n */\ngoog.net.XhrIo.prototype.getProgressEventsEnabled = function() {\n  return this.progressEventsEnabled_;\n};\n/**\n * @param {(string|goog.Uri)} url\n * @param {string=} opt_method\n * @param {(ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string)=} opt_content\n * @param {(Object|goog.structs.Map)=} opt_headers\n * @suppress {deprecated}\n */\ngoog.net.XhrIo.prototype.send = function(url, opt_method, opt_content, opt_headers) {\n  if (this.xhr_) {\n    throw Error(\"[goog.net.XhrIo] Object is active with another request\\x3d\" + this.lastUri_ + \"; newUri\\x3d\" + url);\n  }\n  var method = opt_method ? opt_method.toUpperCase() : \"GET\";\n  this.lastUri_ = url;\n  this.lastError_ = \"\";\n  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\n  this.lastMethod_ = method;\n  this.errorDispatched_ = false;\n  this.active_ = true;\n  this.xhr_ = this.createXhr();\n  this.xhrOptions_ = this.xmlHttpFactory_ ? this.xmlHttpFactory_.getOptions() : goog.net.XmlHttp.getOptions();\n  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);\n  if (this.getProgressEventsEnabled() && \"onprogress\" in this.xhr_) {\n    this.xhr_.onprogress = goog.bind(function(e) {\n      this.onProgressHandler_(e, true);\n    }, this);\n    if (this.xhr_.upload) {\n      this.xhr_.upload.onprogress = goog.bind(this.onProgressHandler_, this);\n    }\n  }\n  try {\n    goog.log.fine(this.logger_, this.formatMsg_(\"Opening Xhr\"));\n    this.inOpen_ = true;\n    this.xhr_.open(method, String(url), true);\n    this.inOpen_ = false;\n  } catch (err) {\n    goog.log.fine(this.logger_, this.formatMsg_(\"Error opening Xhr: \" + err.message));\n    this.error_(goog.net.ErrorCode.EXCEPTION, err);\n    return;\n  }\n  var content = opt_content || \"\";\n  var headers = this.headers.clone();\n  if (opt_headers) {\n    goog.structs.forEach(opt_headers, function(value, key) {\n      headers.set(key, value);\n    });\n  }\n  var contentTypeKey = goog.array.find(headers.getKeys(), goog.net.XhrIo.isContentTypeHeader_);\n  var contentIsFormData = goog.global[\"FormData\"] && content instanceof goog.global[\"FormData\"];\n  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) && !contentTypeKey && !contentIsFormData) {\n    headers.set(goog.net.XhrIo.CONTENT_TYPE_HEADER, goog.net.XhrIo.FORM_CONTENT_TYPE);\n  }\n  headers.forEach(function(value, key) {\n    this.xhr_.setRequestHeader(key, value);\n  }, this);\n  if (this.responseType_) {\n    this.xhr_.responseType = this.responseType_;\n  }\n  if (\"withCredentials\" in this.xhr_ && this.xhr_.withCredentials !== this.withCredentials_) {\n    this.xhr_.withCredentials = this.withCredentials_;\n  }\n  try {\n    this.cleanUpTimeoutTimer_();\n    if (this.timeoutInterval_ > 0) {\n      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);\n      goog.log.fine(this.logger_, this.formatMsg_(\"Will abort after \" + this.timeoutInterval_ + \"ms if incomplete, xhr2 \" + this.useXhr2Timeout_));\n      if (this.useXhr2Timeout_) {\n        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;\n        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = goog.bind(this.timeout_, this);\n      } else {\n        this.timeoutId_ = goog.Timer.callOnce(this.timeout_, this.timeoutInterval_, this);\n      }\n    }\n    goog.log.fine(this.logger_, this.formatMsg_(\"Sending request\"));\n    this.inSend_ = true;\n    this.xhr_.send(content);\n    this.inSend_ = false;\n  } catch (err$3) {\n    goog.log.fine(this.logger_, this.formatMsg_(\"Send error: \" + err$3.message));\n    this.error_(goog.net.ErrorCode.EXCEPTION, err$3);\n  }\n};\n/**\n * @private\n * @param {!goog.net.XhrLike.OrNative} xhr\n * @return {boolean}\n */\ngoog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {\n  return goog.userAgent.IE && goog.userAgent.isVersionOrHigher(9) && goog.isNumber(xhr[goog.net.XhrIo.XHR2_TIMEOUT_]) && goog.isDef(xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_]);\n};\n/**\n * @private\n * @param {string} header\n * @return {boolean}\n */\ngoog.net.XhrIo.isContentTypeHeader_ = function(header) {\n  return goog.string.caseInsensitiveEquals(goog.net.XhrIo.CONTENT_TYPE_HEADER, header);\n};\n/**\n * @protected\n * @return {!goog.net.XhrLike.OrNative}\n */\ngoog.net.XhrIo.prototype.createXhr = function() {\n  return this.xmlHttpFactory_ ? this.xmlHttpFactory_.createInstance() : goog.net.XmlHttp();\n};\n/** @private */ goog.net.XhrIo.prototype.timeout_ = function() {\n  if (typeof goog == \"undefined\") {\n  } else {\n    if (this.xhr_) {\n      this.lastError_ = \"Timed out after \" + this.timeoutInterval_ + \"ms, aborting\";\n      this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;\n      goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));\n      this.dispatchEvent(goog.net.EventType.TIMEOUT);\n      this.abort(goog.net.ErrorCode.TIMEOUT);\n    }\n  }\n};\n/**\n * @private\n * @param {goog.net.ErrorCode} errorCode\n * @param {Error} err\n */\ngoog.net.XhrIo.prototype.error_ = function(errorCode, err) {\n  this.active_ = false;\n  if (this.xhr_) {\n    this.inAbort_ = true;\n    this.xhr_.abort();\n    this.inAbort_ = false;\n  }\n  this.lastError_ = err;\n  this.lastErrorCode_ = errorCode;\n  this.dispatchErrors_();\n  this.cleanUpXhr_();\n};\n/** @private */ goog.net.XhrIo.prototype.dispatchErrors_ = function() {\n  if (!this.errorDispatched_) {\n    this.errorDispatched_ = true;\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\n    this.dispatchEvent(goog.net.EventType.ERROR);\n  }\n};\n/**\n * @param {goog.net.ErrorCode=} opt_failureCode\n */\ngoog.net.XhrIo.prototype.abort = function(opt_failureCode) {\n  if (this.xhr_ && this.active_) {\n    goog.log.fine(this.logger_, this.formatMsg_(\"Aborting\"));\n    this.active_ = false;\n    this.inAbort_ = true;\n    this.xhr_.abort();\n    this.inAbort_ = false;\n    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\n    this.dispatchEvent(goog.net.EventType.ABORT);\n    this.cleanUpXhr_();\n  }\n};\n/** @protected @override */ goog.net.XhrIo.prototype.disposeInternal = function() {\n  if (this.xhr_) {\n    if (this.active_) {\n      this.active_ = false;\n      this.inAbort_ = true;\n      this.xhr_.abort();\n      this.inAbort_ = false;\n    }\n    this.cleanUpXhr_(true);\n  }\n  goog.net.XhrIo.base(this, \"disposeInternal\");\n};\n/** @private */ goog.net.XhrIo.prototype.onReadyStateChange_ = function() {\n  if (this.isDisposed()) {\n    return;\n  }\n  if (!this.inOpen_ && !this.inSend_ && !this.inAbort_) {\n    this.onReadyStateChangeEntryPoint_();\n  } else {\n    this.onReadyStateChangeHelper_();\n  }\n};\n/** @private */ goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {\n  this.onReadyStateChangeHelper_();\n};\n/** @private */ goog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {\n  if (!this.active_) {\n    return;\n  }\n  if (typeof goog == \"undefined\") {\n  } else {\n    if (this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] && this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE && this.getStatus() == 2) {\n      goog.log.fine(this.logger_, this.formatMsg_(\"Local request error detected and ignored\"));\n    } else {\n      if (this.inSend_ && this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {\n        goog.Timer.callOnce(this.onReadyStateChange_, 0, this);\n        return;\n      }\n      this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);\n      if (this.isComplete()) {\n        goog.log.fine(this.logger_, this.formatMsg_(\"Request complete\"));\n        this.active_ = false;\n        try {\n          if (this.isSuccess()) {\n            this.dispatchEvent(goog.net.EventType.COMPLETE);\n            this.dispatchEvent(goog.net.EventType.SUCCESS);\n          } else {\n            this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;\n            this.lastError_ = this.getStatusText() + \" [\" + this.getStatus() + \"]\";\n            this.dispatchErrors_();\n          }\n        } finally {\n          this.cleanUpXhr_();\n        }\n      }\n    }\n  }\n};\n/**\n * @private\n * @param {!ProgressEvent} e\n * @param {boolean=} opt_isDownload\n */\ngoog.net.XhrIo.prototype.onProgressHandler_ = function(e, opt_isDownload) {\n  goog.asserts.assert(e.type === goog.net.EventType.PROGRESS, \"goog.net.EventType.PROGRESS is of the same type as raw XHR progress.\");\n  this.dispatchEvent(goog.net.XhrIo.buildProgressEvent_(e, goog.net.EventType.PROGRESS));\n  this.dispatchEvent(goog.net.XhrIo.buildProgressEvent_(e, opt_isDownload ? goog.net.EventType.DOWNLOAD_PROGRESS : goog.net.EventType.UPLOAD_PROGRESS));\n};\n/**\n * @private\n * @param {!ProgressEvent} e\n * @param {!goog.net.EventType} eventType\n * @return {!ProgressEvent}\n */\ngoog.net.XhrIo.buildProgressEvent_ = function(e, eventType) {\n  return (/** @type {!ProgressEvent} */ ({type:eventType, lengthComputable:e.lengthComputable, loaded:e.loaded, total:e.total}));\n};\n/**\n * @private\n * @param {boolean=} opt_fromDispose\n */\ngoog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {\n  if (this.xhr_) {\n    this.cleanUpTimeoutTimer_();\n    var xhr = this.xhr_;\n    var clearedOnReadyStateChange = this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ? goog.nullFunction : null;\n    this.xhr_ = null;\n    this.xhrOptions_ = null;\n    if (!opt_fromDispose) {\n      this.dispatchEvent(goog.net.EventType.READY);\n    }\n    try {\n      xhr.onreadystatechange = clearedOnReadyStateChange;\n    } catch (e) {\n      goog.log.error(this.logger_, \"Problem encountered resetting onreadystatechange: \" + e.message);\n    }\n  }\n};\n/** @private */ goog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {\n  if (this.xhr_ && this.useXhr2Timeout_) {\n    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;\n  }\n  if (goog.isNumber(this.timeoutId_)) {\n    goog.Timer.clear(this.timeoutId_);\n    this.timeoutId_ = null;\n  }\n};\n/**\n * @return {boolean}\n */\ngoog.net.XhrIo.prototype.isActive = function() {\n  return !!this.xhr_;\n};\n/**\n * @return {boolean}\n */\ngoog.net.XhrIo.prototype.isComplete = function() {\n  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;\n};\n/**\n * @return {boolean}\n */\ngoog.net.XhrIo.prototype.isSuccess = function() {\n  var status = this.getStatus();\n  return goog.net.HttpStatus.isSuccess(status) || status === 0 && !this.isLastUriEffectiveSchemeHttp_();\n};\n/**\n * @private\n * @return {boolean}\n */\ngoog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {\n  var scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));\n  return goog.net.XhrIo.HTTP_SCHEME_PATTERN.test(scheme);\n};\n/**\n * @return {goog.net.XmlHttp.ReadyState}\n */\ngoog.net.XhrIo.prototype.getReadyState = function() {\n  return this.xhr_ ? /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) : goog.net.XmlHttp.ReadyState.UNINITIALIZED;\n};\n/**\n * @return {number}\n */\ngoog.net.XhrIo.prototype.getStatus = function() {\n  try {\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ? this.xhr_.status : -1;\n  } catch (e) {\n    return -1;\n  }\n};\n/**\n * @return {string}\n */\ngoog.net.XhrIo.prototype.getStatusText = function() {\n  try {\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ? this.xhr_.statusText : \"\";\n  } catch (e) {\n    goog.log.fine(this.logger_, \"Can not get status: \" + e.message);\n    return \"\";\n  }\n};\n/**\n * @return {string}\n */\ngoog.net.XhrIo.prototype.getLastUri = function() {\n  return String(this.lastUri_);\n};\n/**\n * @return {string}\n */\ngoog.net.XhrIo.prototype.getResponseText = function() {\n  try {\n    return this.xhr_ ? this.xhr_.responseText : \"\";\n  } catch (e) {\n    goog.log.fine(this.logger_, \"Can not get responseText: \" + e.message);\n    return \"\";\n  }\n};\n/**\n * @return {Object}\n */\ngoog.net.XhrIo.prototype.getResponseBody = function() {\n  try {\n    if (this.xhr_ && \"responseBody\" in this.xhr_) {\n      return this.xhr_[\"responseBody\"];\n    }\n  } catch (e) {\n    goog.log.fine(this.logger_, \"Can not get responseBody: \" + e.message);\n  }\n  return null;\n};\n/**\n * @return {Document}\n */\ngoog.net.XhrIo.prototype.getResponseXml = function() {\n  try {\n    return this.xhr_ ? this.xhr_.responseXML : null;\n  } catch (e) {\n    goog.log.fine(this.logger_, \"Can not get responseXML: \" + e.message);\n    return null;\n  }\n};\n/**\n * @param {string=} opt_xssiPrefix\n * @return {(Object|undefined)}\n */\ngoog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {\n  if (!this.xhr_) {\n    return undefined;\n  }\n  var responseText = this.xhr_.responseText;\n  if (opt_xssiPrefix && responseText.indexOf(opt_xssiPrefix) == 0) {\n    responseText = responseText.substring(opt_xssiPrefix.length);\n  }\n  return goog.json.hybrid.parse(responseText);\n};\n/**\n * @return {*}\n */\ngoog.net.XhrIo.prototype.getResponse = function() {\n  try {\n    if (!this.xhr_) {\n      return null;\n    }\n    if (\"response\" in this.xhr_) {\n      return this.xhr_.response;\n    }\n    switch(this.responseType_) {\n      case goog.net.XhrIo.ResponseType.DEFAULT:\n      case goog.net.XhrIo.ResponseType.TEXT:\n        return this.xhr_.responseText;\n      case goog.net.XhrIo.ResponseType.ARRAY_BUFFER:\n        if (\"mozResponseArrayBuffer\" in this.xhr_) {\n          return this.xhr_.mozResponseArrayBuffer;\n        }\n    }\n    goog.log.error(this.logger_, \"Response type \" + this.responseType_ + \" is not \" + \"supported on this browser\");\n    return null;\n  } catch (e) {\n    goog.log.fine(this.logger_, \"Can not get response: \" + e.message);\n    return null;\n  }\n};\n/**\n * @param {string} key\n * @return {(string|undefined)}\n */\ngoog.net.XhrIo.prototype.getResponseHeader = function(key) {\n  if (!this.xhr_ || !this.isComplete()) {\n    return undefined;\n  }\n  var value = this.xhr_.getResponseHeader(key);\n  return goog.isNull(value) ? undefined : value;\n};\n/**\n * @return {string}\n */\ngoog.net.XhrIo.prototype.getAllResponseHeaders = function() {\n  return this.xhr_ && this.isComplete() ? this.xhr_.getAllResponseHeaders() : \"\";\n};\n/**\n * @return {!Object<string,string>}\n */\ngoog.net.XhrIo.prototype.getResponseHeaders = function() {\n  var headersObject = {};\n  var headersArray = this.getAllResponseHeaders().split(\"\\r\\n\");\n  for (var i = 0; i < headersArray.length; i++) {\n    if (goog.string.isEmptyOrWhitespace(headersArray[i])) {\n      continue;\n    }\n    var keyValue = goog.string.splitLimit(headersArray[i], \": \", 2);\n    if (headersObject[keyValue[0]]) {\n      headersObject[keyValue[0]] += \", \" + keyValue[1];\n    } else {\n      headersObject[keyValue[0]] = keyValue[1];\n    }\n  }\n  return headersObject;\n};\n/**\n * @param {string} key\n * @return {?string}\n */\ngoog.net.XhrIo.prototype.getStreamingResponseHeader = function(key) {\n  return this.xhr_ ? this.xhr_.getResponseHeader(key) : null;\n};\n/**\n * @return {string}\n */\ngoog.net.XhrIo.prototype.getAllStreamingResponseHeaders = function() {\n  return this.xhr_ ? this.xhr_.getAllResponseHeaders() : \"\";\n};\n/**\n * @return {goog.net.ErrorCode}\n */\ngoog.net.XhrIo.prototype.getLastErrorCode = function() {\n  return this.lastErrorCode_;\n};\n/**\n * @return {string}\n */\ngoog.net.XhrIo.prototype.getLastError = function() {\n  return goog.isString(this.lastError_) ? this.lastError_ : String(this.lastError_);\n};\n/**\n * @private\n * @param {string} msg\n * @return {string}\n */\ngoog.net.XhrIo.prototype.formatMsg_ = function(msg) {\n  return msg + \" [\" + this.lastMethod_ + \" \" + this.lastUri_ + \" \" + this.getStatus() + \"]\";\n};\ngoog.debug.entryPointRegistry.register(/**\n * @param {function(!Function):!Function} transformer\n */\nfunction(transformer) {\n  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\n});\n","~:source","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Wrapper class for handling XmlHttpRequests.\n *\n * One off requests can be sent through goog.net.XhrIo.send() or an\n * instance can be created to send multiple requests.  Each request uses its\n * own XmlHttpRequest object and handles clearing of the event callback to\n * ensure no leaks.\n *\n * XhrIo is event based, it dispatches events on success, failure, finishing,\n * ready-state change, or progress (download and upload).\n *\n * The ready-state or timeout event fires first, followed by\n * a generic completed event. Then the abort, error, or success event\n * is fired as appropriate. Progress events are fired as they are\n * received. Lastly, the ready event will fire to indicate that the\n * object may be used to make another request.\n *\n * The error event may also be called before completed and\n * ready-state-change if the XmlHttpRequest.open() or .send() methods throw.\n *\n * This class does not support multiple requests, queuing, or prioritization.\n *\n * When progress events are supported by the browser, and progress is\n * enabled via .setProgressEventsEnabled(true), the\n * goog.net.EventType.PROGRESS event will be the re-dispatched browser\n * progress event. Additionally, a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event\n * will be fired for download and upload progress respectively.\n *\n */\n\n\ngoog.provide('goog.net.XhrIo');\ngoog.provide('goog.net.XhrIo.ResponseType');\n\ngoog.require('goog.Timer');\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.entryPointRegistry');\ngoog.require('goog.events.EventTarget');\ngoog.require('goog.json.hybrid');\ngoog.require('goog.log');\ngoog.require('goog.net.ErrorCode');\ngoog.require('goog.net.EventType');\ngoog.require('goog.net.HttpStatus');\ngoog.require('goog.net.XmlHttp');\ngoog.require('goog.string');\ngoog.require('goog.structs');\ngoog.require('goog.structs.Map');\ngoog.require('goog.uri.utils');\ngoog.require('goog.userAgent');\n\ngoog.forwardDeclare('goog.Uri');\n\n\n\n/**\n * Basic class for handling XMLHttpRequests.\n * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Factory to use when\n *     creating XMLHttpRequest objects.\n * @constructor\n * @extends {goog.events.EventTarget}\n */\ngoog.net.XhrIo = function(opt_xmlHttpFactory) {\n  goog.net.XhrIo.base(this, 'constructor');\n\n  /**\n   * Map of default headers to add to every request, use:\n   * XhrIo.headers.set(name, value)\n   * @type {!goog.structs.Map}\n   */\n  this.headers = new goog.structs.Map();\n\n  /**\n   * Optional XmlHttpFactory\n   * @private {goog.net.XmlHttpFactory}\n   */\n  this.xmlHttpFactory_ = opt_xmlHttpFactory || null;\n\n  /**\n   * Whether XMLHttpRequest is active.  A request is active from the time send()\n   * is called until onReadyStateChange() is complete, or error() or abort()\n   * is called.\n   * @private {boolean}\n   */\n  this.active_ = false;\n\n  /**\n   * The XMLHttpRequest object that is being used for the transfer.\n   * @private {?goog.net.XhrLike.OrNative}\n   */\n  this.xhr_ = null;\n\n  /**\n   * The options to use with the current XMLHttpRequest object.\n   * @private {Object}\n   */\n  this.xhrOptions_ = null;\n\n  /**\n   * Last URL that was requested.\n   * @private {string|goog.Uri}\n   */\n  this.lastUri_ = '';\n\n  /**\n   * Method for the last request.\n   * @private {string}\n   */\n  this.lastMethod_ = '';\n\n  /**\n   * Last error code.\n   * @private {!goog.net.ErrorCode}\n   */\n  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\n\n  /**\n   * Last error message.\n   * @private {Error|string}\n   */\n  this.lastError_ = '';\n\n  /**\n   * Used to ensure that we don't dispatch an multiple ERROR events. This can\n   * happen in IE when it does a synchronous load and one error is handled in\n   * the ready statte change and one is handled due to send() throwing an\n   * exception.\n   * @private {boolean}\n   */\n  this.errorDispatched_ = false;\n\n  /**\n   * Used to make sure we don't fire the complete event from inside a send call.\n   * @private {boolean}\n   */\n  this.inSend_ = false;\n\n  /**\n   * Used in determining if a call to {@link #onReadyStateChange_} is from\n   * within a call to this.xhr_.open.\n   * @private {boolean}\n   */\n  this.inOpen_ = false;\n\n  /**\n   * Used in determining if a call to {@link #onReadyStateChange_} is from\n   * within a call to this.xhr_.abort.\n   * @private {boolean}\n   */\n  this.inAbort_ = false;\n\n  /**\n   * Number of milliseconds after which an incomplete request will be aborted\n   * and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout\n   * is set.\n   * @private {number}\n   */\n  this.timeoutInterval_ = 0;\n\n  /**\n   * Timer to track request timeout.\n   * @private {?number}\n   */\n  this.timeoutId_ = null;\n\n  /**\n   * The requested type for the response. The empty string means use the default\n   * XHR behavior.\n   * @private {goog.net.XhrIo.ResponseType}\n   */\n  this.responseType_ = goog.net.XhrIo.ResponseType.DEFAULT;\n\n  /**\n   * Whether a \"credentialed\" request is to be sent (one that is aware of\n   * cookies and authentication). This is applicable only for cross-domain\n   * requests and more recent browsers that support this part of the HTTP Access\n   * Control standard.\n   *\n   * @see http://www.w3.org/TR/XMLHttpRequest/#the-withcredentials-attribute\n   *\n   * @private {boolean}\n   */\n  this.withCredentials_ = false;\n\n  /**\n   * Whether progress events are enabled for this request. This is\n   * disabled by default because setting a progress event handler\n   * causes pre-flight OPTIONS requests to be sent for CORS requests,\n   * even in cases where a pre-flight request would not otherwise be\n   * sent.\n   *\n   * @see http://xhr.spec.whatwg.org/#security-considerations\n   *\n   * Note that this can cause problems for Firefox 22 and below, as an\n   * older \"LSProgressEvent\" will be dispatched by the browser. That\n   * progress event is no longer supported, and can lead to failures,\n   * including throwing exceptions.\n   *\n   * @see http://bugzilla.mozilla.org/show_bug.cgi?id=845631\n   * @see b/23469793\n   *\n   * @private {boolean}\n   */\n  this.progressEventsEnabled_ = false;\n\n  /**\n   * True if we can use XMLHttpRequest's timeout directly.\n   * @private {boolean}\n   */\n  this.useXhr2Timeout_ = false;\n};\ngoog.inherits(goog.net.XhrIo, goog.events.EventTarget);\n\n\n/**\n * Response types that may be requested for XMLHttpRequests.\n * @enum {string}\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute\n */\ngoog.net.XhrIo.ResponseType = {\n  DEFAULT: '',\n  TEXT: 'text',\n  DOCUMENT: 'document',\n  // Not supported as of Chrome 10.0.612.1 dev\n  BLOB: 'blob',\n  ARRAY_BUFFER: 'arraybuffer'\n};\n\n\n/**\n * A reference to the XhrIo logger\n * @private {?goog.log.Logger}\n * @const\n */\ngoog.net.XhrIo.prototype.logger_ = goog.log.getLogger('goog.net.XhrIo');\n\n\n/**\n * The Content-Type HTTP header name\n * @type {string}\n */\ngoog.net.XhrIo.CONTENT_TYPE_HEADER = 'Content-Type';\n\n\n/**\n * The Content-Transfer-Encoding HTTP header name\n * @type {string}\n */\ngoog.net.XhrIo.CONTENT_TRANSFER_ENCODING = 'Content-Transfer-Encoding';\n\n\n/**\n * The pattern matching the 'http' and 'https' URI schemes\n * @type {!RegExp}\n */\ngoog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;\n\n\n/**\n * The methods that typically come along with form data.  We set different\n * headers depending on whether the HTTP action is one of these.\n */\ngoog.net.XhrIo.METHODS_WITH_FORM_DATA = ['POST', 'PUT'];\n\n\n/**\n * The Content-Type HTTP header value for a url-encoded form\n * @type {string}\n */\ngoog.net.XhrIo.FORM_CONTENT_TYPE =\n    'application/x-www-form-urlencoded;charset=utf-8';\n\n\n/**\n * The XMLHttpRequest Level two timeout delay ms property name.\n *\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\n *\n * @private {string}\n * @const\n */\ngoog.net.XhrIo.XHR2_TIMEOUT_ = 'timeout';\n\n\n/**\n * The XMLHttpRequest Level two ontimeout handler property name.\n *\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\n *\n * @private {string}\n * @const\n */\ngoog.net.XhrIo.XHR2_ON_TIMEOUT_ = 'ontimeout';\n\n\n/**\n * All non-disposed instances of goog.net.XhrIo created\n * by {@link goog.net.XhrIo.send} are in this Array.\n * @see goog.net.XhrIo.cleanup\n * @private {!Array<!goog.net.XhrIo>}\n */\ngoog.net.XhrIo.sendInstances_ = [];\n\n\n/**\n * Static send that creates a short lived instance of XhrIo to send the\n * request.\n * @see goog.net.XhrIo.cleanup\n * @param {string|goog.Uri} url Uri to make request to.\n * @param {?function(this:goog.net.XhrIo, ?)=} opt_callback Callback function\n *     for when request is complete.\n * @param {string=} opt_method Send method, default: GET.\n * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}\n *     opt_content Body data.\n * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the\n *     request.\n * @param {number=} opt_timeoutInterval Number of milliseconds after which an\n *     incomplete request will be aborted; 0 means no timeout is set.\n * @param {boolean=} opt_withCredentials Whether to send credentials with the\n *     request. Default to false. See {@link goog.net.XhrIo#setWithCredentials}.\n * @return {!goog.net.XhrIo} The sent XhrIo.\n */\ngoog.net.XhrIo.send = function(\n    url, opt_callback, opt_method, opt_content, opt_headers,\n    opt_timeoutInterval, opt_withCredentials) {\n  var x = new goog.net.XhrIo();\n  goog.net.XhrIo.sendInstances_.push(x);\n  if (opt_callback) {\n    x.listen(goog.net.EventType.COMPLETE, opt_callback);\n  }\n  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);\n  if (opt_timeoutInterval) {\n    x.setTimeoutInterval(opt_timeoutInterval);\n  }\n  if (opt_withCredentials) {\n    x.setWithCredentials(opt_withCredentials);\n  }\n  x.send(url, opt_method, opt_content, opt_headers);\n  return x;\n};\n\n\n/**\n * Disposes all non-disposed instances of goog.net.XhrIo created by\n * {@link goog.net.XhrIo.send}.\n * {@link goog.net.XhrIo.send} cleans up the goog.net.XhrIo instance\n * it creates when the request completes or fails.  However, if\n * the request never completes, then the goog.net.XhrIo is not disposed.\n * This can occur if the window is unloaded before the request completes.\n * We could have {@link goog.net.XhrIo.send} return the goog.net.XhrIo\n * it creates and make the client of {@link goog.net.XhrIo.send} be\n * responsible for disposing it in this case.  However, this makes things\n * significantly more complicated for the client, and the whole point\n * of {@link goog.net.XhrIo.send} is that it's simple and easy to use.\n * Clients of {@link goog.net.XhrIo.send} should call\n * {@link goog.net.XhrIo.cleanup} when doing final\n * cleanup on window unload.\n */\ngoog.net.XhrIo.cleanup = function() {\n  var instances = goog.net.XhrIo.sendInstances_;\n  while (instances.length) {\n    instances.pop().dispose();\n  }\n};\n\n\n/**\n * Installs exception protection for all entry point introduced by\n * goog.net.XhrIo instances which are not protected by\n * {@link goog.debug.ErrorHandler#protectWindowSetTimeout},\n * {@link goog.debug.ErrorHandler#protectWindowSetInterval}, or\n * {@link goog.events.protectBrowserEventEntryPoint}.\n *\n * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to\n *     protect the entry point(s).\n */\ngoog.net.XhrIo.protectEntryPoints = function(errorHandler) {\n  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =\n      errorHandler.protectEntryPoint(\n          goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\n};\n\n\n/**\n * Disposes of the specified goog.net.XhrIo created by\n * {@link goog.net.XhrIo.send} and removes it from\n * {@link goog.net.XhrIo.pendingStaticSendInstances_}.\n * @private\n */\ngoog.net.XhrIo.prototype.cleanupSend_ = function() {\n  this.dispose();\n  goog.array.remove(goog.net.XhrIo.sendInstances_, this);\n};\n\n\n/**\n * Returns the number of milliseconds after which an incomplete request will be\n * aborted, or 0 if no timeout is set.\n * @return {number} Timeout interval in milliseconds.\n */\ngoog.net.XhrIo.prototype.getTimeoutInterval = function() {\n  return this.timeoutInterval_;\n};\n\n\n/**\n * Sets the number of milliseconds after which an incomplete request will be\n * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no\n * timeout is set.\n * @param {number} ms Timeout interval in milliseconds; 0 means none.\n */\ngoog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {\n  this.timeoutInterval_ = Math.max(0, ms);\n};\n\n\n/**\n * Sets the desired type for the response. At time of writing, this is only\n * supported in very recent versions of WebKit (10.0.612.1 dev and later).\n *\n * If this is used, the response may only be accessed via {@link #getResponse}.\n *\n * @param {goog.net.XhrIo.ResponseType} type The desired type for the response.\n */\ngoog.net.XhrIo.prototype.setResponseType = function(type) {\n  this.responseType_ = type;\n};\n\n\n/**\n * Gets the desired type for the response.\n * @return {goog.net.XhrIo.ResponseType} The desired type for the response.\n */\ngoog.net.XhrIo.prototype.getResponseType = function() {\n  return this.responseType_;\n};\n\n\n/**\n * Sets whether a \"credentialed\" request that is aware of cookie and\n * authentication information should be made. This option is only supported by\n * browsers that support HTTP Access Control. As of this writing, this option\n * is not supported in IE.\n *\n * @param {boolean} withCredentials Whether this should be a \"credentialed\"\n *     request.\n */\ngoog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {\n  this.withCredentials_ = withCredentials;\n};\n\n\n/**\n * Gets whether a \"credentialed\" request is to be sent.\n * @return {boolean} The desired type for the response.\n */\ngoog.net.XhrIo.prototype.getWithCredentials = function() {\n  return this.withCredentials_;\n};\n\n\n/**\n * Sets whether progress events are enabled for this request. Note\n * that progress events require pre-flight OPTIONS request handling\n * for CORS requests, and may cause trouble with older browsers. See\n * progressEventsEnabled_ for details.\n * @param {boolean} enabled Whether progress events should be enabled.\n */\ngoog.net.XhrIo.prototype.setProgressEventsEnabled = function(enabled) {\n  this.progressEventsEnabled_ = enabled;\n};\n\n\n/**\n * Gets whether progress events are enabled.\n * @return {boolean} Whether progress events are enabled for this request.\n */\ngoog.net.XhrIo.prototype.getProgressEventsEnabled = function() {\n  return this.progressEventsEnabled_;\n};\n\n\n/**\n * Instance send that actually uses XMLHttpRequest to make a server call.\n * @param {string|goog.Uri} url Uri to make request to.\n * @param {string=} opt_method Send method, default: GET.\n * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}\n *     opt_content Body data.\n * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the\n *     request.\n * @suppress {deprecated} Use deprecated goog.structs.forEach to allow different\n * types of parameters for opt_headers.\n */\ngoog.net.XhrIo.prototype.send = function(\n    url, opt_method, opt_content, opt_headers) {\n  if (this.xhr_) {\n    throw Error(\n        '[goog.net.XhrIo] Object is active with another request=' +\n        this.lastUri_ + '; newUri=' + url);\n  }\n\n  var method = opt_method ? opt_method.toUpperCase() : 'GET';\n\n  this.lastUri_ = url;\n  this.lastError_ = '';\n  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\n  this.lastMethod_ = method;\n  this.errorDispatched_ = false;\n  this.active_ = true;\n\n  // Use the factory to create the XHR object and options\n  this.xhr_ = this.createXhr();\n  this.xhrOptions_ = this.xmlHttpFactory_ ? this.xmlHttpFactory_.getOptions() :\n                                            goog.net.XmlHttp.getOptions();\n\n  // Set up the onreadystatechange callback\n  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);\n\n  // Set up upload/download progress events, if progress events are supported.\n  if (this.getProgressEventsEnabled() && 'onprogress' in this.xhr_) {\n    this.xhr_.onprogress =\n        goog.bind(function(e) { this.onProgressHandler_(e, true); }, this);\n    if (this.xhr_.upload) {\n      this.xhr_.upload.onprogress = goog.bind(this.onProgressHandler_, this);\n    }\n  }\n\n  /**\n   * Try to open the XMLHttpRequest (always async), if an error occurs here it\n   * is generally permission denied\n   */\n  try {\n    goog.log.fine(this.logger_, this.formatMsg_('Opening Xhr'));\n    this.inOpen_ = true;\n    this.xhr_.open(method, String(url), true);  // Always async!\n    this.inOpen_ = false;\n  } catch (err) {\n    goog.log.fine(\n        this.logger_, this.formatMsg_('Error opening Xhr: ' + err.message));\n    this.error_(goog.net.ErrorCode.EXCEPTION, err);\n    return;\n  }\n\n  // We can't use null since this won't allow requests with form data to have a\n  // content length specified which will cause some proxies to return a 411\n  // error.\n  var content = opt_content || '';\n\n  var headers = this.headers.clone();\n\n  // Add headers specific to this request\n  if (opt_headers) {\n    goog.structs.forEach(\n        opt_headers, function(value, key) { headers.set(key, value); });\n  }\n\n  // Find whether a content type header is set, ignoring case.\n  // HTTP header names are case-insensitive.  See:\n  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n  var contentTypeKey =\n      goog.array.find(headers.getKeys(), goog.net.XhrIo.isContentTypeHeader_);\n\n  var contentIsFormData =\n      (goog.global['FormData'] && (content instanceof goog.global['FormData']));\n  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) &&\n      !contentTypeKey && !contentIsFormData) {\n    // For requests typically with form data, default to the url-encoded form\n    // content type unless this is a FormData request.  For FormData,\n    // the browser will automatically add a multipart/form-data content type\n    // with an appropriate multipart boundary.\n    headers.set(\n        goog.net.XhrIo.CONTENT_TYPE_HEADER, goog.net.XhrIo.FORM_CONTENT_TYPE);\n  }\n\n  // Add the headers to the Xhr object\n  headers.forEach(function(value, key) {\n    this.xhr_.setRequestHeader(key, value);\n  }, this);\n\n  if (this.responseType_) {\n    this.xhr_.responseType = this.responseType_;\n  }\n  // Set xhr_.withCredentials only when the value is different, or else in\n  // synchronous XMLHtppRequest.open Firefox will throw an exception.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=736340\n  if ('withCredentials' in this.xhr_ &&\n      this.xhr_.withCredentials !== this.withCredentials_) {\n    this.xhr_.withCredentials = this.withCredentials_;\n  }\n\n  /**\n   * Try to send the request, or other wise report an error (404 not found).\n   */\n  try {\n    this.cleanUpTimeoutTimer_();  // Paranoid, should never be running.\n    if (this.timeoutInterval_ > 0) {\n      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);\n      goog.log.fine(\n          this.logger_, this.formatMsg_(\n                            'Will abort after ' + this.timeoutInterval_ +\n                            'ms if incomplete, xhr2 ' + this.useXhr2Timeout_));\n      if (this.useXhr2Timeout_) {\n        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;\n        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] =\n            goog.bind(this.timeout_, this);\n      } else {\n        this.timeoutId_ =\n            goog.Timer.callOnce(this.timeout_, this.timeoutInterval_, this);\n      }\n    }\n    goog.log.fine(this.logger_, this.formatMsg_('Sending request'));\n    this.inSend_ = true;\n    this.xhr_.send(content);\n    this.inSend_ = false;\n\n  } catch (err) {\n    goog.log.fine(this.logger_, this.formatMsg_('Send error: ' + err.message));\n    this.error_(goog.net.ErrorCode.EXCEPTION, err);\n  }\n};\n\n\n/**\n * Determines if the argument is an XMLHttpRequest that supports the level 2\n * timeout value and event.\n *\n * Currently, FF 21.0 OS X has the fields but won't actually call the timeout\n * handler.  Perhaps the confusion in the bug referenced below hasn't\n * entirely been resolved.\n *\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=525816\n *\n * @param {!goog.net.XhrLike.OrNative} xhr The request.\n * @return {boolean} True if the request supports level 2 timeout.\n * @private\n */\ngoog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {\n  return goog.userAgent.IE && goog.userAgent.isVersionOrHigher(9) &&\n      goog.isNumber(xhr[goog.net.XhrIo.XHR2_TIMEOUT_]) &&\n      goog.isDef(xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_]);\n};\n\n\n/**\n * @param {string} header An HTTP header key.\n * @return {boolean} Whether the key is a content type header (ignoring\n *     case.\n * @private\n */\ngoog.net.XhrIo.isContentTypeHeader_ = function(header) {\n  return goog.string.caseInsensitiveEquals(\n      goog.net.XhrIo.CONTENT_TYPE_HEADER, header);\n};\n\n\n/**\n * Creates a new XHR object.\n * @return {!goog.net.XhrLike.OrNative} The newly created XHR object.\n * @protected\n */\ngoog.net.XhrIo.prototype.createXhr = function() {\n  return this.xmlHttpFactory_ ? this.xmlHttpFactory_.createInstance() :\n                                goog.net.XmlHttp();\n};\n\n\n/**\n * The request didn't complete after {@link goog.net.XhrIo#timeoutInterval_}\n * milliseconds; raises a {@link goog.net.EventType.TIMEOUT} event and aborts\n * the request.\n * @private\n */\ngoog.net.XhrIo.prototype.timeout_ = function() {\n  if (typeof goog == 'undefined') {\n    // If goog is undefined then the callback has occurred as the application\n    // is unloading and will error.  Thus we let it silently fail.\n  } else if (this.xhr_) {\n    this.lastError_ =\n        'Timed out after ' + this.timeoutInterval_ + 'ms, aborting';\n    this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;\n    goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));\n    this.dispatchEvent(goog.net.EventType.TIMEOUT);\n    this.abort(goog.net.ErrorCode.TIMEOUT);\n  }\n};\n\n\n/**\n * Something errorred, so inactivate, fire error callback and clean up\n * @param {goog.net.ErrorCode} errorCode The error code.\n * @param {Error} err The error object.\n * @private\n */\ngoog.net.XhrIo.prototype.error_ = function(errorCode, err) {\n  this.active_ = false;\n  if (this.xhr_) {\n    this.inAbort_ = true;\n    this.xhr_.abort();  // Ensures XHR isn't hung (FF)\n    this.inAbort_ = false;\n  }\n  this.lastError_ = err;\n  this.lastErrorCode_ = errorCode;\n  this.dispatchErrors_();\n  this.cleanUpXhr_();\n};\n\n\n/**\n * Dispatches COMPLETE and ERROR in case of an error. This ensures that we do\n * not dispatch multiple error events.\n * @private\n */\ngoog.net.XhrIo.prototype.dispatchErrors_ = function() {\n  if (!this.errorDispatched_) {\n    this.errorDispatched_ = true;\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\n    this.dispatchEvent(goog.net.EventType.ERROR);\n  }\n};\n\n\n/**\n * Abort the current XMLHttpRequest\n * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -\n *     defaults to ABORT.\n */\ngoog.net.XhrIo.prototype.abort = function(opt_failureCode) {\n  if (this.xhr_ && this.active_) {\n    goog.log.fine(this.logger_, this.formatMsg_('Aborting'));\n    this.active_ = false;\n    this.inAbort_ = true;\n    this.xhr_.abort();\n    this.inAbort_ = false;\n    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\n    this.dispatchEvent(goog.net.EventType.ABORT);\n    this.cleanUpXhr_();\n  }\n};\n\n\n/**\n * Nullifies all callbacks to reduce risks of leaks.\n * @override\n * @protected\n */\ngoog.net.XhrIo.prototype.disposeInternal = function() {\n  if (this.xhr_) {\n    // We explicitly do not call xhr_.abort() unless active_ is still true.\n    // This is to avoid unnecessarily aborting a successful request when\n    // dispose() is called in a callback triggered by a complete response, but\n    // in which browser cleanup has not yet finished.\n    // (See http://b/issue?id=1684217.)\n    if (this.active_) {\n      this.active_ = false;\n      this.inAbort_ = true;\n      this.xhr_.abort();\n      this.inAbort_ = false;\n    }\n    this.cleanUpXhr_(true);\n  }\n\n  goog.net.XhrIo.base(this, 'disposeInternal');\n};\n\n\n/**\n * Internal handler for the XHR object's readystatechange event.  This method\n * checks the status and the readystate and fires the correct callbacks.\n * If the request has ended, the handlers are cleaned up and the XHR object is\n * nullified.\n * @private\n */\ngoog.net.XhrIo.prototype.onReadyStateChange_ = function() {\n  if (this.isDisposed()) {\n    // This method is the target of an untracked goog.Timer.callOnce().\n    return;\n  }\n  if (!this.inOpen_ && !this.inSend_ && !this.inAbort_) {\n    // Were not being called from within a call to this.xhr_.send\n    // this.xhr_.abort, or this.xhr_.open, so this is an entry point\n    this.onReadyStateChangeEntryPoint_();\n  } else {\n    this.onReadyStateChangeHelper_();\n  }\n};\n\n\n/**\n * Used to protect the onreadystatechange handler entry point.  Necessary\n * as {#onReadyStateChange_} maybe called from within send or abort, this\n * method is only called when {#onReadyStateChange_} is called as an\n * entry point.\n * {@see #protectEntryPoints}\n * @private\n */\ngoog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {\n  this.onReadyStateChangeHelper_();\n};\n\n\n/**\n * Helper for {@link #onReadyStateChange_}.  This is used so that\n * entry point calls to {@link #onReadyStateChange_} can be routed through\n * {@link #onReadyStateChangeEntryPoint_}.\n * @private\n */\ngoog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {\n  if (!this.active_) {\n    // can get called inside abort call\n    return;\n  }\n\n  if (typeof goog == 'undefined') {\n    // NOTE(user): If goog is undefined then the callback has occurred as the\n    // application is unloading and will error.  Thus we let it silently fail.\n\n  } else if (\n      this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] &&\n      this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE &&\n      this.getStatus() == 2) {\n    // NOTE(user): In IE if send() errors on a *local* request the readystate\n    // is still changed to COMPLETE.  We need to ignore it and allow the\n    // try/catch around send() to pick up the error.\n    goog.log.fine(\n        this.logger_,\n        this.formatMsg_('Local request error detected and ignored'));\n\n  } else {\n    // In IE when the response has been cached we sometimes get the callback\n    // from inside the send call and this usually breaks code that assumes that\n    // XhrIo is asynchronous.  If that is the case we delay the callback\n    // using a timer.\n    if (this.inSend_ &&\n        this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {\n      goog.Timer.callOnce(this.onReadyStateChange_, 0, this);\n      return;\n    }\n\n    this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);\n\n    // readyState indicates the transfer has finished\n    if (this.isComplete()) {\n      goog.log.fine(this.logger_, this.formatMsg_('Request complete'));\n\n      this.active_ = false;\n\n      try {\n        // Call the specific callbacks for success or failure. Only call the\n        // success if the status is 200 (HTTP_OK) or 304 (HTTP_CACHED)\n        if (this.isSuccess()) {\n          this.dispatchEvent(goog.net.EventType.COMPLETE);\n          this.dispatchEvent(goog.net.EventType.SUCCESS);\n        } else {\n          this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;\n          this.lastError_ =\n              this.getStatusText() + ' [' + this.getStatus() + ']';\n          this.dispatchErrors_();\n        }\n      } finally {\n        this.cleanUpXhr_();\n      }\n    }\n  }\n};\n\n\n/**\n * Internal handler for the XHR object's onprogress event. Fires both a generic\n * PROGRESS event and either a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event to\n * allow specific binding for each XHR progress event.\n * @param {!ProgressEvent} e XHR progress event.\n * @param {boolean=} opt_isDownload Whether the current progress event is from a\n *     download. Used to determine whether DOWNLOAD_PROGRESS or UPLOAD_PROGRESS\n *     event should be dispatched.\n * @private\n */\ngoog.net.XhrIo.prototype.onProgressHandler_ = function(e, opt_isDownload) {\n  goog.asserts.assert(\n      e.type === goog.net.EventType.PROGRESS,\n      'goog.net.EventType.PROGRESS is of the same type as raw XHR progress.');\n  this.dispatchEvent(\n      goog.net.XhrIo.buildProgressEvent_(e, goog.net.EventType.PROGRESS));\n  this.dispatchEvent(\n      goog.net.XhrIo.buildProgressEvent_(\n          e, opt_isDownload ? goog.net.EventType.DOWNLOAD_PROGRESS :\n                              goog.net.EventType.UPLOAD_PROGRESS));\n};\n\n\n/**\n * Creates a representation of the native ProgressEvent. IE doesn't support\n * constructing ProgressEvent via \"new\", and the alternatives (e.g.,\n * ProgressEvent.initProgressEvent) are non-standard or deprecated.\n * @param {!ProgressEvent} e XHR progress event.\n * @param {!goog.net.EventType} eventType The type of the event.\n * @return {!ProgressEvent} The progress event.\n * @private\n */\ngoog.net.XhrIo.buildProgressEvent_ = function(e, eventType) {\n  return /** @type {!ProgressEvent} */ ({\n    type: eventType,\n    lengthComputable: e.lengthComputable,\n    loaded: e.loaded,\n    total: e.total\n  });\n};\n\n\n/**\n * Remove the listener to protect against leaks, and nullify the XMLHttpRequest\n * object.\n * @param {boolean=} opt_fromDispose If this is from the dispose (don't want to\n *     fire any events).\n * @private\n */\ngoog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {\n  if (this.xhr_) {\n    // Cancel any pending timeout event handler.\n    this.cleanUpTimeoutTimer_();\n\n    // Save reference so we can mark it as closed after the READY event.  The\n    // READY event may trigger another request, thus we must nullify this.xhr_\n    var xhr = this.xhr_;\n    var clearedOnReadyStateChange =\n        this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ?\n        goog.nullFunction :\n        null;\n    this.xhr_ = null;\n    this.xhrOptions_ = null;\n\n    if (!opt_fromDispose) {\n      this.dispatchEvent(goog.net.EventType.READY);\n    }\n\n    try {\n      // NOTE(user): Not nullifying in FireFox can still leak if the callbacks\n      // are defined in the same scope as the instance of XhrIo. But, IE doesn't\n      // allow you to set the onreadystatechange to NULL so nullFunction is\n      // used.\n      xhr.onreadystatechange = clearedOnReadyStateChange;\n    } catch (e) {\n      // This seems to occur with a Gears HTTP request. Delayed the setting of\n      // this onreadystatechange until after READY is sent out and catching the\n      // error to see if we can track down the problem.\n      goog.log.error(\n          this.logger_,\n          'Problem encountered resetting onreadystatechange: ' + e.message);\n    }\n  }\n};\n\n\n/**\n * Make sure the timeout timer isn't running.\n * @private\n */\ngoog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {\n  if (this.xhr_ && this.useXhr2Timeout_) {\n    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;\n  }\n  if (goog.isNumber(this.timeoutId_)) {\n    goog.Timer.clear(this.timeoutId_);\n    this.timeoutId_ = null;\n  }\n};\n\n\n/**\n * @return {boolean} Whether there is an active request.\n */\ngoog.net.XhrIo.prototype.isActive = function() {\n  return !!this.xhr_;\n};\n\n\n/**\n * @return {boolean} Whether the request has completed.\n */\ngoog.net.XhrIo.prototype.isComplete = function() {\n  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;\n};\n\n\n/**\n * @return {boolean} Whether the request completed with a success.\n */\ngoog.net.XhrIo.prototype.isSuccess = function() {\n  var status = this.getStatus();\n  // A zero status code is considered successful for local files.\n  return goog.net.HttpStatus.isSuccess(status) ||\n      status === 0 && !this.isLastUriEffectiveSchemeHttp_();\n};\n\n\n/**\n * @return {boolean} whether the effective scheme of the last URI that was\n *     fetched was 'http' or 'https'.\n * @private\n */\ngoog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {\n  var scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));\n  return goog.net.XhrIo.HTTP_SCHEME_PATTERN.test(scheme);\n};\n\n\n/**\n * Get the readystate from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @return {goog.net.XmlHttp.ReadyState} goog.net.XmlHttp.ReadyState.*.\n */\ngoog.net.XhrIo.prototype.getReadyState = function() {\n  return this.xhr_ ?\n      /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) :\n                                                 goog.net.XmlHttp.ReadyState\n                                                     .UNINITIALIZED;\n};\n\n\n/**\n * Get the status from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @return {number} Http status.\n */\ngoog.net.XhrIo.prototype.getStatus = function() {\n  /**\n   * IE doesn't like you checking status until the readystate is greater than 2\n   * (i.e. it is receiving or complete).  The try/catch is used for when the\n   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.\n   */\n  try {\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?\n        this.xhr_.status :\n        -1;\n  } catch (e) {\n    return -1;\n  }\n};\n\n\n/**\n * Get the status text from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @return {string} Status text.\n */\ngoog.net.XhrIo.prototype.getStatusText = function() {\n  /**\n   * IE doesn't like you checking status until the readystate is greater than 2\n   * (i.e. it is receiving or complete).  The try/catch is used for when the\n   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.\n   */\n  try {\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?\n        this.xhr_.statusText :\n        '';\n  } catch (e) {\n    goog.log.fine(this.logger_, 'Can not get status: ' + e.message);\n    return '';\n  }\n};\n\n\n/**\n * Get the last Uri that was requested\n * @return {string} Last Uri.\n */\ngoog.net.XhrIo.prototype.getLastUri = function() {\n  return String(this.lastUri_);\n};\n\n\n/**\n * Get the response text from the Xhr object\n * Will only return correct result when called from the context of a callback.\n * @return {string} Result from the server, or '' if no result available.\n */\ngoog.net.XhrIo.prototype.getResponseText = function() {\n  try {\n    return this.xhr_ ? this.xhr_.responseText : '';\n  } catch (e) {\n    // http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute\n    // states that responseText should return '' (and responseXML null)\n    // when the state is not LOADING or DONE. Instead, IE can\n    // throw unexpected exceptions, for example when a request is aborted\n    // or no data is available yet.\n    goog.log.fine(this.logger_, 'Can not get responseText: ' + e.message);\n    return '';\n  }\n};\n\n\n/**\n * Get the response body from the Xhr object. This property is only available\n * in IE since version 7 according to MSDN:\n * http://msdn.microsoft.com/en-us/library/ie/ms534368(v=vs.85).aspx\n * Will only return correct result when called from the context of a callback.\n *\n * One option is to construct a VBArray from the returned object and convert\n * it to a JavaScript array using the toArray method:\n * {@code (new window['VBArray'](xhrIo.getResponseBody())).toArray()}\n * This will result in an array of numbers in the range of [0..255]\n *\n * Another option is to use the VBScript CStr method to convert it into a\n * string as outlined in http://stackoverflow.com/questions/1919972\n *\n * @return {Object} Binary result from the server or null if not available.\n */\ngoog.net.XhrIo.prototype.getResponseBody = function() {\n\n  try {\n    if (this.xhr_ && 'responseBody' in this.xhr_) {\n      return this.xhr_['responseBody'];\n    }\n  } catch (e) {\n    // IE can throw unexpected exceptions, for example when a request is aborted\n    // or no data is yet available.\n    goog.log.fine(this.logger_, 'Can not get responseBody: ' + e.message);\n  }\n  return null;\n};\n\n\n/**\n * Get the response XML from the Xhr object\n * Will only return correct result when called from the context of a callback.\n * @return {Document} The DOM Document representing the XML file, or null\n * if no result available.\n */\ngoog.net.XhrIo.prototype.getResponseXml = function() {\n\n  try {\n    return this.xhr_ ? this.xhr_.responseXML : null;\n  } catch (e) {\n    goog.log.fine(this.logger_, 'Can not get responseXML: ' + e.message);\n    return null;\n  }\n};\n\n\n/**\n * Get the response and evaluates it as JSON from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @param {string=} opt_xssiPrefix Optional XSSI prefix string to use for\n *     stripping of the response before parsing. This needs to be set only if\n *     your backend server prepends the same prefix string to the JSON response.\n * @throws Error if the response text is invalid JSON.\n * @return {Object|undefined} JavaScript object.\n */\ngoog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {\n  if (!this.xhr_) {\n    return undefined;\n  }\n\n  var responseText = this.xhr_.responseText;\n  if (opt_xssiPrefix && responseText.indexOf(opt_xssiPrefix) == 0) {\n    responseText = responseText.substring(opt_xssiPrefix.length);\n  }\n\n  return goog.json.hybrid.parse(responseText);\n};\n\n\n/**\n * Get the response as the type specificed by {@link #setResponseType}. At time\n * of writing, this is only directly supported in very recent versions of WebKit\n * (10.0.612.1 dev and later). If the field is not supported directly, we will\n * try to emulate it.\n *\n * Emulating the response means following the rules laid out at\n * http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute\n *\n * On browsers with no support for this (Chrome < 10, Firefox < 4, etc), only\n * response types of DEFAULT or TEXT may be used, and the response returned will\n * be the text response.\n *\n * On browsers with Mozilla's draft support for array buffers (Firefox 4, 5),\n * only response types of DEFAULT, TEXT, and ARRAY_BUFFER may be used, and the\n * response returned will be either the text response or the Mozilla\n * implementation of the array buffer response.\n *\n * On browsers will full support, any valid response type supported by the\n * browser may be used, and the response provided by the browser will be\n * returned.\n *\n * @return {*} The response.\n */\ngoog.net.XhrIo.prototype.getResponse = function() {\n\n  try {\n    if (!this.xhr_) {\n      return null;\n    }\n    if ('response' in this.xhr_) {\n      return this.xhr_.response;\n    }\n    switch (this.responseType_) {\n      case goog.net.XhrIo.ResponseType.DEFAULT:\n      case goog.net.XhrIo.ResponseType.TEXT:\n        return this.xhr_.responseText;\n      // DOCUMENT and BLOB don't need to be handled here because they are\n      // introduced in the same spec that adds the .response field, and would\n      // have been caught above.\n      // ARRAY_BUFFER needs an implementation for Firefox 4, where it was\n      // implemented using a draft spec rather than the final spec.\n      case goog.net.XhrIo.ResponseType.ARRAY_BUFFER:\n        if ('mozResponseArrayBuffer' in this.xhr_) {\n          return this.xhr_.mozResponseArrayBuffer;\n        }\n    }\n    // Fell through to a response type that is not supported on this browser.\n    goog.log.error(\n        this.logger_, 'Response type ' + this.responseType_ + ' is not ' +\n            'supported on this browser');\n    return null;\n  } catch (e) {\n    goog.log.fine(this.logger_, 'Can not get response: ' + e.message);\n    return null;\n  }\n};\n\n\n/**\n * Get the value of the response-header with the given name from the Xhr object\n * Will only return correct result when called from the context of a callback\n * and the request has completed\n * @param {string} key The name of the response-header to retrieve.\n * @return {string|undefined} The value of the response-header named key.\n */\ngoog.net.XhrIo.prototype.getResponseHeader = function(key) {\n  if (!this.xhr_ || !this.isComplete()) {\n    return undefined;\n  }\n\n  var value = this.xhr_.getResponseHeader(key);\n  return goog.isNull(value) ? undefined : value;\n};\n\n\n/**\n * Gets the text of all the headers in the response.\n * Will only return correct result when called from the context of a callback\n * and the request has completed.\n * @return {string} The value of the response headers or empty string.\n */\ngoog.net.XhrIo.prototype.getAllResponseHeaders = function() {\n  return this.xhr_ && this.isComplete() ? this.xhr_.getAllResponseHeaders() :\n                                          '';\n};\n\n\n/**\n * Returns all response headers as a key-value map.\n * Multiple values for the same header key can be combined into one,\n * separated by a comma and a space.\n * Note that the native getResponseHeader method for retrieving a single header\n * does a case insensitive match on the header name. This method does not\n * include any case normalization logic, it will just return a key-value\n * representation of the headers.\n * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method\n * @return {!Object<string, string>} An object with the header keys as keys\n *     and header values as values.\n */\ngoog.net.XhrIo.prototype.getResponseHeaders = function() {\n  var headersObject = {};\n  var headersArray = this.getAllResponseHeaders().split('\\r\\n');\n  for (var i = 0; i < headersArray.length; i++) {\n    if (goog.string.isEmptyOrWhitespace(headersArray[i])) {\n      continue;\n    }\n    var keyValue = goog.string.splitLimit(headersArray[i], ': ', 2);\n    if (headersObject[keyValue[0]]) {\n      headersObject[keyValue[0]] += ', ' + keyValue[1];\n    } else {\n      headersObject[keyValue[0]] = keyValue[1];\n    }\n  }\n  return headersObject;\n};\n\n\n/**\n * Get the value of the response-header with the given name from the Xhr object.\n * As opposed to {@link #getResponseHeader}, this method does not require that\n * the request has completed.\n * @param {string} key The name of the response-header to retrieve.\n * @return {?string} The value of the response-header, or null if it is\n *     unavailable.\n */\ngoog.net.XhrIo.prototype.getStreamingResponseHeader = function(key) {\n  return this.xhr_ ? this.xhr_.getResponseHeader(key) : null;\n};\n\n\n/**\n * Gets the text of all the headers in the response. As opposed to\n * {@link #getAllResponseHeaders}, this method does not require that the request\n * has completed.\n * @return {string} The value of the response headers or empty string.\n */\ngoog.net.XhrIo.prototype.getAllStreamingResponseHeaders = function() {\n  return this.xhr_ ? this.xhr_.getAllResponseHeaders() : '';\n};\n\n\n/**\n * Get the last error message\n * @return {goog.net.ErrorCode} Last error code.\n */\ngoog.net.XhrIo.prototype.getLastErrorCode = function() {\n  return this.lastErrorCode_;\n};\n\n\n/**\n * Get the last error message\n * @return {string} Last error message.\n */\ngoog.net.XhrIo.prototype.getLastError = function() {\n  return goog.isString(this.lastError_) ? this.lastError_ :\n                                          String(this.lastError_);\n};\n\n\n/**\n * Adds the last method, status and URI to the message.  This is used to add\n * this information to the logging calls.\n * @param {string} msg The message text that we want to add the extra text to.\n * @return {string} The message with the extra text appended.\n * @private\n */\ngoog.net.XhrIo.prototype.formatMsg_ = function(msg) {\n  return msg + ' [' + this.lastMethod_ + ' ' + this.lastUri_ + ' ' +\n      this.getStatus() + ']';\n};\n\n\n// Register the xhr handler as an entry point, so that\n// it can be monitored for exception handling, etc.\ngoog.debug.entryPointRegistry.register(\n    /**\n     * @param {function(!Function): !Function} transformer The transforming\n     *     function.\n     */\n    function(transformer) {\n      goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =\n          transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\n    });\n","~:compiled-at",1574163696301,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.net.xhrio.js\",\n\"lineCount\":622,\n\"mappings\":\"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\",\n\"sources\":[\"goog/net/xhrio.js\"],\n\"sourcesContent\":[\"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Wrapper class for handling XmlHttpRequests.\\n *\\n * One off requests can be sent through goog.net.XhrIo.send() or an\\n * instance can be created to send multiple requests.  Each request uses its\\n * own XmlHttpRequest object and handles clearing of the event callback to\\n * ensure no leaks.\\n *\\n * XhrIo is event based, it dispatches events on success, failure, finishing,\\n * ready-state change, or progress (download and upload).\\n *\\n * The ready-state or timeout event fires first, followed by\\n * a generic completed event. Then the abort, error, or success event\\n * is fired as appropriate. Progress events are fired as they are\\n * received. Lastly, the ready event will fire to indicate that the\\n * object may be used to make another request.\\n *\\n * The error event may also be called before completed and\\n * ready-state-change if the XmlHttpRequest.open() or .send() methods throw.\\n *\\n * This class does not support multiple requests, queuing, or prioritization.\\n *\\n * When progress events are supported by the browser, and progress is\\n * enabled via .setProgressEventsEnabled(true), the\\n * goog.net.EventType.PROGRESS event will be the re-dispatched browser\\n * progress event. Additionally, a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event\\n * will be fired for download and upload progress respectively.\\n *\\n */\\n\\n\\ngoog.provide('goog.net.XhrIo');\\ngoog.provide('goog.net.XhrIo.ResponseType');\\n\\ngoog.require('goog.Timer');\\ngoog.require('goog.array');\\ngoog.require('goog.asserts');\\ngoog.require('goog.debug.entryPointRegistry');\\ngoog.require('goog.events.EventTarget');\\ngoog.require('goog.json.hybrid');\\ngoog.require('goog.log');\\ngoog.require('goog.net.ErrorCode');\\ngoog.require('goog.net.EventType');\\ngoog.require('goog.net.HttpStatus');\\ngoog.require('goog.net.XmlHttp');\\ngoog.require('goog.string');\\ngoog.require('goog.structs');\\ngoog.require('goog.structs.Map');\\ngoog.require('goog.uri.utils');\\ngoog.require('goog.userAgent');\\n\\ngoog.forwardDeclare('goog.Uri');\\n\\n\\n\\n/**\\n * Basic class for handling XMLHttpRequests.\\n * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Factory to use when\\n *     creating XMLHttpRequest objects.\\n * @constructor\\n * @extends {goog.events.EventTarget}\\n */\\ngoog.net.XhrIo = function(opt_xmlHttpFactory) {\\n  goog.net.XhrIo.base(this, 'constructor');\\n\\n  /**\\n   * Map of default headers to add to every request, use:\\n   * XhrIo.headers.set(name, value)\\n   * @type {!goog.structs.Map}\\n   */\\n  this.headers = new goog.structs.Map();\\n\\n  /**\\n   * Optional XmlHttpFactory\\n   * @private {goog.net.XmlHttpFactory}\\n   */\\n  this.xmlHttpFactory_ = opt_xmlHttpFactory || null;\\n\\n  /**\\n   * Whether XMLHttpRequest is active.  A request is active from the time send()\\n   * is called until onReadyStateChange() is complete, or error() or abort()\\n   * is called.\\n   * @private {boolean}\\n   */\\n  this.active_ = false;\\n\\n  /**\\n   * The XMLHttpRequest object that is being used for the transfer.\\n   * @private {?goog.net.XhrLike.OrNative}\\n   */\\n  this.xhr_ = null;\\n\\n  /**\\n   * The options to use with the current XMLHttpRequest object.\\n   * @private {Object}\\n   */\\n  this.xhrOptions_ = null;\\n\\n  /**\\n   * Last URL that was requested.\\n   * @private {string|goog.Uri}\\n   */\\n  this.lastUri_ = '';\\n\\n  /**\\n   * Method for the last request.\\n   * @private {string}\\n   */\\n  this.lastMethod_ = '';\\n\\n  /**\\n   * Last error code.\\n   * @private {!goog.net.ErrorCode}\\n   */\\n  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\\n\\n  /**\\n   * Last error message.\\n   * @private {Error|string}\\n   */\\n  this.lastError_ = '';\\n\\n  /**\\n   * Used to ensure that we don't dispatch an multiple ERROR events. This can\\n   * happen in IE when it does a synchronous load and one error is handled in\\n   * the ready statte change and one is handled due to send() throwing an\\n   * exception.\\n   * @private {boolean}\\n   */\\n  this.errorDispatched_ = false;\\n\\n  /**\\n   * Used to make sure we don't fire the complete event from inside a send call.\\n   * @private {boolean}\\n   */\\n  this.inSend_ = false;\\n\\n  /**\\n   * Used in determining if a call to {@link #onReadyStateChange_} is from\\n   * within a call to this.xhr_.open.\\n   * @private {boolean}\\n   */\\n  this.inOpen_ = false;\\n\\n  /**\\n   * Used in determining if a call to {@link #onReadyStateChange_} is from\\n   * within a call to this.xhr_.abort.\\n   * @private {boolean}\\n   */\\n  this.inAbort_ = false;\\n\\n  /**\\n   * Number of milliseconds after which an incomplete request will be aborted\\n   * and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout\\n   * is set.\\n   * @private {number}\\n   */\\n  this.timeoutInterval_ = 0;\\n\\n  /**\\n   * Timer to track request timeout.\\n   * @private {?number}\\n   */\\n  this.timeoutId_ = null;\\n\\n  /**\\n   * The requested type for the response. The empty string means use the default\\n   * XHR behavior.\\n   * @private {goog.net.XhrIo.ResponseType}\\n   */\\n  this.responseType_ = goog.net.XhrIo.ResponseType.DEFAULT;\\n\\n  /**\\n   * Whether a \\\"credentialed\\\" request is to be sent (one that is aware of\\n   * cookies and authentication). This is applicable only for cross-domain\\n   * requests and more recent browsers that support this part of the HTTP Access\\n   * Control standard.\\n   *\\n   * @see http://www.w3.org/TR/XMLHttpRequest/#the-withcredentials-attribute\\n   *\\n   * @private {boolean}\\n   */\\n  this.withCredentials_ = false;\\n\\n  /**\\n   * Whether progress events are enabled for this request. This is\\n   * disabled by default because setting a progress event handler\\n   * causes pre-flight OPTIONS requests to be sent for CORS requests,\\n   * even in cases where a pre-flight request would not otherwise be\\n   * sent.\\n   *\\n   * @see http://xhr.spec.whatwg.org/#security-considerations\\n   *\\n   * Note that this can cause problems for Firefox 22 and below, as an\\n   * older \\\"LSProgressEvent\\\" will be dispatched by the browser. That\\n   * progress event is no longer supported, and can lead to failures,\\n   * including throwing exceptions.\\n   *\\n   * @see http://bugzilla.mozilla.org/show_bug.cgi?id=845631\\n   * @see b/23469793\\n   *\\n   * @private {boolean}\\n   */\\n  this.progressEventsEnabled_ = false;\\n\\n  /**\\n   * True if we can use XMLHttpRequest's timeout directly.\\n   * @private {boolean}\\n   */\\n  this.useXhr2Timeout_ = false;\\n};\\ngoog.inherits(goog.net.XhrIo, goog.events.EventTarget);\\n\\n\\n/**\\n * Response types that may be requested for XMLHttpRequests.\\n * @enum {string}\\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute\\n */\\ngoog.net.XhrIo.ResponseType = {\\n  DEFAULT: '',\\n  TEXT: 'text',\\n  DOCUMENT: 'document',\\n  // Not supported as of Chrome 10.0.612.1 dev\\n  BLOB: 'blob',\\n  ARRAY_BUFFER: 'arraybuffer'\\n};\\n\\n\\n/**\\n * A reference to the XhrIo logger\\n * @private {?goog.log.Logger}\\n * @const\\n */\\ngoog.net.XhrIo.prototype.logger_ = goog.log.getLogger('goog.net.XhrIo');\\n\\n\\n/**\\n * The Content-Type HTTP header name\\n * @type {string}\\n */\\ngoog.net.XhrIo.CONTENT_TYPE_HEADER = 'Content-Type';\\n\\n\\n/**\\n * The Content-Transfer-Encoding HTTP header name\\n * @type {string}\\n */\\ngoog.net.XhrIo.CONTENT_TRANSFER_ENCODING = 'Content-Transfer-Encoding';\\n\\n\\n/**\\n * The pattern matching the 'http' and 'https' URI schemes\\n * @type {!RegExp}\\n */\\ngoog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;\\n\\n\\n/**\\n * The methods that typically come along with form data.  We set different\\n * headers depending on whether the HTTP action is one of these.\\n */\\ngoog.net.XhrIo.METHODS_WITH_FORM_DATA = ['POST', 'PUT'];\\n\\n\\n/**\\n * The Content-Type HTTP header value for a url-encoded form\\n * @type {string}\\n */\\ngoog.net.XhrIo.FORM_CONTENT_TYPE =\\n    'application/x-www-form-urlencoded;charset=utf-8';\\n\\n\\n/**\\n * The XMLHttpRequest Level two timeout delay ms property name.\\n *\\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\\n *\\n * @private {string}\\n * @const\\n */\\ngoog.net.XhrIo.XHR2_TIMEOUT_ = 'timeout';\\n\\n\\n/**\\n * The XMLHttpRequest Level two ontimeout handler property name.\\n *\\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\\n *\\n * @private {string}\\n * @const\\n */\\ngoog.net.XhrIo.XHR2_ON_TIMEOUT_ = 'ontimeout';\\n\\n\\n/**\\n * All non-disposed instances of goog.net.XhrIo created\\n * by {@link goog.net.XhrIo.send} are in this Array.\\n * @see goog.net.XhrIo.cleanup\\n * @private {!Array<!goog.net.XhrIo>}\\n */\\ngoog.net.XhrIo.sendInstances_ = [];\\n\\n\\n/**\\n * Static send that creates a short lived instance of XhrIo to send the\\n * request.\\n * @see goog.net.XhrIo.cleanup\\n * @param {string|goog.Uri} url Uri to make request to.\\n * @param {?function(this:goog.net.XhrIo, ?)=} opt_callback Callback function\\n *     for when request is complete.\\n * @param {string=} opt_method Send method, default: GET.\\n * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}\\n *     opt_content Body data.\\n * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the\\n *     request.\\n * @param {number=} opt_timeoutInterval Number of milliseconds after which an\\n *     incomplete request will be aborted; 0 means no timeout is set.\\n * @param {boolean=} opt_withCredentials Whether to send credentials with the\\n *     request. Default to false. See {@link goog.net.XhrIo#setWithCredentials}.\\n * @return {!goog.net.XhrIo} The sent XhrIo.\\n */\\ngoog.net.XhrIo.send = function(\\n    url, opt_callback, opt_method, opt_content, opt_headers,\\n    opt_timeoutInterval, opt_withCredentials) {\\n  var x = new goog.net.XhrIo();\\n  goog.net.XhrIo.sendInstances_.push(x);\\n  if (opt_callback) {\\n    x.listen(goog.net.EventType.COMPLETE, opt_callback);\\n  }\\n  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);\\n  if (opt_timeoutInterval) {\\n    x.setTimeoutInterval(opt_timeoutInterval);\\n  }\\n  if (opt_withCredentials) {\\n    x.setWithCredentials(opt_withCredentials);\\n  }\\n  x.send(url, opt_method, opt_content, opt_headers);\\n  return x;\\n};\\n\\n\\n/**\\n * Disposes all non-disposed instances of goog.net.XhrIo created by\\n * {@link goog.net.XhrIo.send}.\\n * {@link goog.net.XhrIo.send} cleans up the goog.net.XhrIo instance\\n * it creates when the request completes or fails.  However, if\\n * the request never completes, then the goog.net.XhrIo is not disposed.\\n * This can occur if the window is unloaded before the request completes.\\n * We could have {@link goog.net.XhrIo.send} return the goog.net.XhrIo\\n * it creates and make the client of {@link goog.net.XhrIo.send} be\\n * responsible for disposing it in this case.  However, this makes things\\n * significantly more complicated for the client, and the whole point\\n * of {@link goog.net.XhrIo.send} is that it's simple and easy to use.\\n * Clients of {@link goog.net.XhrIo.send} should call\\n * {@link goog.net.XhrIo.cleanup} when doing final\\n * cleanup on window unload.\\n */\\ngoog.net.XhrIo.cleanup = function() {\\n  var instances = goog.net.XhrIo.sendInstances_;\\n  while (instances.length) {\\n    instances.pop().dispose();\\n  }\\n};\\n\\n\\n/**\\n * Installs exception protection for all entry point introduced by\\n * goog.net.XhrIo instances which are not protected by\\n * {@link goog.debug.ErrorHandler#protectWindowSetTimeout},\\n * {@link goog.debug.ErrorHandler#protectWindowSetInterval}, or\\n * {@link goog.events.protectBrowserEventEntryPoint}.\\n *\\n * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to\\n *     protect the entry point(s).\\n */\\ngoog.net.XhrIo.protectEntryPoints = function(errorHandler) {\\n  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =\\n      errorHandler.protectEntryPoint(\\n          goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\\n};\\n\\n\\n/**\\n * Disposes of the specified goog.net.XhrIo created by\\n * {@link goog.net.XhrIo.send} and removes it from\\n * {@link goog.net.XhrIo.pendingStaticSendInstances_}.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.cleanupSend_ = function() {\\n  this.dispose();\\n  goog.array.remove(goog.net.XhrIo.sendInstances_, this);\\n};\\n\\n\\n/**\\n * Returns the number of milliseconds after which an incomplete request will be\\n * aborted, or 0 if no timeout is set.\\n * @return {number} Timeout interval in milliseconds.\\n */\\ngoog.net.XhrIo.prototype.getTimeoutInterval = function() {\\n  return this.timeoutInterval_;\\n};\\n\\n\\n/**\\n * Sets the number of milliseconds after which an incomplete request will be\\n * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no\\n * timeout is set.\\n * @param {number} ms Timeout interval in milliseconds; 0 means none.\\n */\\ngoog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {\\n  this.timeoutInterval_ = Math.max(0, ms);\\n};\\n\\n\\n/**\\n * Sets the desired type for the response. At time of writing, this is only\\n * supported in very recent versions of WebKit (10.0.612.1 dev and later).\\n *\\n * If this is used, the response may only be accessed via {@link #getResponse}.\\n *\\n * @param {goog.net.XhrIo.ResponseType} type The desired type for the response.\\n */\\ngoog.net.XhrIo.prototype.setResponseType = function(type) {\\n  this.responseType_ = type;\\n};\\n\\n\\n/**\\n * Gets the desired type for the response.\\n * @return {goog.net.XhrIo.ResponseType} The desired type for the response.\\n */\\ngoog.net.XhrIo.prototype.getResponseType = function() {\\n  return this.responseType_;\\n};\\n\\n\\n/**\\n * Sets whether a \\\"credentialed\\\" request that is aware of cookie and\\n * authentication information should be made. This option is only supported by\\n * browsers that support HTTP Access Control. As of this writing, this option\\n * is not supported in IE.\\n *\\n * @param {boolean} withCredentials Whether this should be a \\\"credentialed\\\"\\n *     request.\\n */\\ngoog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {\\n  this.withCredentials_ = withCredentials;\\n};\\n\\n\\n/**\\n * Gets whether a \\\"credentialed\\\" request is to be sent.\\n * @return {boolean} The desired type for the response.\\n */\\ngoog.net.XhrIo.prototype.getWithCredentials = function() {\\n  return this.withCredentials_;\\n};\\n\\n\\n/**\\n * Sets whether progress events are enabled for this request. Note\\n * that progress events require pre-flight OPTIONS request handling\\n * for CORS requests, and may cause trouble with older browsers. See\\n * progressEventsEnabled_ for details.\\n * @param {boolean} enabled Whether progress events should be enabled.\\n */\\ngoog.net.XhrIo.prototype.setProgressEventsEnabled = function(enabled) {\\n  this.progressEventsEnabled_ = enabled;\\n};\\n\\n\\n/**\\n * Gets whether progress events are enabled.\\n * @return {boolean} Whether progress events are enabled for this request.\\n */\\ngoog.net.XhrIo.prototype.getProgressEventsEnabled = function() {\\n  return this.progressEventsEnabled_;\\n};\\n\\n\\n/**\\n * Instance send that actually uses XMLHttpRequest to make a server call.\\n * @param {string|goog.Uri} url Uri to make request to.\\n * @param {string=} opt_method Send method, default: GET.\\n * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}\\n *     opt_content Body data.\\n * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the\\n *     request.\\n * @suppress {deprecated} Use deprecated goog.structs.forEach to allow different\\n * types of parameters for opt_headers.\\n */\\ngoog.net.XhrIo.prototype.send = function(\\n    url, opt_method, opt_content, opt_headers) {\\n  if (this.xhr_) {\\n    throw Error(\\n        '[goog.net.XhrIo] Object is active with another request=' +\\n        this.lastUri_ + '; newUri=' + url);\\n  }\\n\\n  var method = opt_method ? opt_method.toUpperCase() : 'GET';\\n\\n  this.lastUri_ = url;\\n  this.lastError_ = '';\\n  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\\n  this.lastMethod_ = method;\\n  this.errorDispatched_ = false;\\n  this.active_ = true;\\n\\n  // Use the factory to create the XHR object and options\\n  this.xhr_ = this.createXhr();\\n  this.xhrOptions_ = this.xmlHttpFactory_ ? this.xmlHttpFactory_.getOptions() :\\n                                            goog.net.XmlHttp.getOptions();\\n\\n  // Set up the onreadystatechange callback\\n  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);\\n\\n  // Set up upload/download progress events, if progress events are supported.\\n  if (this.getProgressEventsEnabled() && 'onprogress' in this.xhr_) {\\n    this.xhr_.onprogress =\\n        goog.bind(function(e) { this.onProgressHandler_(e, true); }, this);\\n    if (this.xhr_.upload) {\\n      this.xhr_.upload.onprogress = goog.bind(this.onProgressHandler_, this);\\n    }\\n  }\\n\\n  /**\\n   * Try to open the XMLHttpRequest (always async), if an error occurs here it\\n   * is generally permission denied\\n   */\\n  try {\\n    goog.log.fine(this.logger_, this.formatMsg_('Opening Xhr'));\\n    this.inOpen_ = true;\\n    this.xhr_.open(method, String(url), true);  // Always async!\\n    this.inOpen_ = false;\\n  } catch (err) {\\n    goog.log.fine(\\n        this.logger_, this.formatMsg_('Error opening Xhr: ' + err.message));\\n    this.error_(goog.net.ErrorCode.EXCEPTION, err);\\n    return;\\n  }\\n\\n  // We can't use null since this won't allow requests with form data to have a\\n  // content length specified which will cause some proxies to return a 411\\n  // error.\\n  var content = opt_content || '';\\n\\n  var headers = this.headers.clone();\\n\\n  // Add headers specific to this request\\n  if (opt_headers) {\\n    goog.structs.forEach(\\n        opt_headers, function(value, key) { headers.set(key, value); });\\n  }\\n\\n  // Find whether a content type header is set, ignoring case.\\n  // HTTP header names are case-insensitive.  See:\\n  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\\n  var contentTypeKey =\\n      goog.array.find(headers.getKeys(), goog.net.XhrIo.isContentTypeHeader_);\\n\\n  var contentIsFormData =\\n      (goog.global['FormData'] && (content instanceof goog.global['FormData']));\\n  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) &&\\n      !contentTypeKey && !contentIsFormData) {\\n    // For requests typically with form data, default to the url-encoded form\\n    // content type unless this is a FormData request.  For FormData,\\n    // the browser will automatically add a multipart/form-data content type\\n    // with an appropriate multipart boundary.\\n    headers.set(\\n        goog.net.XhrIo.CONTENT_TYPE_HEADER, goog.net.XhrIo.FORM_CONTENT_TYPE);\\n  }\\n\\n  // Add the headers to the Xhr object\\n  headers.forEach(function(value, key) {\\n    this.xhr_.setRequestHeader(key, value);\\n  }, this);\\n\\n  if (this.responseType_) {\\n    this.xhr_.responseType = this.responseType_;\\n  }\\n  // Set xhr_.withCredentials only when the value is different, or else in\\n  // synchronous XMLHtppRequest.open Firefox will throw an exception.\\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=736340\\n  if ('withCredentials' in this.xhr_ &&\\n      this.xhr_.withCredentials !== this.withCredentials_) {\\n    this.xhr_.withCredentials = this.withCredentials_;\\n  }\\n\\n  /**\\n   * Try to send the request, or other wise report an error (404 not found).\\n   */\\n  try {\\n    this.cleanUpTimeoutTimer_();  // Paranoid, should never be running.\\n    if (this.timeoutInterval_ > 0) {\\n      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);\\n      goog.log.fine(\\n          this.logger_, this.formatMsg_(\\n                            'Will abort after ' + this.timeoutInterval_ +\\n                            'ms if incomplete, xhr2 ' + this.useXhr2Timeout_));\\n      if (this.useXhr2Timeout_) {\\n        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;\\n        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] =\\n            goog.bind(this.timeout_, this);\\n      } else {\\n        this.timeoutId_ =\\n            goog.Timer.callOnce(this.timeout_, this.timeoutInterval_, this);\\n      }\\n    }\\n    goog.log.fine(this.logger_, this.formatMsg_('Sending request'));\\n    this.inSend_ = true;\\n    this.xhr_.send(content);\\n    this.inSend_ = false;\\n\\n  } catch (err) {\\n    goog.log.fine(this.logger_, this.formatMsg_('Send error: ' + err.message));\\n    this.error_(goog.net.ErrorCode.EXCEPTION, err);\\n  }\\n};\\n\\n\\n/**\\n * Determines if the argument is an XMLHttpRequest that supports the level 2\\n * timeout value and event.\\n *\\n * Currently, FF 21.0 OS X has the fields but won't actually call the timeout\\n * handler.  Perhaps the confusion in the bug referenced below hasn't\\n * entirely been resolved.\\n *\\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=525816\\n *\\n * @param {!goog.net.XhrLike.OrNative} xhr The request.\\n * @return {boolean} True if the request supports level 2 timeout.\\n * @private\\n */\\ngoog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {\\n  return goog.userAgent.IE && goog.userAgent.isVersionOrHigher(9) &&\\n      goog.isNumber(xhr[goog.net.XhrIo.XHR2_TIMEOUT_]) &&\\n      goog.isDef(xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_]);\\n};\\n\\n\\n/**\\n * @param {string} header An HTTP header key.\\n * @return {boolean} Whether the key is a content type header (ignoring\\n *     case.\\n * @private\\n */\\ngoog.net.XhrIo.isContentTypeHeader_ = function(header) {\\n  return goog.string.caseInsensitiveEquals(\\n      goog.net.XhrIo.CONTENT_TYPE_HEADER, header);\\n};\\n\\n\\n/**\\n * Creates a new XHR object.\\n * @return {!goog.net.XhrLike.OrNative} The newly created XHR object.\\n * @protected\\n */\\ngoog.net.XhrIo.prototype.createXhr = function() {\\n  return this.xmlHttpFactory_ ? this.xmlHttpFactory_.createInstance() :\\n                                goog.net.XmlHttp();\\n};\\n\\n\\n/**\\n * The request didn't complete after {@link goog.net.XhrIo#timeoutInterval_}\\n * milliseconds; raises a {@link goog.net.EventType.TIMEOUT} event and aborts\\n * the request.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.timeout_ = function() {\\n  if (typeof goog == 'undefined') {\\n    // If goog is undefined then the callback has occurred as the application\\n    // is unloading and will error.  Thus we let it silently fail.\\n  } else if (this.xhr_) {\\n    this.lastError_ =\\n        'Timed out after ' + this.timeoutInterval_ + 'ms, aborting';\\n    this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;\\n    goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));\\n    this.dispatchEvent(goog.net.EventType.TIMEOUT);\\n    this.abort(goog.net.ErrorCode.TIMEOUT);\\n  }\\n};\\n\\n\\n/**\\n * Something errorred, so inactivate, fire error callback and clean up\\n * @param {goog.net.ErrorCode} errorCode The error code.\\n * @param {Error} err The error object.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.error_ = function(errorCode, err) {\\n  this.active_ = false;\\n  if (this.xhr_) {\\n    this.inAbort_ = true;\\n    this.xhr_.abort();  // Ensures XHR isn't hung (FF)\\n    this.inAbort_ = false;\\n  }\\n  this.lastError_ = err;\\n  this.lastErrorCode_ = errorCode;\\n  this.dispatchErrors_();\\n  this.cleanUpXhr_();\\n};\\n\\n\\n/**\\n * Dispatches COMPLETE and ERROR in case of an error. This ensures that we do\\n * not dispatch multiple error events.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.dispatchErrors_ = function() {\\n  if (!this.errorDispatched_) {\\n    this.errorDispatched_ = true;\\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\\n    this.dispatchEvent(goog.net.EventType.ERROR);\\n  }\\n};\\n\\n\\n/**\\n * Abort the current XMLHttpRequest\\n * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -\\n *     defaults to ABORT.\\n */\\ngoog.net.XhrIo.prototype.abort = function(opt_failureCode) {\\n  if (this.xhr_ && this.active_) {\\n    goog.log.fine(this.logger_, this.formatMsg_('Aborting'));\\n    this.active_ = false;\\n    this.inAbort_ = true;\\n    this.xhr_.abort();\\n    this.inAbort_ = false;\\n    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;\\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\\n    this.dispatchEvent(goog.net.EventType.ABORT);\\n    this.cleanUpXhr_();\\n  }\\n};\\n\\n\\n/**\\n * Nullifies all callbacks to reduce risks of leaks.\\n * @override\\n * @protected\\n */\\ngoog.net.XhrIo.prototype.disposeInternal = function() {\\n  if (this.xhr_) {\\n    // We explicitly do not call xhr_.abort() unless active_ is still true.\\n    // This is to avoid unnecessarily aborting a successful request when\\n    // dispose() is called in a callback triggered by a complete response, but\\n    // in which browser cleanup has not yet finished.\\n    // (See http://b/issue?id=1684217.)\\n    if (this.active_) {\\n      this.active_ = false;\\n      this.inAbort_ = true;\\n      this.xhr_.abort();\\n      this.inAbort_ = false;\\n    }\\n    this.cleanUpXhr_(true);\\n  }\\n\\n  goog.net.XhrIo.base(this, 'disposeInternal');\\n};\\n\\n\\n/**\\n * Internal handler for the XHR object's readystatechange event.  This method\\n * checks the status and the readystate and fires the correct callbacks.\\n * If the request has ended, the handlers are cleaned up and the XHR object is\\n * nullified.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.onReadyStateChange_ = function() {\\n  if (this.isDisposed()) {\\n    // This method is the target of an untracked goog.Timer.callOnce().\\n    return;\\n  }\\n  if (!this.inOpen_ && !this.inSend_ && !this.inAbort_) {\\n    // Were not being called from within a call to this.xhr_.send\\n    // this.xhr_.abort, or this.xhr_.open, so this is an entry point\\n    this.onReadyStateChangeEntryPoint_();\\n  } else {\\n    this.onReadyStateChangeHelper_();\\n  }\\n};\\n\\n\\n/**\\n * Used to protect the onreadystatechange handler entry point.  Necessary\\n * as {#onReadyStateChange_} maybe called from within send or abort, this\\n * method is only called when {#onReadyStateChange_} is called as an\\n * entry point.\\n * {@see #protectEntryPoints}\\n * @private\\n */\\ngoog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {\\n  this.onReadyStateChangeHelper_();\\n};\\n\\n\\n/**\\n * Helper for {@link #onReadyStateChange_}.  This is used so that\\n * entry point calls to {@link #onReadyStateChange_} can be routed through\\n * {@link #onReadyStateChangeEntryPoint_}.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {\\n  if (!this.active_) {\\n    // can get called inside abort call\\n    return;\\n  }\\n\\n  if (typeof goog == 'undefined') {\\n    // NOTE(user): If goog is undefined then the callback has occurred as the\\n    // application is unloading and will error.  Thus we let it silently fail.\\n\\n  } else if (\\n      this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] &&\\n      this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE &&\\n      this.getStatus() == 2) {\\n    // NOTE(user): In IE if send() errors on a *local* request the readystate\\n    // is still changed to COMPLETE.  We need to ignore it and allow the\\n    // try/catch around send() to pick up the error.\\n    goog.log.fine(\\n        this.logger_,\\n        this.formatMsg_('Local request error detected and ignored'));\\n\\n  } else {\\n    // In IE when the response has been cached we sometimes get the callback\\n    // from inside the send call and this usually breaks code that assumes that\\n    // XhrIo is asynchronous.  If that is the case we delay the callback\\n    // using a timer.\\n    if (this.inSend_ &&\\n        this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {\\n      goog.Timer.callOnce(this.onReadyStateChange_, 0, this);\\n      return;\\n    }\\n\\n    this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);\\n\\n    // readyState indicates the transfer has finished\\n    if (this.isComplete()) {\\n      goog.log.fine(this.logger_, this.formatMsg_('Request complete'));\\n\\n      this.active_ = false;\\n\\n      try {\\n        // Call the specific callbacks for success or failure. Only call the\\n        // success if the status is 200 (HTTP_OK) or 304 (HTTP_CACHED)\\n        if (this.isSuccess()) {\\n          this.dispatchEvent(goog.net.EventType.COMPLETE);\\n          this.dispatchEvent(goog.net.EventType.SUCCESS);\\n        } else {\\n          this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;\\n          this.lastError_ =\\n              this.getStatusText() + ' [' + this.getStatus() + ']';\\n          this.dispatchErrors_();\\n        }\\n      } finally {\\n        this.cleanUpXhr_();\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Internal handler for the XHR object's onprogress event. Fires both a generic\\n * PROGRESS event and either a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event to\\n * allow specific binding for each XHR progress event.\\n * @param {!ProgressEvent} e XHR progress event.\\n * @param {boolean=} opt_isDownload Whether the current progress event is from a\\n *     download. Used to determine whether DOWNLOAD_PROGRESS or UPLOAD_PROGRESS\\n *     event should be dispatched.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.onProgressHandler_ = function(e, opt_isDownload) {\\n  goog.asserts.assert(\\n      e.type === goog.net.EventType.PROGRESS,\\n      'goog.net.EventType.PROGRESS is of the same type as raw XHR progress.');\\n  this.dispatchEvent(\\n      goog.net.XhrIo.buildProgressEvent_(e, goog.net.EventType.PROGRESS));\\n  this.dispatchEvent(\\n      goog.net.XhrIo.buildProgressEvent_(\\n          e, opt_isDownload ? goog.net.EventType.DOWNLOAD_PROGRESS :\\n                              goog.net.EventType.UPLOAD_PROGRESS));\\n};\\n\\n\\n/**\\n * Creates a representation of the native ProgressEvent. IE doesn't support\\n * constructing ProgressEvent via \\\"new\\\", and the alternatives (e.g.,\\n * ProgressEvent.initProgressEvent) are non-standard or deprecated.\\n * @param {!ProgressEvent} e XHR progress event.\\n * @param {!goog.net.EventType} eventType The type of the event.\\n * @return {!ProgressEvent} The progress event.\\n * @private\\n */\\ngoog.net.XhrIo.buildProgressEvent_ = function(e, eventType) {\\n  return /** @type {!ProgressEvent} */ ({\\n    type: eventType,\\n    lengthComputable: e.lengthComputable,\\n    loaded: e.loaded,\\n    total: e.total\\n  });\\n};\\n\\n\\n/**\\n * Remove the listener to protect against leaks, and nullify the XMLHttpRequest\\n * object.\\n * @param {boolean=} opt_fromDispose If this is from the dispose (don't want to\\n *     fire any events).\\n * @private\\n */\\ngoog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {\\n  if (this.xhr_) {\\n    // Cancel any pending timeout event handler.\\n    this.cleanUpTimeoutTimer_();\\n\\n    // Save reference so we can mark it as closed after the READY event.  The\\n    // READY event may trigger another request, thus we must nullify this.xhr_\\n    var xhr = this.xhr_;\\n    var clearedOnReadyStateChange =\\n        this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ?\\n        goog.nullFunction :\\n        null;\\n    this.xhr_ = null;\\n    this.xhrOptions_ = null;\\n\\n    if (!opt_fromDispose) {\\n      this.dispatchEvent(goog.net.EventType.READY);\\n    }\\n\\n    try {\\n      // NOTE(user): Not nullifying in FireFox can still leak if the callbacks\\n      // are defined in the same scope as the instance of XhrIo. But, IE doesn't\\n      // allow you to set the onreadystatechange to NULL so nullFunction is\\n      // used.\\n      xhr.onreadystatechange = clearedOnReadyStateChange;\\n    } catch (e) {\\n      // This seems to occur with a Gears HTTP request. Delayed the setting of\\n      // this onreadystatechange until after READY is sent out and catching the\\n      // error to see if we can track down the problem.\\n      goog.log.error(\\n          this.logger_,\\n          'Problem encountered resetting onreadystatechange: ' + e.message);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Make sure the timeout timer isn't running.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {\\n  if (this.xhr_ && this.useXhr2Timeout_) {\\n    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;\\n  }\\n  if (goog.isNumber(this.timeoutId_)) {\\n    goog.Timer.clear(this.timeoutId_);\\n    this.timeoutId_ = null;\\n  }\\n};\\n\\n\\n/**\\n * @return {boolean} Whether there is an active request.\\n */\\ngoog.net.XhrIo.prototype.isActive = function() {\\n  return !!this.xhr_;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether the request has completed.\\n */\\ngoog.net.XhrIo.prototype.isComplete = function() {\\n  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether the request completed with a success.\\n */\\ngoog.net.XhrIo.prototype.isSuccess = function() {\\n  var status = this.getStatus();\\n  // A zero status code is considered successful for local files.\\n  return goog.net.HttpStatus.isSuccess(status) ||\\n      status === 0 && !this.isLastUriEffectiveSchemeHttp_();\\n};\\n\\n\\n/**\\n * @return {boolean} whether the effective scheme of the last URI that was\\n *     fetched was 'http' or 'https'.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {\\n  var scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));\\n  return goog.net.XhrIo.HTTP_SCHEME_PATTERN.test(scheme);\\n};\\n\\n\\n/**\\n * Get the readystate from the Xhr object\\n * Will only return correct result when called from the context of a callback\\n * @return {goog.net.XmlHttp.ReadyState} goog.net.XmlHttp.ReadyState.*.\\n */\\ngoog.net.XhrIo.prototype.getReadyState = function() {\\n  return this.xhr_ ?\\n      /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) :\\n                                                 goog.net.XmlHttp.ReadyState\\n                                                     .UNINITIALIZED;\\n};\\n\\n\\n/**\\n * Get the status from the Xhr object\\n * Will only return correct result when called from the context of a callback\\n * @return {number} Http status.\\n */\\ngoog.net.XhrIo.prototype.getStatus = function() {\\n  /**\\n   * IE doesn't like you checking status until the readystate is greater than 2\\n   * (i.e. it is receiving or complete).  The try/catch is used for when the\\n   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.\\n   */\\n  try {\\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?\\n        this.xhr_.status :\\n        -1;\\n  } catch (e) {\\n    return -1;\\n  }\\n};\\n\\n\\n/**\\n * Get the status text from the Xhr object\\n * Will only return correct result when called from the context of a callback\\n * @return {string} Status text.\\n */\\ngoog.net.XhrIo.prototype.getStatusText = function() {\\n  /**\\n   * IE doesn't like you checking status until the readystate is greater than 2\\n   * (i.e. it is receiving or complete).  The try/catch is used for when the\\n   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.\\n   */\\n  try {\\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?\\n        this.xhr_.statusText :\\n        '';\\n  } catch (e) {\\n    goog.log.fine(this.logger_, 'Can not get status: ' + e.message);\\n    return '';\\n  }\\n};\\n\\n\\n/**\\n * Get the last Uri that was requested\\n * @return {string} Last Uri.\\n */\\ngoog.net.XhrIo.prototype.getLastUri = function() {\\n  return String(this.lastUri_);\\n};\\n\\n\\n/**\\n * Get the response text from the Xhr object\\n * Will only return correct result when called from the context of a callback.\\n * @return {string} Result from the server, or '' if no result available.\\n */\\ngoog.net.XhrIo.prototype.getResponseText = function() {\\n  try {\\n    return this.xhr_ ? this.xhr_.responseText : '';\\n  } catch (e) {\\n    // http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute\\n    // states that responseText should return '' (and responseXML null)\\n    // when the state is not LOADING or DONE. Instead, IE can\\n    // throw unexpected exceptions, for example when a request is aborted\\n    // or no data is available yet.\\n    goog.log.fine(this.logger_, 'Can not get responseText: ' + e.message);\\n    return '';\\n  }\\n};\\n\\n\\n/**\\n * Get the response body from the Xhr object. This property is only available\\n * in IE since version 7 according to MSDN:\\n * http://msdn.microsoft.com/en-us/library/ie/ms534368(v=vs.85).aspx\\n * Will only return correct result when called from the context of a callback.\\n *\\n * One option is to construct a VBArray from the returned object and convert\\n * it to a JavaScript array using the toArray method:\\n * {@code (new window['VBArray'](xhrIo.getResponseBody())).toArray()}\\n * This will result in an array of numbers in the range of [0..255]\\n *\\n * Another option is to use the VBScript CStr method to convert it into a\\n * string as outlined in http://stackoverflow.com/questions/1919972\\n *\\n * @return {Object} Binary result from the server or null if not available.\\n */\\ngoog.net.XhrIo.prototype.getResponseBody = function() {\\n\\n  try {\\n    if (this.xhr_ && 'responseBody' in this.xhr_) {\\n      return this.xhr_['responseBody'];\\n    }\\n  } catch (e) {\\n    // IE can throw unexpected exceptions, for example when a request is aborted\\n    // or no data is yet available.\\n    goog.log.fine(this.logger_, 'Can not get responseBody: ' + e.message);\\n  }\\n  return null;\\n};\\n\\n\\n/**\\n * Get the response XML from the Xhr object\\n * Will only return correct result when called from the context of a callback.\\n * @return {Document} The DOM Document representing the XML file, or null\\n * if no result available.\\n */\\ngoog.net.XhrIo.prototype.getResponseXml = function() {\\n\\n  try {\\n    return this.xhr_ ? this.xhr_.responseXML : null;\\n  } catch (e) {\\n    goog.log.fine(this.logger_, 'Can not get responseXML: ' + e.message);\\n    return null;\\n  }\\n};\\n\\n\\n/**\\n * Get the response and evaluates it as JSON from the Xhr object\\n * Will only return correct result when called from the context of a callback\\n * @param {string=} opt_xssiPrefix Optional XSSI prefix string to use for\\n *     stripping of the response before parsing. This needs to be set only if\\n *     your backend server prepends the same prefix string to the JSON response.\\n * @throws Error if the response text is invalid JSON.\\n * @return {Object|undefined} JavaScript object.\\n */\\ngoog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {\\n  if (!this.xhr_) {\\n    return undefined;\\n  }\\n\\n  var responseText = this.xhr_.responseText;\\n  if (opt_xssiPrefix && responseText.indexOf(opt_xssiPrefix) == 0) {\\n    responseText = responseText.substring(opt_xssiPrefix.length);\\n  }\\n\\n  return goog.json.hybrid.parse(responseText);\\n};\\n\\n\\n/**\\n * Get the response as the type specificed by {@link #setResponseType}. At time\\n * of writing, this is only directly supported in very recent versions of WebKit\\n * (10.0.612.1 dev and later). If the field is not supported directly, we will\\n * try to emulate it.\\n *\\n * Emulating the response means following the rules laid out at\\n * http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute\\n *\\n * On browsers with no support for this (Chrome < 10, Firefox < 4, etc), only\\n * response types of DEFAULT or TEXT may be used, and the response returned will\\n * be the text response.\\n *\\n * On browsers with Mozilla's draft support for array buffers (Firefox 4, 5),\\n * only response types of DEFAULT, TEXT, and ARRAY_BUFFER may be used, and the\\n * response returned will be either the text response or the Mozilla\\n * implementation of the array buffer response.\\n *\\n * On browsers will full support, any valid response type supported by the\\n * browser may be used, and the response provided by the browser will be\\n * returned.\\n *\\n * @return {*} The response.\\n */\\ngoog.net.XhrIo.prototype.getResponse = function() {\\n\\n  try {\\n    if (!this.xhr_) {\\n      return null;\\n    }\\n    if ('response' in this.xhr_) {\\n      return this.xhr_.response;\\n    }\\n    switch (this.responseType_) {\\n      case goog.net.XhrIo.ResponseType.DEFAULT:\\n      case goog.net.XhrIo.ResponseType.TEXT:\\n        return this.xhr_.responseText;\\n      // DOCUMENT and BLOB don't need to be handled here because they are\\n      // introduced in the same spec that adds the .response field, and would\\n      // have been caught above.\\n      // ARRAY_BUFFER needs an implementation for Firefox 4, where it was\\n      // implemented using a draft spec rather than the final spec.\\n      case goog.net.XhrIo.ResponseType.ARRAY_BUFFER:\\n        if ('mozResponseArrayBuffer' in this.xhr_) {\\n          return this.xhr_.mozResponseArrayBuffer;\\n        }\\n    }\\n    // Fell through to a response type that is not supported on this browser.\\n    goog.log.error(\\n        this.logger_, 'Response type ' + this.responseType_ + ' is not ' +\\n            'supported on this browser');\\n    return null;\\n  } catch (e) {\\n    goog.log.fine(this.logger_, 'Can not get response: ' + e.message);\\n    return null;\\n  }\\n};\\n\\n\\n/**\\n * Get the value of the response-header with the given name from the Xhr object\\n * Will only return correct result when called from the context of a callback\\n * and the request has completed\\n * @param {string} key The name of the response-header to retrieve.\\n * @return {string|undefined} The value of the response-header named key.\\n */\\ngoog.net.XhrIo.prototype.getResponseHeader = function(key) {\\n  if (!this.xhr_ || !this.isComplete()) {\\n    return undefined;\\n  }\\n\\n  var value = this.xhr_.getResponseHeader(key);\\n  return goog.isNull(value) ? undefined : value;\\n};\\n\\n\\n/**\\n * Gets the text of all the headers in the response.\\n * Will only return correct result when called from the context of a callback\\n * and the request has completed.\\n * @return {string} The value of the response headers or empty string.\\n */\\ngoog.net.XhrIo.prototype.getAllResponseHeaders = function() {\\n  return this.xhr_ && this.isComplete() ? this.xhr_.getAllResponseHeaders() :\\n                                          '';\\n};\\n\\n\\n/**\\n * Returns all response headers as a key-value map.\\n * Multiple values for the same header key can be combined into one,\\n * separated by a comma and a space.\\n * Note that the native getResponseHeader method for retrieving a single header\\n * does a case insensitive match on the header name. This method does not\\n * include any case normalization logic, it will just return a key-value\\n * representation of the headers.\\n * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method\\n * @return {!Object<string, string>} An object with the header keys as keys\\n *     and header values as values.\\n */\\ngoog.net.XhrIo.prototype.getResponseHeaders = function() {\\n  var headersObject = {};\\n  var headersArray = this.getAllResponseHeaders().split('\\\\r\\\\n');\\n  for (var i = 0; i < headersArray.length; i++) {\\n    if (goog.string.isEmptyOrWhitespace(headersArray[i])) {\\n      continue;\\n    }\\n    var keyValue = goog.string.splitLimit(headersArray[i], ': ', 2);\\n    if (headersObject[keyValue[0]]) {\\n      headersObject[keyValue[0]] += ', ' + keyValue[1];\\n    } else {\\n      headersObject[keyValue[0]] = keyValue[1];\\n    }\\n  }\\n  return headersObject;\\n};\\n\\n\\n/**\\n * Get the value of the response-header with the given name from the Xhr object.\\n * As opposed to {@link #getResponseHeader}, this method does not require that\\n * the request has completed.\\n * @param {string} key The name of the response-header to retrieve.\\n * @return {?string} The value of the response-header, or null if it is\\n *     unavailable.\\n */\\ngoog.net.XhrIo.prototype.getStreamingResponseHeader = function(key) {\\n  return this.xhr_ ? this.xhr_.getResponseHeader(key) : null;\\n};\\n\\n\\n/**\\n * Gets the text of all the headers in the response. As opposed to\\n * {@link #getAllResponseHeaders}, this method does not require that the request\\n * has completed.\\n * @return {string} The value of the response headers or empty string.\\n */\\ngoog.net.XhrIo.prototype.getAllStreamingResponseHeaders = function() {\\n  return this.xhr_ ? this.xhr_.getAllResponseHeaders() : '';\\n};\\n\\n\\n/**\\n * Get the last error message\\n * @return {goog.net.ErrorCode} Last error code.\\n */\\ngoog.net.XhrIo.prototype.getLastErrorCode = function() {\\n  return this.lastErrorCode_;\\n};\\n\\n\\n/**\\n * Get the last error message\\n * @return {string} Last error message.\\n */\\ngoog.net.XhrIo.prototype.getLastError = function() {\\n  return goog.isString(this.lastError_) ? this.lastError_ :\\n                                          String(this.lastError_);\\n};\\n\\n\\n/**\\n * Adds the last method, status and URI to the message.  This is used to add\\n * this information to the logging calls.\\n * @param {string} msg The message text that we want to add the extra text to.\\n * @return {string} The message with the extra text appended.\\n * @private\\n */\\ngoog.net.XhrIo.prototype.formatMsg_ = function(msg) {\\n  return msg + ' [' + this.lastMethod_ + ' ' + this.lastUri_ + ' ' +\\n      this.getStatus() + ']';\\n};\\n\\n\\n// Register the xhr handler as an entry point, so that\\n// it can be monitored for exception handling, etc.\\ngoog.debug.entryPointRegistry.register(\\n    /**\\n     * @param {function(!Function): !Function} transformer The transforming\\n     *     function.\\n     */\\n    function(transformer) {\\n      goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =\\n          transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\\n    });\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"forwardDeclare\",\"net\",\"XhrIo\",\"goog.net.XhrIo\",\"opt_xmlHttpFactory\",\"base\",\"headers\",\"structs\",\"Map\",\"xmlHttpFactory_\",\"active_\",\"xhr_\",\"xhrOptions_\",\"lastUri_\",\"lastMethod_\",\"lastErrorCode_\",\"ErrorCode\",\"NO_ERROR\",\"lastError_\",\"errorDispatched_\",\"inSend_\",\"inOpen_\",\"inAbort_\",\"timeoutInterval_\",\"timeoutId_\",\"responseType_\",\"ResponseType\",\"DEFAULT\",\"withCredentials_\",\"progressEventsEnabled_\",\"useXhr2Timeout_\",\"inherits\",\"events\",\"EventTarget\",\"TEXT\",\"DOCUMENT\",\"BLOB\",\"ARRAY_BUFFER\",\"prototype\",\"logger_\",\"log\",\"getLogger\",\"CONTENT_TYPE_HEADER\",\"CONTENT_TRANSFER_ENCODING\",\"HTTP_SCHEME_PATTERN\",\"METHODS_WITH_FORM_DATA\",\"FORM_CONTENT_TYPE\",\"XHR2_TIMEOUT_\",\"XHR2_ON_TIMEOUT_\",\"sendInstances_\",\"send\",\"goog.net.XhrIo.send\",\"url\",\"opt_callback\",\"opt_method\",\"opt_content\",\"opt_headers\",\"opt_timeoutInterval\",\"opt_withCredentials\",\"x\",\"push\",\"listen\",\"EventType\",\"COMPLETE\",\"listenOnce\",\"READY\",\"cleanupSend_\",\"setTimeoutInterval\",\"setWithCredentials\",\"cleanup\",\"goog.net.XhrIo.cleanup\",\"instances\",\"length\",\"pop\",\"dispose\",\"protectEntryPoints\",\"goog.net.XhrIo.protectEntryPoints\",\"errorHandler\",\"onReadyStateChangeEntryPoint_\",\"protectEntryPoint\",\"goog.net.XhrIo.prototype.cleanupSend_\",\"array\",\"remove\",\"getTimeoutInterval\",\"goog.net.XhrIo.prototype.getTimeoutInterval\",\"goog.net.XhrIo.prototype.setTimeoutInterval\",\"ms\",\"Math\",\"max\",\"setResponseType\",\"goog.net.XhrIo.prototype.setResponseType\",\"type\",\"getResponseType\",\"goog.net.XhrIo.prototype.getResponseType\",\"goog.net.XhrIo.prototype.setWithCredentials\",\"withCredentials\",\"getWithCredentials\",\"goog.net.XhrIo.prototype.getWithCredentials\",\"setProgressEventsEnabled\",\"goog.net.XhrIo.prototype.setProgressEventsEnabled\",\"enabled\",\"getProgressEventsEnabled\",\"goog.net.XhrIo.prototype.getProgressEventsEnabled\",\"goog.net.XhrIo.prototype.send\",\"Error\",\"method\",\"toUpperCase\",\"createXhr\",\"getOptions\",\"XmlHttp\",\"onreadystatechange\",\"bind\",\"onReadyStateChange_\",\"onprogress\",\"e\",\"onProgressHandler_\",\"upload\",\"fine\",\"formatMsg_\",\"open\",\"String\",\"err\",\"message\",\"error_\",\"EXCEPTION\",\"content\",\"clone\",\"forEach\",\"value\",\"key\",\"set\",\"contentTypeKey\",\"find\",\"getKeys\",\"isContentTypeHeader_\",\"contentIsFormData\",\"global\",\"contains\",\"setRequestHeader\",\"responseType\",\"cleanUpTimeoutTimer_\",\"shouldUseXhr2Timeout_\",\"timeout_\",\"Timer\",\"callOnce\",\"goog.net.XhrIo.shouldUseXhr2Timeout_\",\"xhr\",\"userAgent\",\"IE\",\"isVersionOrHigher\",\"isNumber\",\"isDef\",\"goog.net.XhrIo.isContentTypeHeader_\",\"header\",\"string\",\"caseInsensitiveEquals\",\"goog.net.XhrIo.prototype.createXhr\",\"createInstance\",\"goog.net.XhrIo.prototype.timeout_\",\"TIMEOUT\",\"dispatchEvent\",\"abort\",\"goog.net.XhrIo.prototype.error_\",\"errorCode\",\"dispatchErrors_\",\"cleanUpXhr_\",\"goog.net.XhrIo.prototype.dispatchErrors_\",\"ERROR\",\"goog.net.XhrIo.prototype.abort\",\"opt_failureCode\",\"ABORT\",\"disposeInternal\",\"goog.net.XhrIo.prototype.disposeInternal\",\"goog.net.XhrIo.prototype.onReadyStateChange_\",\"isDisposed\",\"onReadyStateChangeHelper_\",\"goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_\",\"goog.net.XhrIo.prototype.onReadyStateChangeHelper_\",\"OptionType\",\"LOCAL_REQUEST_ERROR\",\"getReadyState\",\"ReadyState\",\"getStatus\",\"READY_STATE_CHANGE\",\"isComplete\",\"isSuccess\",\"SUCCESS\",\"HTTP_ERROR\",\"getStatusText\",\"goog.net.XhrIo.prototype.onProgressHandler_\",\"opt_isDownload\",\"asserts\",\"assert\",\"PROGRESS\",\"buildProgressEvent_\",\"DOWNLOAD_PROGRESS\",\"UPLOAD_PROGRESS\",\"goog.net.XhrIo.buildProgressEvent_\",\"eventType\",\"lengthComputable\",\"loaded\",\"total\",\"goog.net.XhrIo.prototype.cleanUpXhr_\",\"opt_fromDispose\",\"clearedOnReadyStateChange\",\"USE_NULL_FUNCTION\",\"nullFunction\",\"error\",\"goog.net.XhrIo.prototype.cleanUpTimeoutTimer_\",\"clear\",\"isActive\",\"goog.net.XhrIo.prototype.isActive\",\"goog.net.XhrIo.prototype.isComplete\",\"goog.net.XhrIo.prototype.isSuccess\",\"status\",\"HttpStatus\",\"isLastUriEffectiveSchemeHttp_\",\"goog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_\",\"scheme\",\"uri\",\"utils\",\"getEffectiveScheme\",\"test\",\"goog.net.XhrIo.prototype.getReadyState\",\"readyState\",\"UNINITIALIZED\",\"goog.net.XhrIo.prototype.getStatus\",\"LOADED\",\"goog.net.XhrIo.prototype.getStatusText\",\"statusText\",\"getLastUri\",\"goog.net.XhrIo.prototype.getLastUri\",\"getResponseText\",\"goog.net.XhrIo.prototype.getResponseText\",\"responseText\",\"getResponseBody\",\"goog.net.XhrIo.prototype.getResponseBody\",\"getResponseXml\",\"goog.net.XhrIo.prototype.getResponseXml\",\"responseXML\",\"getResponseJson\",\"goog.net.XhrIo.prototype.getResponseJson\",\"opt_xssiPrefix\",\"undefined\",\"indexOf\",\"substring\",\"json\",\"hybrid\",\"parse\",\"getResponse\",\"goog.net.XhrIo.prototype.getResponse\",\"response\",\"mozResponseArrayBuffer\",\"getResponseHeader\",\"goog.net.XhrIo.prototype.getResponseHeader\",\"isNull\",\"getAllResponseHeaders\",\"goog.net.XhrIo.prototype.getAllResponseHeaders\",\"getResponseHeaders\",\"goog.net.XhrIo.prototype.getResponseHeaders\",\"headersObject\",\"headersArray\",\"split\",\"i\",\"isEmptyOrWhitespace\",\"keyValue\",\"splitLimit\",\"getStreamingResponseHeader\",\"goog.net.XhrIo.prototype.getStreamingResponseHeader\",\"getAllStreamingResponseHeaders\",\"goog.net.XhrIo.prototype.getAllStreamingResponseHeaders\",\"getLastErrorCode\",\"goog.net.XhrIo.prototype.getLastErrorCode\",\"getLastError\",\"goog.net.XhrIo.prototype.getLastError\",\"isString\",\"goog.net.XhrIo.prototype.formatMsg_\",\"msg\",\"debug\",\"entryPointRegistry\",\"register\",\"transformer\"]\n}\n"]