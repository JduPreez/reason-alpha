["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/string/string.js"],"~:js","goog.provide(\"goog.string\");\ngoog.provide(\"goog.string.Unicode\");\n/** @define {boolean} */ goog.define(\"goog.string.DETECT_DOUBLE_ESCAPING\", false);\n/** @define {boolean} */ goog.define(\"goog.string.FORCE_NON_DOM_HTML_UNESCAPING\", false);\n/** @enum {string} */ goog.string.Unicode = {NBSP:\" \"};\n/**\n * @param {string} str\n * @param {string} prefix\n * @return {boolean}\n */\ngoog.string.startsWith = function(str, prefix) {\n  return str.lastIndexOf(prefix, 0) == 0;\n};\n/**\n * @param {string} str\n * @param {string} suffix\n * @return {boolean}\n */\ngoog.string.endsWith = function(str, suffix) {\n  var l = str.length - suffix.length;\n  return l >= 0 && str.indexOf(suffix, l) == l;\n};\n/**\n * @param {string} str\n * @param {string} prefix\n * @return {boolean}\n */\ngoog.string.caseInsensitiveStartsWith = function(str, prefix) {\n  return goog.string.caseInsensitiveCompare(prefix, str.substr(0, prefix.length)) == 0;\n};\n/**\n * @param {string} str\n * @param {string} suffix\n * @return {boolean}\n */\ngoog.string.caseInsensitiveEndsWith = function(str, suffix) {\n  return goog.string.caseInsensitiveCompare(suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;\n};\n/**\n * @param {string} str1\n * @param {string} str2\n * @return {boolean}\n */\ngoog.string.caseInsensitiveEquals = function(str1, str2) {\n  return str1.toLowerCase() == str2.toLowerCase();\n};\n/**\n * @param {string} str\n * @param {...*} var_args\n * @return {string}\n */\ngoog.string.subs = function(str, var_args) {\n  var splitParts = str.split(\"%s\");\n  var returnString = \"\";\n  var subsArguments = Array.prototype.slice.call(arguments, 1);\n  while (subsArguments.length && splitParts.length > 1) {\n    returnString += splitParts.shift() + subsArguments.shift();\n  }\n  return returnString + splitParts.join(\"%s\");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.collapseWhitespace = function(str) {\n  return str.replace(/[\\s\\xa0]+/g, \" \").replace(/^\\s+|\\s+$/g, \"\");\n};\n/**\n * @param {string} str\n * @return {boolean}\n */\ngoog.string.isEmptyOrWhitespace = function(str) {\n  return /^[\\s\\xa0]*$/.test(str);\n};\n/**\n * @param {string} str\n * @return {boolean}\n */\ngoog.string.isEmptyString = function(str) {\n  return str.length == 0;\n};\n/**\n * @param {string} str\n * @return {boolean}\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\n */\ngoog.string.isEmpty = goog.string.isEmptyOrWhitespace;\n/**\n * @param {*} str\n * @return {boolean}\n * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str)) instead.\n */\ngoog.string.isEmptyOrWhitespaceSafe = function(str) {\n  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));\n};\n/**\n * @param {*} str\n * @return {boolean}\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\n */\ngoog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;\n/**\n * @param {string} str\n * @return {boolean}\n */\ngoog.string.isBreakingWhitespace = function(str) {\n  return !/[^\\t\\n\\r ]/.test(str);\n};\n/**\n * @param {string} str\n * @return {boolean}\n */\ngoog.string.isAlpha = function(str) {\n  return !/[^a-zA-Z]/.test(str);\n};\n/**\n * @param {*} str\n * @return {boolean}\n */\ngoog.string.isNumeric = function(str) {\n  return !/[^0-9]/.test(str);\n};\n/**\n * @param {string} str\n * @return {boolean}\n */\ngoog.string.isAlphaNumeric = function(str) {\n  return !/[^a-zA-Z0-9]/.test(str);\n};\n/**\n * @param {string} ch\n * @return {boolean}\n */\ngoog.string.isSpace = function(ch) {\n  return ch == \" \";\n};\n/**\n * @param {string} ch\n * @return {boolean}\n */\ngoog.string.isUnicodeChar = function(ch) {\n  return ch.length == 1 && ch >= \" \" && ch <= \"~\" || ch >= \"\" && ch <= \"�\";\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.stripNewlines = function(str) {\n  return str.replace(/(\\r\\n|\\r|\\n)+/g, \" \");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.canonicalizeNewlines = function(str) {\n  return str.replace(/(\\r\\n|\\r|\\n)/g, \"\\n\");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.normalizeWhitespace = function(str) {\n  return str.replace(/\\xa0|\\s/g, \" \");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.normalizeSpaces = function(str) {\n  return str.replace(/\\xa0|[ \\t]+/g, \" \");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.collapseBreakingSpaces = function(str) {\n  return str.replace(/[\\t\\r\\n ]+/g, \" \").replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, \"\");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(str) {\n  return str.trim();\n} : function(str) {\n  return str.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, \"\");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.trimLeft = function(str) {\n  return str.replace(/^[\\s\\xa0]+/, \"\");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.trimRight = function(str) {\n  return str.replace(/[\\s\\xa0]+$/, \"\");\n};\n/**\n * @param {string} str1\n * @param {string} str2\n * @return {number}\n */\ngoog.string.caseInsensitiveCompare = function(str1, str2) {\n  var test1 = String(str1).toLowerCase();\n  var test2 = String(str2).toLowerCase();\n  if (test1 < test2) {\n    return -1;\n  } else {\n    if (test1 == test2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n};\n/**\n * @private\n * @param {string} str1\n * @param {string} str2\n * @param {!RegExp} tokenizerRegExp\n * @return {number}\n */\ngoog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {\n  if (str1 == str2) {\n    return 0;\n  }\n  if (!str1) {\n    return -1;\n  }\n  if (!str2) {\n    return 1;\n  }\n  var tokens1 = str1.toLowerCase().match(tokenizerRegExp);\n  var tokens2 = str2.toLowerCase().match(tokenizerRegExp);\n  var count = Math.min(tokens1.length, tokens2.length);\n  for (var i = 0; i < count; i++) {\n    var a = tokens1[i];\n    var b = tokens2[i];\n    if (a != b) {\n      var num1 = parseInt(a, 10);\n      if (!isNaN(num1)) {\n        var num2 = parseInt(b, 10);\n        if (!isNaN(num2) && num1 - num2) {\n          return num1 - num2;\n        }\n      }\n      return a < b ? -1 : 1;\n    }\n  }\n  if (tokens1.length != tokens2.length) {\n    return tokens1.length - tokens2.length;\n  }\n  return str1 < str2 ? -1 : 1;\n};\n/**\n * @param {string} str1\n * @param {string} str2\n * @return {number}\n */\ngoog.string.intAwareCompare = function(str1, str2) {\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\D+/g);\n};\n/**\n * @param {string} str1\n * @param {string} str2\n * @return {number}\n */\ngoog.string.floatAwareCompare = function(str1, str2) {\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\.\\d+|\\D+/g);\n};\n/**\n * @param {string} str1\n * @param {string} str2\n * @return {number}\n */\ngoog.string.numerateCompare = goog.string.floatAwareCompare;\n/**\n * @param {*} str\n * @return {string}\n */\ngoog.string.urlEncode = function(str) {\n  return encodeURIComponent(String(str));\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.urlDecode = function(str) {\n  return decodeURIComponent(str.replace(/\\+/g, \" \"));\n};\n/**\n * @param {string} str\n * @param {boolean=} opt_xml\n * @return {string}\n */\ngoog.string.newLineToBr = function(str, opt_xml) {\n  return str.replace(/(\\r\\n|\\r|\\n)/g, opt_xml ? \"\\x3cbr /\\x3e\" : \"\\x3cbr\\x3e\");\n};\n/**\n * @param {string} str\n * @param {boolean=} opt_isLikelyToContainHtmlChars\n * @return {string}\n */\ngoog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {\n  if (opt_isLikelyToContainHtmlChars) {\n    str = str.replace(goog.string.AMP_RE_, \"\\x26amp;\").replace(goog.string.LT_RE_, \"\\x26lt;\").replace(goog.string.GT_RE_, \"\\x26gt;\").replace(goog.string.QUOT_RE_, \"\\x26quot;\").replace(goog.string.SINGLE_QUOTE_RE_, \"\\x26#39;\").replace(goog.string.NULL_RE_, \"\\x26#0;\");\n    if (goog.string.DETECT_DOUBLE_ESCAPING) {\n      str = str.replace(goog.string.E_RE_, \"\\x26#101;\");\n    }\n    return str;\n  } else {\n    if (!goog.string.ALL_RE_.test(str)) {\n      return str;\n    }\n    if (str.indexOf(\"\\x26\") != -1) {\n      str = str.replace(goog.string.AMP_RE_, \"\\x26amp;\");\n    }\n    if (str.indexOf(\"\\x3c\") != -1) {\n      str = str.replace(goog.string.LT_RE_, \"\\x26lt;\");\n    }\n    if (str.indexOf(\"\\x3e\") != -1) {\n      str = str.replace(goog.string.GT_RE_, \"\\x26gt;\");\n    }\n    if (str.indexOf('\"') != -1) {\n      str = str.replace(goog.string.QUOT_RE_, \"\\x26quot;\");\n    }\n    if (str.indexOf(\"'\") != -1) {\n      str = str.replace(goog.string.SINGLE_QUOTE_RE_, \"\\x26#39;\");\n    }\n    if (str.indexOf(\"\\x00\") != -1) {\n      str = str.replace(goog.string.NULL_RE_, \"\\x26#0;\");\n    }\n    if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf(\"e\") != -1) {\n      str = str.replace(goog.string.E_RE_, \"\\x26#101;\");\n    }\n    return str;\n  }\n};\n/** @private @const @type {!RegExp} */ goog.string.AMP_RE_ = /&/g;\n/** @private @const @type {!RegExp} */ goog.string.LT_RE_ = /</g;\n/** @private @const @type {!RegExp} */ goog.string.GT_RE_ = />/g;\n/** @private @const @type {!RegExp} */ goog.string.QUOT_RE_ = /\"/g;\n/** @private @const @type {!RegExp} */ goog.string.SINGLE_QUOTE_RE_ = /'/g;\n/** @private @const @type {!RegExp} */ goog.string.NULL_RE_ = /\\x00/g;\n/** @private @const @type {!RegExp} */ goog.string.E_RE_ = /e/g;\n/** @private @const @type {!RegExp} */ goog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\\x00&<>\"'e]/ : /[\\x00&<>\"']/;\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.unescapeEntities = function(str) {\n  if (goog.string.contains(str, \"\\x26\")) {\n    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING && \"document\" in goog.global) {\n      return goog.string.unescapeEntitiesUsingDom_(str);\n    } else {\n      return goog.string.unescapePureXmlEntities_(str);\n    }\n  }\n  return str;\n};\n/**\n * @param {string} str\n * @param {!Document} document\n * @return {string}\n */\ngoog.string.unescapeEntitiesWithDocument = function(str, document) {\n  if (goog.string.contains(str, \"\\x26\")) {\n    return goog.string.unescapeEntitiesUsingDom_(str, document);\n  }\n  return str;\n};\n/**\n * @private\n * @param {string} str\n * @param {Document=} opt_document\n * @return {string}\n */\ngoog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {\n  /** @type {!Object<string,string>} */ var seen = {\"\\x26amp;\":\"\\x26\", \"\\x26lt;\":\"\\x3c\", \"\\x26gt;\":\"\\x3e\", \"\\x26quot;\":'\"'};\n  var div;\n  if (opt_document) {\n    div = opt_document.createElement(\"div\");\n  } else {\n    div = goog.global.document.createElement(\"div\");\n  }\n  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {\n    var value = seen[s];\n    if (value) {\n      return value;\n    }\n    if (entity.charAt(0) == \"#\") {\n      var n = Number(\"0\" + entity.substr(1));\n      if (!isNaN(n)) {\n        value = String.fromCharCode(n);\n      }\n    }\n    if (!value) {\n      div.innerHTML = s + \" \";\n      value = div.firstChild.nodeValue.slice(0, -1);\n    }\n    return seen[s] = value;\n  });\n};\n/**\n * @private\n * @param {string} str\n * @return {string}\n */\ngoog.string.unescapePureXmlEntities_ = function(str) {\n  return str.replace(/&([^;]+);/g, function(s, entity) {\n    switch(entity) {\n      case \"amp\":\n        return \"\\x26\";\n      case \"lt\":\n        return \"\\x3c\";\n      case \"gt\":\n        return \"\\x3e\";\n      case \"quot\":\n        return '\"';\n      default:\n        if (entity.charAt(0) == \"#\") {\n          var n = Number(\"0\" + entity.substr(1));\n          if (!isNaN(n)) {\n            return String.fromCharCode(n);\n          }\n        }\n        return s;\n    }\n  });\n};\n/** @private @type {!RegExp} */ goog.string.HTML_ENTITY_PATTERN_ = /&([^;\\s<&]+);?/g;\n/**\n * @param {string} str\n * @param {boolean=} opt_xml\n * @return {string}\n */\ngoog.string.whitespaceEscape = function(str, opt_xml) {\n  return goog.string.newLineToBr(str.replace(/  /g, \" \\x26#160;\"), opt_xml);\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.preserveSpaces = function(str) {\n  return str.replace(/(^|[\\n ]) /g, \"$1\" + goog.string.Unicode.NBSP);\n};\n/**\n * @param {string} str\n * @param {string} quoteChars\n * @return {string}\n */\ngoog.string.stripQuotes = function(str, quoteChars) {\n  var length = quoteChars.length;\n  for (var i = 0; i < length; i++) {\n    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);\n    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {\n      return str.substring(1, str.length - 1);\n    }\n  }\n  return str;\n};\n/**\n * @param {string} str\n * @param {number} chars\n * @param {boolean=} opt_protectEscapedCharacters\n * @return {string}\n */\ngoog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.unescapeEntities(str);\n  }\n  if (str.length > chars) {\n    str = str.substring(0, chars - 3) + \"...\";\n  }\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.htmlEscape(str);\n  }\n  return str;\n};\n/**\n * @param {string} str\n * @param {number} chars\n * @param {boolean=} opt_protectEscapedCharacters\n * @param {number=} opt_trailingChars\n * @return {string}\n */\ngoog.string.truncateMiddle = function(str, chars, opt_protectEscapedCharacters, opt_trailingChars) {\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.unescapeEntities(str);\n  }\n  if (opt_trailingChars && str.length > chars) {\n    if (opt_trailingChars > chars) {\n      opt_trailingChars = chars;\n    }\n    var endPoint = str.length - opt_trailingChars;\n    var startPoint = chars - opt_trailingChars;\n    str = str.substring(0, startPoint) + \"...\" + str.substring(endPoint);\n  } else {\n    if (str.length > chars) {\n      var half = Math.floor(chars / 2);\n      var endPos = str.length - half;\n      half += chars % 2;\n      str = str.substring(0, half) + \"...\" + str.substring(endPos);\n    }\n  }\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.htmlEscape(str);\n  }\n  return str;\n};\n/** @private @type {!Object<string,string>} */ goog.string.specialEscapeChars_ = {\"\\x00\":\"\\\\0\", \"\\b\":\"\\\\b\", \"\\f\":\"\\\\f\", \"\\n\":\"\\\\n\", \"\\r\":\"\\\\r\", \"\\t\":\"\\\\t\", \"\\x0B\":\"\\\\x0B\", '\"':'\\\\\"', \"\\\\\":\"\\\\\\\\\", \"\\x3c\":\"\\x3c\"};\n/** @private @type {!Object<string,string>} */ goog.string.jsEscapeCache_ = {\"'\":\"\\\\'\"};\n/**\n * @param {string} s\n * @return {string}\n */\ngoog.string.quote = function(s) {\n  s = String(s);\n  var sb = ['\"'];\n  for (var i = 0; i < s.length; i++) {\n    var ch = s.charAt(i);\n    var cc = ch.charCodeAt(0);\n    sb[i + 1] = goog.string.specialEscapeChars_[ch] || (cc > 31 && cc < 127 ? ch : goog.string.escapeChar(ch));\n  }\n  sb.push('\"');\n  return sb.join(\"\");\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.escapeString = function(str) {\n  var sb = [];\n  for (var i = 0; i < str.length; i++) {\n    sb[i] = goog.string.escapeChar(str.charAt(i));\n  }\n  return sb.join(\"\");\n};\n/**\n * @param {string} c\n * @return {string}\n */\ngoog.string.escapeChar = function(c) {\n  if (c in goog.string.jsEscapeCache_) {\n    return goog.string.jsEscapeCache_[c];\n  }\n  if (c in goog.string.specialEscapeChars_) {\n    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];\n  }\n  var rv = c;\n  var cc = c.charCodeAt(0);\n  if (cc > 31 && cc < 127) {\n    rv = c;\n  } else {\n    if (cc < 256) {\n      rv = \"\\\\x\";\n      if (cc < 16 || cc > 256) {\n        rv += \"0\";\n      }\n    } else {\n      rv = \"\\\\u\";\n      if (cc < 4096) {\n        rv += \"0\";\n      }\n    }\n    rv += cc.toString(16).toUpperCase();\n  }\n  return goog.string.jsEscapeCache_[c] = rv;\n};\n/**\n * @param {string} str\n * @param {string} subString\n * @return {boolean}\n */\ngoog.string.contains = function(str, subString) {\n  return str.indexOf(subString) != -1;\n};\n/**\n * @param {string} str\n * @param {string} subString\n * @return {boolean}\n */\ngoog.string.caseInsensitiveContains = function(str, subString) {\n  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());\n};\n/**\n * @param {string} s\n * @param {string} ss\n * @return {number}\n */\ngoog.string.countOf = function(s, ss) {\n  return s && ss ? s.split(ss).length - 1 : 0;\n};\n/**\n * @param {string} s\n * @param {number} index\n * @param {number} stringLength\n * @return {string}\n */\ngoog.string.removeAt = function(s, index, stringLength) {\n  var resultStr = s;\n  if (index >= 0 && index < s.length && stringLength > 0) {\n    resultStr = s.substr(0, index) + s.substr(index + stringLength, s.length - index - stringLength);\n  }\n  return resultStr;\n};\n/**\n * @param {string} str\n * @param {string} substr\n * @return {string}\n */\ngoog.string.remove = function(str, substr) {\n  return str.replace(substr, \"\");\n};\n/**\n * @param {string} s\n * @param {string} ss\n * @return {string}\n */\ngoog.string.removeAll = function(s, ss) {\n  var re = new RegExp(goog.string.regExpEscape(ss), \"g\");\n  return s.replace(re, \"\");\n};\n/**\n * @param {string} s\n * @param {string} ss\n * @param {string} replacement\n * @return {string}\n */\ngoog.string.replaceAll = function(s, ss, replacement) {\n  var re = new RegExp(goog.string.regExpEscape(ss), \"g\");\n  return s.replace(re, replacement.replace(/\\$/g, \"$$$$\"));\n};\n/**\n * @param {*} s\n * @return {string}\n */\ngoog.string.regExpEscape = function(s) {\n  return String(s).replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\").replace(/\\x08/g, \"\\\\x08\");\n};\n/**\n * @param {string} string\n * @param {number} length\n * @return {string}\n */\ngoog.string.repeat = String.prototype.repeat ? function(string, length) {\n  return string.repeat(length);\n} : function(string, length) {\n  return (new Array(length + 1)).join(string);\n};\n/**\n * @param {number} num\n * @param {number} length\n * @param {number=} opt_precision\n * @return {string}\n */\ngoog.string.padNumber = function(num, length, opt_precision) {\n  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);\n  var index = s.indexOf(\".\");\n  if (index == -1) {\n    index = s.length;\n  }\n  return goog.string.repeat(\"0\", Math.max(0, length - index)) + s;\n};\n/**\n * @param {*} obj\n * @return {string}\n */\ngoog.string.makeSafe = function(obj) {\n  return obj == null ? \"\" : String(obj);\n};\n/**\n * @param {...*} var_args\n * @return {string}\n */\ngoog.string.buildString = function(var_args) {\n  return Array.prototype.join.call(arguments, \"\");\n};\n/**\n * @return {string}\n */\ngoog.string.getRandomString = function() {\n  var x = 2147483648;\n  return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);\n};\n/**\n * @param {(string|number)} version1\n * @param {(string|number)} version2\n * @return {number}\n */\ngoog.string.compareVersions = function(version1, version2) {\n  var order = 0;\n  var v1Subs = goog.string.trim(String(version1)).split(\".\");\n  var v2Subs = goog.string.trim(String(version2)).split(\".\");\n  var subCount = Math.max(v1Subs.length, v2Subs.length);\n  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {\n    var v1Sub = v1Subs[subIdx] || \"\";\n    var v2Sub = v2Subs[subIdx] || \"\";\n    do {\n      var v1Comp = /(\\d*)(\\D*)(.*)/.exec(v1Sub) || [\"\", \"\", \"\", \"\"];\n      var v2Comp = /(\\d*)(\\D*)(.*)/.exec(v2Sub) || [\"\", \"\", \"\", \"\"];\n      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {\n        break;\n      }\n      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);\n      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);\n      order = goog.string.compareElements_(v1CompNum, v2CompNum) || goog.string.compareElements_(v1Comp[2].length == 0, v2Comp[2].length == 0) || goog.string.compareElements_(v1Comp[2], v2Comp[2]);\n      v1Sub = v1Comp[3];\n      v2Sub = v2Comp[3];\n    } while (order == 0);\n  }\n  return order;\n};\n/**\n * @private\n * @param {(string|number|boolean)} left\n * @param {(string|number|boolean)} right\n * @return {number}\n */\ngoog.string.compareElements_ = function(left, right) {\n  if (left < right) {\n    return -1;\n  } else {\n    if (left > right) {\n      return 1;\n    }\n  }\n  return 0;\n};\n/**\n * @param {string} str\n * @return {number}\n */\ngoog.string.hashCode = function(str) {\n  var result = 0;\n  for (var i = 0; i < str.length; ++i) {\n    result = 31 * result + str.charCodeAt(i) >>> 0;\n  }\n  return result;\n};\n/** @private @type {number} */ goog.string.uniqueStringCounter_ = Math.random() * 2147483648 | 0;\n/**\n * @return {string}\n */\ngoog.string.createUniqueString = function() {\n  return \"goog_\" + goog.string.uniqueStringCounter_++;\n};\n/**\n * @param {string} str\n * @return {number}\n */\ngoog.string.toNumber = function(str) {\n  var num = Number(str);\n  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {\n    return NaN;\n  }\n  return num;\n};\n/**\n * @param {string} str\n * @return {boolean}\n */\ngoog.string.isLowerCamelCase = function(str) {\n  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);\n};\n/**\n * @param {string} str\n * @return {boolean}\n */\ngoog.string.isUpperCamelCase = function(str) {\n  return /^([A-Z][a-z]*)+$/.test(str);\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.toCamelCase = function(str) {\n  return String(str).replace(/\\-([a-z])/g, function(all, match) {\n    return match.toUpperCase();\n  });\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.toSelectorCase = function(str) {\n  return String(str).replace(/([A-Z])/g, \"-$1\").toLowerCase();\n};\n/**\n * @param {string} str\n * @param {string=} opt_delimiters\n * @return {string}\n */\ngoog.string.toTitleCase = function(str, opt_delimiters) {\n  var delimiters = goog.isString(opt_delimiters) ? goog.string.regExpEscape(opt_delimiters) : \"\\\\s\";\n  delimiters = delimiters ? \"|[\" + delimiters + \"]+\" : \"\";\n  var regexp = new RegExp(\"(^\" + delimiters + \")([a-z])\", \"g\");\n  return str.replace(regexp, function(all, p1, p2) {\n    return p1 + p2.toUpperCase();\n  });\n};\n/**\n * @param {string} str\n * @return {string}\n */\ngoog.string.capitalize = function(str) {\n  return String(str.charAt(0)).toUpperCase() + String(str.substr(1)).toLowerCase();\n};\n/**\n * @param {(string|number|null|undefined)} value\n * @return {number}\n */\ngoog.string.parseInt = function(value) {\n  if (isFinite(value)) {\n    value = String(value);\n  }\n  if (goog.isString(value)) {\n    return /^\\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);\n  }\n  return NaN;\n};\n/**\n * @param {string} str\n * @param {string} separator\n * @param {number} limit\n * @return {!Array<string>}\n */\ngoog.string.splitLimit = function(str, separator, limit) {\n  var parts = str.split(separator);\n  var returnVal = [];\n  while (limit > 0 && parts.length) {\n    returnVal.push(parts.shift());\n    limit--;\n  }\n  if (parts.length) {\n    returnVal.push(parts.join(separator));\n  }\n  return returnVal;\n};\n/**\n * @param {string} str\n * @param {(string|!Array<string>)} separators\n * @return {string}\n */\ngoog.string.lastComponent = function(str, separators) {\n  if (!separators) {\n    return str;\n  } else {\n    if (typeof separators == \"string\") {\n      separators = [separators];\n    }\n  }\n  var lastSeparatorIndex = -1;\n  for (var i = 0; i < separators.length; i++) {\n    if (separators[i] == \"\") {\n      continue;\n    }\n    var currentSeparatorIndex = str.lastIndexOf(separators[i]);\n    if (currentSeparatorIndex > lastSeparatorIndex) {\n      lastSeparatorIndex = currentSeparatorIndex;\n    }\n  }\n  if (lastSeparatorIndex == -1) {\n    return str;\n  }\n  return str.slice(lastSeparatorIndex + 1);\n};\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\ngoog.string.editDistance = function(a, b) {\n  var v0 = [];\n  var v1 = [];\n  if (a == b) {\n    return 0;\n  }\n  if (!a.length || !b.length) {\n    return Math.max(a.length, b.length);\n  }\n  for (var i = 0; i < b.length + 1; i++) {\n    v0[i] = i;\n  }\n  for (var i = 0; i < a.length; i++) {\n    v1[0] = i + 1;\n    for (var j = 0; j < b.length; j++) {\n      var cost = Number(a[i] != b[j]);\n      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);\n    }\n    for (var j = 0; j < v0.length; j++) {\n      v0[j] = v1[j];\n    }\n  }\n  return v1[b.length];\n};\n","~:source","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities for string manipulation.\n * @author arv@google.com (Erik Arvidsson)\n */\n\n\n/**\n * Namespace for string utilities\n */\ngoog.provide('goog.string');\ngoog.provide('goog.string.Unicode');\n\n\n/**\n * @define {boolean} Enables HTML escaping of lowercase letter \"e\" which helps\n * with detection of double-escaping as this letter is frequently used.\n */\ngoog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);\n\n\n/**\n * @define {boolean} Whether to force non-dom html unescaping.\n */\ngoog.define('goog.string.FORCE_NON_DOM_HTML_UNESCAPING', false);\n\n\n/**\n * Common Unicode string characters.\n * @enum {string}\n */\ngoog.string.Unicode = {\n  NBSP: '\\xa0'\n};\n\n\n/**\n * Fast prefix-checker.\n * @param {string} str The string to check.\n * @param {string} prefix A string to look for at the start of {@code str}.\n * @return {boolean} True if {@code str} begins with {@code prefix}.\n */\ngoog.string.startsWith = function(str, prefix) {\n  return str.lastIndexOf(prefix, 0) == 0;\n};\n\n\n/**\n * Fast suffix-checker.\n * @param {string} str The string to check.\n * @param {string} suffix A string to look for at the end of {@code str}.\n * @return {boolean} True if {@code str} ends with {@code suffix}.\n */\ngoog.string.endsWith = function(str, suffix) {\n  var l = str.length - suffix.length;\n  return l >= 0 && str.indexOf(suffix, l) == l;\n};\n\n\n/**\n * Case-insensitive prefix-checker.\n * @param {string} str The string to check.\n * @param {string} prefix  A string to look for at the end of {@code str}.\n * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring\n *     case).\n */\ngoog.string.caseInsensitiveStartsWith = function(str, prefix) {\n  return goog.string.caseInsensitiveCompare(\n             prefix, str.substr(0, prefix.length)) == 0;\n};\n\n\n/**\n * Case-insensitive suffix-checker.\n * @param {string} str The string to check.\n * @param {string} suffix A string to look for at the end of {@code str}.\n * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring\n *     case).\n */\ngoog.string.caseInsensitiveEndsWith = function(str, suffix) {\n  return (\n      goog.string.caseInsensitiveCompare(\n          suffix, str.substr(str.length - suffix.length, suffix.length)) == 0);\n};\n\n\n/**\n * Case-insensitive equality checker.\n * @param {string} str1 First string to check.\n * @param {string} str2 Second string to check.\n * @return {boolean} True if {@code str1} and {@code str2} are the same string,\n *     ignoring case.\n */\ngoog.string.caseInsensitiveEquals = function(str1, str2) {\n  return str1.toLowerCase() == str2.toLowerCase();\n};\n\n\n/**\n * Does simple python-style string substitution.\n * subs(\"foo%s hot%s\", \"bar\", \"dog\") becomes \"foobar hotdog\".\n * @param {string} str The string containing the pattern.\n * @param {...*} var_args The items to substitute into the pattern.\n * @return {string} A copy of {@code str} in which each occurrence of\n *     {@code %s} has been replaced an argument from {@code var_args}.\n */\ngoog.string.subs = function(str, var_args) {\n  var splitParts = str.split('%s');\n  var returnString = '';\n\n  var subsArguments = Array.prototype.slice.call(arguments, 1);\n  while (subsArguments.length &&\n         // Replace up to the last split part. We are inserting in the\n         // positions between split parts.\n         splitParts.length > 1) {\n    returnString += splitParts.shift() + subsArguments.shift();\n  }\n\n  return returnString + splitParts.join('%s');  // Join unused '%s'\n};\n\n\n/**\n * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines\n * and tabs) to a single space, and strips leading and trailing whitespace.\n * @param {string} str Input string.\n * @return {string} A copy of {@code str} with collapsed whitespace.\n */\ngoog.string.collapseWhitespace = function(str) {\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return str.replace(/[\\s\\xa0]+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n};\n\n\n/**\n * Checks if a string is empty or contains only whitespaces.\n * @param {string} str The string to check.\n * @return {boolean} Whether {@code str} is empty or whitespace only.\n */\ngoog.string.isEmptyOrWhitespace = function(str) {\n  // testing length == 0 first is actually slower in all browsers (about the\n  // same in Opera).\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return /^[\\s\\xa0]*$/.test(str);\n};\n\n\n/**\n * Checks if a string is empty.\n * @param {string} str The string to check.\n * @return {boolean} Whether {@code str} is empty.\n */\ngoog.string.isEmptyString = function(str) {\n  return str.length == 0;\n};\n\n\n/**\n * Checks if a string is empty or contains only whitespaces.\n *\n * @param {string} str The string to check.\n * @return {boolean} Whether {@code str} is empty or whitespace only.\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\n */\ngoog.string.isEmpty = goog.string.isEmptyOrWhitespace;\n\n\n/**\n * Checks if a string is null, undefined, empty or contains only whitespaces.\n * @param {*} str The string to check.\n * @return {boolean} Whether {@code str} is null, undefined, empty, or\n *     whitespace only.\n * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))\n *     instead.\n */\ngoog.string.isEmptyOrWhitespaceSafe = function(str) {\n  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));\n};\n\n\n/**\n * Checks if a string is null, undefined, empty or contains only whitespaces.\n *\n * @param {*} str The string to check.\n * @return {boolean} Whether {@code str} is null, undefined, empty, or\n *     whitespace only.\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\n */\ngoog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;\n\n\n/**\n * Checks if a string is all breaking whitespace.\n * @param {string} str The string to check.\n * @return {boolean} Whether the string is all breaking whitespace.\n */\ngoog.string.isBreakingWhitespace = function(str) {\n  return !/[^\\t\\n\\r ]/.test(str);\n};\n\n\n/**\n * Checks if a string contains all letters.\n * @param {string} str string to check.\n * @return {boolean} True if {@code str} consists entirely of letters.\n */\ngoog.string.isAlpha = function(str) {\n  return !/[^a-zA-Z]/.test(str);\n};\n\n\n/**\n * Checks if a string contains only numbers.\n * @param {*} str string to check. If not a string, it will be\n *     casted to one.\n * @return {boolean} True if {@code str} is numeric.\n */\ngoog.string.isNumeric = function(str) {\n  return !/[^0-9]/.test(str);\n};\n\n\n/**\n * Checks if a string contains only numbers or letters.\n * @param {string} str string to check.\n * @return {boolean} True if {@code str} is alphanumeric.\n */\ngoog.string.isAlphaNumeric = function(str) {\n  return !/[^a-zA-Z0-9]/.test(str);\n};\n\n\n/**\n * Checks if a character is a space character.\n * @param {string} ch Character to check.\n * @return {boolean} True if {@code ch} is a space.\n */\ngoog.string.isSpace = function(ch) {\n  return ch == ' ';\n};\n\n\n/**\n * Checks if a character is a valid unicode character.\n * @param {string} ch Character to check.\n * @return {boolean} True if {@code ch} is a valid unicode character.\n */\ngoog.string.isUnicodeChar = function(ch) {\n  return ch.length == 1 && ch >= ' ' && ch <= '~' ||\n      ch >= '\\u0080' && ch <= '\\uFFFD';\n};\n\n\n/**\n * Takes a string and replaces newlines with a space. Multiple lines are\n * replaced with a single space.\n * @param {string} str The string from which to strip newlines.\n * @return {string} A copy of {@code str} stripped of newlines.\n */\ngoog.string.stripNewlines = function(str) {\n  return str.replace(/(\\r\\n|\\r|\\n)+/g, ' ');\n};\n\n\n/**\n * Replaces Windows and Mac new lines with unix style: \\r or \\r\\n with \\n.\n * @param {string} str The string to in which to canonicalize newlines.\n * @return {string} {@code str} A copy of {@code} with canonicalized newlines.\n */\ngoog.string.canonicalizeNewlines = function(str) {\n  return str.replace(/(\\r\\n|\\r|\\n)/g, '\\n');\n};\n\n\n/**\n * Normalizes whitespace in a string, replacing all whitespace chars with\n * a space.\n * @param {string} str The string in which to normalize whitespace.\n * @return {string} A copy of {@code str} with all whitespace normalized.\n */\ngoog.string.normalizeWhitespace = function(str) {\n  return str.replace(/\\xa0|\\s/g, ' ');\n};\n\n\n/**\n * Normalizes spaces in a string, replacing all consecutive spaces and tabs\n * with a single space. Replaces non-breaking space with a space.\n * @param {string} str The string in which to normalize spaces.\n * @return {string} A copy of {@code str} with all consecutive spaces and tabs\n *    replaced with a single space.\n */\ngoog.string.normalizeSpaces = function(str) {\n  return str.replace(/\\xa0|[ \\t]+/g, ' ');\n};\n\n\n/**\n * Removes the breaking spaces from the left and right of the string and\n * collapses the sequences of breaking spaces in the middle into single spaces.\n * The original and the result strings render the same way in HTML.\n * @param {string} str A string in which to collapse spaces.\n * @return {string} Copy of the string with normalized breaking spaces.\n */\ngoog.string.collapseBreakingSpaces = function(str) {\n  return str.replace(/[\\t\\r\\n ]+/g, ' ')\n      .replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, '');\n};\n\n\n/**\n * Trims white spaces to the left and right of a string.\n * @param {string} str The string to trim.\n * @return {string} A trimmed copy of {@code str}.\n */\ngoog.string.trim =\n    (goog.TRUSTED_SITE && String.prototype.trim) ? function(str) {\n      return str.trim();\n    } : function(str) {\n      // Since IE doesn't include non-breaking-space (0xa0) in their \\s\n      // character class (as required by section 7.2 of the ECMAScript spec),\n      // we explicitly include it in the regexp to enforce consistent\n      // cross-browser behavior.\n      return str.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n    };\n\n\n/**\n * Trims whitespaces at the left end of a string.\n * @param {string} str The string to left trim.\n * @return {string} A trimmed copy of {@code str}.\n */\ngoog.string.trimLeft = function(str) {\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return str.replace(/^[\\s\\xa0]+/, '');\n};\n\n\n/**\n * Trims whitespaces at the right end of a string.\n * @param {string} str The string to right trim.\n * @return {string} A trimmed copy of {@code str}.\n */\ngoog.string.trimRight = function(str) {\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return str.replace(/[\\s\\xa0]+$/, '');\n};\n\n\n/**\n * A string comparator that ignores case.\n * -1 = str1 less than str2\n *  0 = str1 equals str2\n *  1 = str1 greater than str2\n *\n * @param {string} str1 The string to compare.\n * @param {string} str2 The string to compare {@code str1} to.\n * @return {number} The comparator result, as described above.\n */\ngoog.string.caseInsensitiveCompare = function(str1, str2) {\n  var test1 = String(str1).toLowerCase();\n  var test2 = String(str2).toLowerCase();\n\n  if (test1 < test2) {\n    return -1;\n  } else if (test1 == test2) {\n    return 0;\n  } else {\n    return 1;\n  }\n};\n\n\n/**\n * Compares two strings interpreting their numeric substrings as numbers.\n *\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @param {!RegExp} tokenizerRegExp Splits a string into substrings of\n *     non-negative integers, non-numeric characters and optionally fractional\n *     numbers starting with a decimal point.\n * @return {number} Negative if str1 < str2, 0 is str1 == str2, positive if\n *     str1 > str2.\n * @private\n */\ngoog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {\n  if (str1 == str2) {\n    return 0;\n  }\n  if (!str1) {\n    return -1;\n  }\n  if (!str2) {\n    return 1;\n  }\n\n  // Using match to split the entire string ahead of time turns out to be faster\n  // for most inputs than using RegExp.exec or iterating over each character.\n  var tokens1 = str1.toLowerCase().match(tokenizerRegExp);\n  var tokens2 = str2.toLowerCase().match(tokenizerRegExp);\n\n  var count = Math.min(tokens1.length, tokens2.length);\n\n  for (var i = 0; i < count; i++) {\n    var a = tokens1[i];\n    var b = tokens2[i];\n\n    // Compare pairs of tokens, returning if one token sorts before the other.\n    if (a != b) {\n      // Only if both tokens are integers is a special comparison required.\n      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').\n      var num1 = parseInt(a, 10);\n      if (!isNaN(num1)) {\n        var num2 = parseInt(b, 10);\n        if (!isNaN(num2) && num1 - num2) {\n          return num1 - num2;\n        }\n      }\n      return a < b ? -1 : 1;\n    }\n  }\n\n  // If one string is a substring of the other, the shorter string sorts first.\n  if (tokens1.length != tokens2.length) {\n    return tokens1.length - tokens2.length;\n  }\n\n  // The two strings must be equivalent except for case (perfect equality is\n  // tested at the head of the function.) Revert to default ASCII string\n  // comparison to stabilize the sort.\n  return str1 < str2 ? -1 : 1;\n};\n\n\n/**\n * String comparison function that handles non-negative integer numbers in a\n * way humans might expect. Using this function, the string 'File 2.jpg' sorts\n * before 'File 10.jpg', and 'Version 1.9' before 'Version 1.10'. The comparison\n * is mostly case-insensitive, though strings that are identical except for case\n * are sorted with the upper-case strings before lower-case.\n *\n * This comparison function is up to 50x slower than either the default or the\n * case-insensitive compare. It should not be used in time-critical code, but\n * should be fast enough to sort several hundred short strings (like filenames)\n * with a reasonable delay.\n *\n * @param {string} str1 The string to compare in a numerically sensitive way.\n * @param {string} str2 The string to compare {@code str1} to.\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\n *     0 if str1 > str2.\n */\ngoog.string.intAwareCompare = function(str1, str2) {\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\D+/g);\n};\n\n\n/**\n * String comparison function that handles non-negative integer and fractional\n * numbers in a way humans might expect. Using this function, the string\n * 'File 2.jpg' sorts before 'File 10.jpg', and '3.14' before '3.2'. Equivalent\n * to {@link goog.string.intAwareCompare} apart from the way how it interprets\n * dots.\n *\n * @param {string} str1 The string to compare in a numerically sensitive way.\n * @param {string} str2 The string to compare {@code str1} to.\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\n *     0 if str1 > str2.\n */\ngoog.string.floatAwareCompare = function(str1, str2) {\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\.\\d+|\\D+/g);\n};\n\n\n/**\n * Alias for {@link goog.string.floatAwareCompare}.\n *\n * @param {string} str1\n * @param {string} str2\n * @return {number}\n */\ngoog.string.numerateCompare = goog.string.floatAwareCompare;\n\n\n/**\n * URL-encodes a string\n * @param {*} str The string to url-encode.\n * @return {string} An encoded copy of {@code str} that is safe for urls.\n *     Note that '#', ':', and other characters used to delimit portions\n *     of URLs *will* be encoded.\n */\ngoog.string.urlEncode = function(str) {\n  return encodeURIComponent(String(str));\n};\n\n\n/**\n * URL-decodes the string. We need to specially handle '+'s because\n * the javascript library doesn't convert them to spaces.\n * @param {string} str The string to url decode.\n * @return {string} The decoded {@code str}.\n */\ngoog.string.urlDecode = function(str) {\n  return decodeURIComponent(str.replace(/\\+/g, ' '));\n};\n\n\n/**\n * Converts \\n to <br>s or <br />s.\n * @param {string} str The string in which to convert newlines.\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\n * @return {string} A copy of {@code str} with converted newlines.\n */\ngoog.string.newLineToBr = function(str, opt_xml) {\n  return str.replace(/(\\r\\n|\\r|\\n)/g, opt_xml ? '<br />' : '<br>');\n};\n\n\n/**\n * Escapes double quote '\"' and single quote '\\'' characters in addition to\n * '&', '<', and '>' so that a string can be included in an HTML tag attribute\n * value within double or single quotes.\n *\n * It should be noted that > doesn't need to be escaped for the HTML or XML to\n * be valid, but it has been decided to escape it for consistency with other\n * implementations.\n *\n * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the\n * lowercase letter \"e\".\n *\n * NOTE(user):\n * HtmlEscape is often called during the generation of large blocks of HTML.\n * Using statics for the regular expressions and strings is an optimization\n * that can more than half the amount of time IE spends in this function for\n * large apps, since strings and regexes both contribute to GC allocations.\n *\n * Testing for the presence of a character before escaping increases the number\n * of function calls, but actually provides a speed increase for the average\n * case -- since the average case often doesn't require the escaping of all 4\n * characters and indexOf() is much cheaper than replace().\n * The worst case does suffer slightly from the additional calls, therefore the\n * opt_isLikelyToContainHtmlChars option has been included for situations\n * where all 4 HTML entities are very likely to be present and need escaping.\n *\n * Some benchmarks (times tended to fluctuate +-0.05ms):\n *                                     FireFox                     IE6\n * (no chars / average (mix of cases) / all 4 chars)\n * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80\n * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84\n * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85\n *\n * An additional advantage of checking if replace actually needs to be called\n * is a reduction in the number of object allocations, so as the size of the\n * application grows the difference between the various methods would increase.\n *\n * @param {string} str string to be escaped.\n * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see\n *     if the character needs replacing - use this option if you expect each of\n *     the characters to appear often. Leave false if you expect few html\n *     characters to occur in your strings, such as if you are escaping HTML.\n * @return {string} An escaped copy of {@code str}.\n */\ngoog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {\n\n  if (opt_isLikelyToContainHtmlChars) {\n    str = str.replace(goog.string.AMP_RE_, '&amp;')\n              .replace(goog.string.LT_RE_, '&lt;')\n              .replace(goog.string.GT_RE_, '&gt;')\n              .replace(goog.string.QUOT_RE_, '&quot;')\n              .replace(goog.string.SINGLE_QUOTE_RE_, '&#39;')\n              .replace(goog.string.NULL_RE_, '&#0;');\n    if (goog.string.DETECT_DOUBLE_ESCAPING) {\n      str = str.replace(goog.string.E_RE_, '&#101;');\n    }\n    return str;\n\n  } else {\n    // quick test helps in the case when there are no chars to replace, in\n    // worst case this makes barely a difference to the time taken\n    if (!goog.string.ALL_RE_.test(str)) return str;\n\n    // str.indexOf is faster than regex.test in this case\n    if (str.indexOf('&') != -1) {\n      str = str.replace(goog.string.AMP_RE_, '&amp;');\n    }\n    if (str.indexOf('<') != -1) {\n      str = str.replace(goog.string.LT_RE_, '&lt;');\n    }\n    if (str.indexOf('>') != -1) {\n      str = str.replace(goog.string.GT_RE_, '&gt;');\n    }\n    if (str.indexOf('\"') != -1) {\n      str = str.replace(goog.string.QUOT_RE_, '&quot;');\n    }\n    if (str.indexOf('\\'') != -1) {\n      str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');\n    }\n    if (str.indexOf('\\x00') != -1) {\n      str = str.replace(goog.string.NULL_RE_, '&#0;');\n    }\n    if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {\n      str = str.replace(goog.string.E_RE_, '&#101;');\n    }\n    return str;\n  }\n};\n\n\n/**\n * Regular expression that matches an ampersand, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.AMP_RE_ = /&/g;\n\n\n/**\n * Regular expression that matches a less than sign, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.LT_RE_ = /</g;\n\n\n/**\n * Regular expression that matches a greater than sign, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.GT_RE_ = />/g;\n\n\n/**\n * Regular expression that matches a double quote, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.QUOT_RE_ = /\"/g;\n\n\n/**\n * Regular expression that matches a single quote, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.SINGLE_QUOTE_RE_ = /'/g;\n\n\n/**\n * Regular expression that matches null character, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.NULL_RE_ = /\\x00/g;\n\n\n/**\n * Regular expression that matches a lowercase letter \"e\", for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.E_RE_ = /e/g;\n\n\n/**\n * Regular expression that matches any character that needs to be escaped.\n * @const {!RegExp}\n * @private\n */\ngoog.string.ALL_RE_ =\n    (goog.string.DETECT_DOUBLE_ESCAPING ? /[\\x00&<>\"'e]/ : /[\\x00&<>\"']/);\n\n\n/**\n * Unescapes an HTML string.\n *\n * @param {string} str The string to unescape.\n * @return {string} An unescaped copy of {@code str}.\n */\ngoog.string.unescapeEntities = function(str) {\n  if (goog.string.contains(str, '&')) {\n    // We are careful not to use a DOM if we do not have one or we explicitly\n    // requested non-DOM html unescaping.\n    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &&\n        'document' in goog.global) {\n      return goog.string.unescapeEntitiesUsingDom_(str);\n    } else {\n      // Fall back on pure XML entities\n      return goog.string.unescapePureXmlEntities_(str);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Unescapes a HTML string using the provided document.\n *\n * @param {string} str The string to unescape.\n * @param {!Document} document A document to use in escaping the string.\n * @return {string} An unescaped copy of {@code str}.\n */\ngoog.string.unescapeEntitiesWithDocument = function(str, document) {\n  if (goog.string.contains(str, '&')) {\n    return goog.string.unescapeEntitiesUsingDom_(str, document);\n  }\n  return str;\n};\n\n\n/**\n * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric\n * entities. This function is XSS-safe and whitespace-preserving.\n * @private\n * @param {string} str The string to unescape.\n * @param {Document=} opt_document An optional document to use for creating\n *     elements. If this is not specified then the default window.document\n *     will be used.\n * @return {string} The unescaped {@code str} string.\n */\ngoog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {\n  /** @type {!Object<string, string>} */\n  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"'};\n  var div;\n  if (opt_document) {\n    div = opt_document.createElement('div');\n  } else {\n    div = goog.global.document.createElement('div');\n  }\n  // Match as many valid entity characters as possible. If the actual entity\n  // happens to be shorter, it will still work as innerHTML will return the\n  // trailing characters unchanged. Since the entity characters do not include\n  // open angle bracket, there is no chance of XSS from the innerHTML use.\n  // Since no whitespace is passed to innerHTML, whitespace is preserved.\n  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {\n    // Check for cached entity.\n    var value = seen[s];\n    if (value) {\n      return value;\n    }\n    // Check for numeric entity.\n    if (entity.charAt(0) == '#') {\n      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.\n      var n = Number('0' + entity.substr(1));\n      if (!isNaN(n)) {\n        value = String.fromCharCode(n);\n      }\n    }\n    // Fall back to innerHTML otherwise.\n    if (!value) {\n      // Append a non-entity character to avoid a bug in Webkit that parses\n      // an invalid entity at the end of innerHTML text as the empty string.\n      div.innerHTML = s + ' ';\n      // Then remove the trailing character from the result.\n      value = div.firstChild.nodeValue.slice(0, -1);\n    }\n    // Cache and return.\n    return seen[s] = value;\n  });\n};\n\n\n/**\n * Unescapes XML entities.\n * @private\n * @param {string} str The string to unescape.\n * @return {string} An unescaped copy of {@code str}.\n */\ngoog.string.unescapePureXmlEntities_ = function(str) {\n  return str.replace(/&([^;]+);/g, function(s, entity) {\n    switch (entity) {\n      case 'amp':\n        return '&';\n      case 'lt':\n        return '<';\n      case 'gt':\n        return '>';\n      case 'quot':\n        return '\"';\n      default:\n        if (entity.charAt(0) == '#') {\n          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.\n          var n = Number('0' + entity.substr(1));\n          if (!isNaN(n)) {\n            return String.fromCharCode(n);\n          }\n        }\n        // For invalid entities we just return the entity\n        return s;\n    }\n  });\n};\n\n\n/**\n * Regular expression that matches an HTML entity.\n * See also HTML5: Tokenization / Tokenizing character references.\n * @private\n * @type {!RegExp}\n */\ngoog.string.HTML_ENTITY_PATTERN_ = /&([^;\\s<&]+);?/g;\n\n\n/**\n * Do escaping of whitespace to preserve spatial formatting. We use character\n * entity #160 to make it safer for xml.\n * @param {string} str The string in which to escape whitespace.\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\n * @return {string} An escaped copy of {@code str}.\n */\ngoog.string.whitespaceEscape = function(str, opt_xml) {\n  // This doesn't use goog.string.preserveSpaces for backwards compatibility.\n  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);\n};\n\n\n/**\n * Preserve spaces that would be otherwise collapsed in HTML by replacing them\n * with non-breaking space Unicode characters.\n * @param {string} str The string in which to preserve whitespace.\n * @return {string} A copy of {@code str} with preserved whitespace.\n */\ngoog.string.preserveSpaces = function(str) {\n  return str.replace(/(^|[\\n ]) /g, '$1' + goog.string.Unicode.NBSP);\n};\n\n\n/**\n * Strip quote characters around a string.  The second argument is a string of\n * characters to treat as quotes.  This can be a single character or a string of\n * multiple character and in that case each of those are treated as possible\n * quote characters. For example:\n *\n * <pre>\n * goog.string.stripQuotes('\"abc\"', '\"`') --> 'abc'\n * goog.string.stripQuotes('`abc`', '\"`') --> 'abc'\n * </pre>\n *\n * @param {string} str The string to strip.\n * @param {string} quoteChars The quote characters to strip.\n * @return {string} A copy of {@code str} without the quotes.\n */\ngoog.string.stripQuotes = function(str, quoteChars) {\n  var length = quoteChars.length;\n  for (var i = 0; i < length; i++) {\n    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);\n    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {\n      return str.substring(1, str.length - 1);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Truncates a string to a certain length and adds '...' if necessary.  The\n * length also accounts for the ellipsis, so a maximum length of 10 and a string\n * 'Hello World!' produces 'Hello W...'.\n * @param {string} str The string to truncate.\n * @param {number} chars Max number of characters.\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\n *     characters from being cut off in the middle.\n * @return {string} The truncated {@code str} string.\n */\ngoog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.unescapeEntities(str);\n  }\n\n  if (str.length > chars) {\n    str = str.substring(0, chars - 3) + '...';\n  }\n\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.htmlEscape(str);\n  }\n\n  return str;\n};\n\n\n/**\n * Truncate a string in the middle, adding \"...\" if necessary,\n * and favoring the beginning of the string.\n * @param {string} str The string to truncate the middle of.\n * @param {number} chars Max number of characters.\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\n *     characters from being cutoff in the middle.\n * @param {number=} opt_trailingChars Optional number of trailing characters to\n *     leave at the end of the string, instead of truncating as close to the\n *     middle as possible.\n * @return {string} A truncated copy of {@code str}.\n */\ngoog.string.truncateMiddle = function(\n    str, chars, opt_protectEscapedCharacters, opt_trailingChars) {\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.unescapeEntities(str);\n  }\n\n  if (opt_trailingChars && str.length > chars) {\n    if (opt_trailingChars > chars) {\n      opt_trailingChars = chars;\n    }\n    var endPoint = str.length - opt_trailingChars;\n    var startPoint = chars - opt_trailingChars;\n    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);\n  } else if (str.length > chars) {\n    // Favor the beginning of the string:\n    var half = Math.floor(chars / 2);\n    var endPos = str.length - half;\n    half += chars % 2;\n    str = str.substring(0, half) + '...' + str.substring(endPos);\n  }\n\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.htmlEscape(str);\n  }\n\n  return str;\n};\n\n\n/**\n * Special chars that need to be escaped for goog.string.quote.\n * @private {!Object<string, string>}\n */\ngoog.string.specialEscapeChars_ = {\n  '\\0': '\\\\0',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\x0B': '\\\\x0B',  // '\\v' is not supported in JScript\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\',\n  // To support the use case of embedding quoted strings inside of script\n  // tags, we have to make sure HTML comments and opening/closing script tags do\n  // not appear in the resulting string. The specific strings that must be\n  // escaped are documented at:\n  // http://www.w3.org/TR/html51/semantics.html#restrictions-for-contents-of-script-elements\n  '<': '\\x3c'\n};\n\n\n/**\n * Character mappings used internally for goog.string.escapeChar.\n * @private {!Object<string, string>}\n */\ngoog.string.jsEscapeCache_ = {\n  '\\'': '\\\\\\''\n};\n\n\n/**\n * Encloses a string in double quotes and escapes characters so that the\n * string is a valid JS string. The resulting string is safe to embed in\n * `<script>` tags as \"<\" is escaped.\n * @param {string} s The string to quote.\n * @return {string} A copy of {@code s} surrounded by double quotes.\n */\ngoog.string.quote = function(s) {\n  s = String(s);\n  var sb = ['\"'];\n  for (var i = 0; i < s.length; i++) {\n    var ch = s.charAt(i);\n    var cc = ch.charCodeAt(0);\n    sb[i + 1] = goog.string.specialEscapeChars_[ch] ||\n        ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));\n  }\n  sb.push('\"');\n  return sb.join('');\n};\n\n\n/**\n * Takes a string and returns the escaped string for that input string.\n * @param {string} str The string to escape.\n * @return {string} An escaped string representing {@code str}.\n */\ngoog.string.escapeString = function(str) {\n  var sb = [];\n  for (var i = 0; i < str.length; i++) {\n    sb[i] = goog.string.escapeChar(str.charAt(i));\n  }\n  return sb.join('');\n};\n\n\n/**\n * Takes a character and returns the escaped string for that character. For\n * example escapeChar(String.fromCharCode(15)) -> \"\\\\x0E\".\n * @param {string} c The character to escape.\n * @return {string} An escaped string representing {@code c}.\n */\ngoog.string.escapeChar = function(c) {\n  if (c in goog.string.jsEscapeCache_) {\n    return goog.string.jsEscapeCache_[c];\n  }\n\n  if (c in goog.string.specialEscapeChars_) {\n    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];\n  }\n\n  var rv = c;\n  var cc = c.charCodeAt(0);\n  if (cc > 31 && cc < 127) {\n    rv = c;\n  } else {\n    // tab is 9 but handled above\n    if (cc < 256) {\n      rv = '\\\\x';\n      if (cc < 16 || cc > 256) {\n        rv += '0';\n      }\n    } else {\n      rv = '\\\\u';\n      if (cc < 4096) {  // \\u1000\n        rv += '0';\n      }\n    }\n    rv += cc.toString(16).toUpperCase();\n  }\n\n  return goog.string.jsEscapeCache_[c] = rv;\n};\n\n\n/**\n * Determines whether a string contains a substring.\n * @param {string} str The string to search.\n * @param {string} subString The substring to search for.\n * @return {boolean} Whether {@code str} contains {@code subString}.\n */\ngoog.string.contains = function(str, subString) {\n  return str.indexOf(subString) != -1;\n};\n\n\n/**\n * Determines whether a string contains a substring, ignoring case.\n * @param {string} str The string to search.\n * @param {string} subString The substring to search for.\n * @return {boolean} Whether {@code str} contains {@code subString}.\n */\ngoog.string.caseInsensitiveContains = function(str, subString) {\n  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());\n};\n\n\n/**\n * Returns the non-overlapping occurrences of ss in s.\n * If either s or ss evalutes to false, then returns zero.\n * @param {string} s The string to look in.\n * @param {string} ss The string to look for.\n * @return {number} Number of occurrences of ss in s.\n */\ngoog.string.countOf = function(s, ss) {\n  return s && ss ? s.split(ss).length - 1 : 0;\n};\n\n\n/**\n * Removes a substring of a specified length at a specific\n * index in a string.\n * @param {string} s The base string from which to remove.\n * @param {number} index The index at which to remove the substring.\n * @param {number} stringLength The length of the substring to remove.\n * @return {string} A copy of {@code s} with the substring removed or the full\n *     string if nothing is removed or the input is invalid.\n */\ngoog.string.removeAt = function(s, index, stringLength) {\n  var resultStr = s;\n  // If the index is greater or equal to 0 then remove substring\n  if (index >= 0 && index < s.length && stringLength > 0) {\n    resultStr = s.substr(0, index) +\n        s.substr(index + stringLength, s.length - index - stringLength);\n  }\n  return resultStr;\n};\n\n\n/**\n * Removes the first occurrence of a substring from a string.\n * @param {string} str The base string from which to remove.\n * @param {string} substr The string to remove.\n * @return {string} A copy of {@code str} with {@code substr} removed or the\n *     full string if nothing is removed.\n */\ngoog.string.remove = function(str, substr) {\n  return str.replace(substr, '');\n};\n\n\n/**\n *  Removes all occurrences of a substring from a string.\n *  @param {string} s The base string from which to remove.\n *  @param {string} ss The string to remove.\n *  @return {string} A copy of {@code s} with {@code ss} removed or the full\n *      string if nothing is removed.\n */\ngoog.string.removeAll = function(s, ss) {\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\n  return s.replace(re, '');\n};\n\n\n/**\n *  Replaces all occurrences of a substring of a string with a new substring.\n *  @param {string} s The base string from which to remove.\n *  @param {string} ss The string to replace.\n *  @param {string} replacement The replacement string.\n *  @return {string} A copy of {@code s} with {@code ss} replaced by\n *      {@code replacement} or the original string if nothing is replaced.\n */\ngoog.string.replaceAll = function(s, ss, replacement) {\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\n  return s.replace(re, replacement.replace(/\\$/g, '$$$$'));\n};\n\n\n/**\n * Escapes characters in the string that are not safe to use in a RegExp.\n * @param {*} s The string to escape. If not a string, it will be casted\n *     to one.\n * @return {string} A RegExp safe, escaped copy of {@code s}.\n */\ngoog.string.regExpEscape = function(s) {\n  return String(s)\n      .replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1')\n      .replace(/\\x08/g, '\\\\x08');\n};\n\n\n/**\n * Repeats a string n times.\n * @param {string} string The string to repeat.\n * @param {number} length The number of times to repeat.\n * @return {string} A string containing {@code length} repetitions of\n *     {@code string}.\n */\ngoog.string.repeat = (String.prototype.repeat) ? function(string, length) {\n  // The native method is over 100 times faster than the alternative.\n  return string.repeat(length);\n} : function(string, length) {\n  return new Array(length + 1).join(string);\n};\n\n\n/**\n * Pads number to given length and optionally rounds it to a given precision.\n * For example:\n * <pre>padNumber(1.25, 2, 3) -> '01.250'\n * padNumber(1.25, 2) -> '01.25'\n * padNumber(1.25, 2, 1) -> '01.3'\n * padNumber(1.25, 0) -> '1.25'</pre>\n *\n * @param {number} num The number to pad.\n * @param {number} length The desired length.\n * @param {number=} opt_precision The desired precision.\n * @return {string} {@code num} as a string with the given options.\n */\ngoog.string.padNumber = function(num, length, opt_precision) {\n  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);\n  var index = s.indexOf('.');\n  if (index == -1) {\n    index = s.length;\n  }\n  return goog.string.repeat('0', Math.max(0, length - index)) + s;\n};\n\n\n/**\n * Returns a string representation of the given object, with\n * null and undefined being returned as the empty string.\n *\n * @param {*} obj The object to convert.\n * @return {string} A string representation of the {@code obj}.\n */\ngoog.string.makeSafe = function(obj) {\n  return obj == null ? '' : String(obj);\n};\n\n\n/**\n * Concatenates string expressions. This is useful\n * since some browsers are very inefficient when it comes to using plus to\n * concat strings. Be careful when using null and undefined here since\n * these will not be included in the result. If you need to represent these\n * be sure to cast the argument to a String first.\n * For example:\n * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'\n * buildString(null, undefined) -> ''\n * </pre>\n * @param {...*} var_args A list of strings to concatenate. If not a string,\n *     it will be casted to one.\n * @return {string} The concatenation of {@code var_args}.\n */\ngoog.string.buildString = function(var_args) {\n  return Array.prototype.join.call(arguments, '');\n};\n\n\n/**\n * Returns a string with at least 64-bits of randomness.\n *\n * Doesn't trust Javascript's random function entirely. Uses a combination of\n * random and current timestamp, and then encodes the string in base-36 to\n * make it shorter.\n *\n * @return {string} A random string, e.g. sn1s7vb4gcic.\n */\ngoog.string.getRandomString = function() {\n  var x = 2147483648;\n  return Math.floor(Math.random() * x).toString(36) +\n      Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);\n};\n\n\n/**\n * Compares two version numbers.\n *\n * @param {string|number} version1 Version of first item.\n * @param {string|number} version2 Version of second item.\n *\n * @return {number}  1 if {@code version1} is higher.\n *                   0 if arguments are equal.\n *                  -1 if {@code version2} is higher.\n */\ngoog.string.compareVersions = function(version1, version2) {\n  var order = 0;\n  // Trim leading and trailing whitespace and split the versions into\n  // subversions.\n  var v1Subs = goog.string.trim(String(version1)).split('.');\n  var v2Subs = goog.string.trim(String(version2)).split('.');\n  var subCount = Math.max(v1Subs.length, v2Subs.length);\n\n  // Iterate over the subversions, as long as they appear to be equivalent.\n  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {\n    var v1Sub = v1Subs[subIdx] || '';\n    var v2Sub = v2Subs[subIdx] || '';\n\n    do {\n      // Split the subversions into pairs of numbers and qualifiers (like 'b').\n      // Two different RegExp objects are use to make it clear the code\n      // is side-effect free\n      var v1Comp = /(\\d*)(\\D*)(.*)/.exec(v1Sub) || ['', '', '', ''];\n      var v2Comp = /(\\d*)(\\D*)(.*)/.exec(v2Sub) || ['', '', '', ''];\n      // Break if there are no more matches.\n      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {\n        break;\n      }\n\n      // Parse the numeric part of the subversion. A missing number is\n      // equivalent to 0.\n      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);\n      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);\n\n      // Compare the subversion components. The number has the highest\n      // precedence. Next, if the numbers are equal, a subversion without any\n      // qualifier is always higher than a subversion with any qualifier. Next,\n      // the qualifiers are compared as strings.\n      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||\n          goog.string.compareElements_(\n              v1Comp[2].length == 0, v2Comp[2].length == 0) ||\n          goog.string.compareElements_(v1Comp[2], v2Comp[2]);\n      // Stop as soon as an inequality is discovered.\n\n      v1Sub = v1Comp[3];\n      v2Sub = v2Comp[3];\n    } while (order == 0);\n  }\n\n  return order;\n};\n\n\n/**\n * Compares elements of a version number.\n *\n * @param {string|number|boolean} left An element from a version number.\n * @param {string|number|boolean} right An element from a version number.\n *\n * @return {number}  1 if {@code left} is higher.\n *                   0 if arguments are equal.\n *                  -1 if {@code right} is higher.\n * @private\n */\ngoog.string.compareElements_ = function(left, right) {\n  if (left < right) {\n    return -1;\n  } else if (left > right) {\n    return 1;\n  }\n  return 0;\n};\n\n\n/**\n * String hash function similar to java.lang.String.hashCode().\n * The hash code for a string is computed as\n * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n * where s[i] is the ith character of the string and n is the length of\n * the string. We mod the result to make it between 0 (inclusive) and 2^32\n * (exclusive).\n * @param {string} str A string.\n * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32\n *  (exclusive). The empty string returns 0.\n */\ngoog.string.hashCode = function(str) {\n  var result = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Normalize to 4 byte range, 0 ... 2^32.\n    result = (31 * result + str.charCodeAt(i)) >>> 0;\n  }\n  return result;\n};\n\n\n/**\n * The most recent unique ID. |0 is equivalent to Math.floor in this case.\n * @type {number}\n * @private\n */\ngoog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;\n\n\n/**\n * Generates and returns a string which is unique in the current document.\n * This is useful, for example, to create unique IDs for DOM elements.\n * @return {string} A unique id.\n */\ngoog.string.createUniqueString = function() {\n  return 'goog_' + goog.string.uniqueStringCounter_++;\n};\n\n\n/**\n * Converts the supplied string to a number, which may be Infinity or NaN.\n * This function strips whitespace: (toNumber(' 123') === 123)\n * This function accepts scientific notation: (toNumber('1e1') === 10)\n *\n * This is better than Javascript's built-in conversions because, sadly:\n *     (Number(' ') === 0) and (parseFloat('123a') === 123)\n *\n * @param {string} str The string to convert.\n * @return {number} The number the supplied string represents, or NaN.\n */\ngoog.string.toNumber = function(str) {\n  var num = Number(str);\n  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {\n    return NaN;\n  }\n  return num;\n};\n\n\n/**\n * Returns whether the given string is lower camel case (e.g. \"isFooBar\").\n *\n * Note that this assumes the string is entirely letters.\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\n *\n * @param {string} str String to test.\n * @return {boolean} Whether the string is lower camel case.\n */\ngoog.string.isLowerCamelCase = function(str) {\n  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);\n};\n\n\n/**\n * Returns whether the given string is upper camel case (e.g. \"FooBarBaz\").\n *\n * Note that this assumes the string is entirely letters.\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\n *\n * @param {string} str String to test.\n * @return {boolean} Whether the string is upper camel case.\n */\ngoog.string.isUpperCamelCase = function(str) {\n  return /^([A-Z][a-z]*)+$/.test(str);\n};\n\n\n/**\n * Converts a string from selector-case to camelCase (e.g. from\n * \"multi-part-string\" to \"multiPartString\"), useful for converting\n * CSS selectors and HTML dataset keys to their equivalent JS properties.\n * @param {string} str The string in selector-case form.\n * @return {string} The string in camelCase form.\n */\ngoog.string.toCamelCase = function(str) {\n  return String(str).replace(\n      /\\-([a-z])/g, function(all, match) { return match.toUpperCase(); });\n};\n\n\n/**\n * Converts a string from camelCase to selector-case (e.g. from\n * \"multiPartString\" to \"multi-part-string\"), useful for converting JS\n * style and dataset properties to equivalent CSS selectors and HTML keys.\n * @param {string} str The string in camelCase form.\n * @return {string} The string in selector-case form.\n */\ngoog.string.toSelectorCase = function(str) {\n  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n\n/**\n * Converts a string into TitleCase. First character of the string is always\n * capitalized in addition to the first letter of every subsequent word.\n * Words are delimited by one or more whitespaces by default. Custom delimiters\n * can optionally be specified to replace the default, which doesn't preserve\n * whitespace delimiters and instead must be explicitly included if needed.\n *\n * Default delimiter => \" \":\n *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'\n *    goog.string.toTitleCase('one two three')  => 'One Two Three'\n *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '\n *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'\n *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'\n *\n * Custom delimiter => \"_-.\":\n *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'\n *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'\n *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '\n *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'\n *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'\n *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'\n *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'\n *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'\n *\n * @param {string} str String value in camelCase form.\n * @param {string=} opt_delimiters Custom delimiter character set used to\n *      distinguish words in the string value. Each character represents a\n *      single delimiter. When provided, default whitespace delimiter is\n *      overridden and must be explicitly included if needed.\n * @return {string} String value in TitleCase form.\n */\ngoog.string.toTitleCase = function(str, opt_delimiters) {\n  var delimiters = goog.isString(opt_delimiters) ?\n      goog.string.regExpEscape(opt_delimiters) :\n      '\\\\s';\n\n  // For IE8, we need to prevent using an empty character set. Otherwise,\n  // incorrect matching will occur.\n  delimiters = delimiters ? '|[' + delimiters + ']+' : '';\n\n  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');\n  return str.replace(\n      regexp, function(all, p1, p2) { return p1 + p2.toUpperCase(); });\n};\n\n\n/**\n * Capitalizes a string, i.e. converts the first letter to uppercase\n * and all other letters to lowercase, e.g.:\n *\n * goog.string.capitalize('one')     => 'One'\n * goog.string.capitalize('ONE')     => 'One'\n * goog.string.capitalize('one two') => 'One two'\n *\n * Note that this function does not trim initial whitespace.\n *\n * @param {string} str String value to capitalize.\n * @return {string} String value with first letter in uppercase.\n */\ngoog.string.capitalize = function(str) {\n  return String(str.charAt(0)).toUpperCase() +\n      String(str.substr(1)).toLowerCase();\n};\n\n\n/**\n * Parse a string in decimal or hexidecimal ('0xFFFF') form.\n *\n * To parse a particular radix, please use parseInt(string, radix) directly. See\n * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt\n *\n * This is a wrapper for the built-in parseInt function that will only parse\n * numbers as base 10 or base 16.  Some JS implementations assume strings\n * starting with \"0\" are intended to be octal. ES3 allowed but discouraged\n * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.\n *\n * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj\n *\n * @param {string|number|null|undefined} value The value to be parsed.\n * @return {number} The number, parsed. If the string failed to parse, this\n *     will be NaN.\n */\ngoog.string.parseInt = function(value) {\n  // Force finite numbers to strings.\n  if (isFinite(value)) {\n    value = String(value);\n  }\n\n  if (goog.isString(value)) {\n    // If the string starts with '0x' or '-0x', parse as hex.\n    return /^\\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);\n  }\n\n  return NaN;\n};\n\n\n/**\n * Splits a string on a separator a limited number of times.\n *\n * This implementation is more similar to Python or Java, where the limit\n * parameter specifies the maximum number of splits rather than truncating\n * the number of results.\n *\n * See http://docs.python.org/2/library/stdtypes.html#str.split\n * See JavaDoc: http://goo.gl/F2AsY\n * See Mozilla reference: http://goo.gl/dZdZs\n *\n * @param {string} str String to split.\n * @param {string} separator The separator.\n * @param {number} limit The limit to the number of splits. The resulting array\n *     will have a maximum length of limit+1.  Negative numbers are the same\n *     as zero.\n * @return {!Array<string>} The string, split.\n */\ngoog.string.splitLimit = function(str, separator, limit) {\n  var parts = str.split(separator);\n  var returnVal = [];\n\n  // Only continue doing this while we haven't hit the limit and we have\n  // parts left.\n  while (limit > 0 && parts.length) {\n    returnVal.push(parts.shift());\n    limit--;\n  }\n\n  // If there are remaining parts, append them to the end.\n  if (parts.length) {\n    returnVal.push(parts.join(separator));\n  }\n\n  return returnVal;\n};\n\n\n/**\n * Finds the characters to the right of the last instance of any separator\n *\n * This function is similar to goog.string.path.baseName, except it can take a\n * list of characters to split the string on. It will return the rightmost\n * grouping of characters to the right of any separator as a left-to-right\n * oriented string.\n *\n * @see goog.string.path.baseName\n * @param {string} str The string\n * @param {string|!Array<string>} separators A list of separator characters\n * @return {string} The last part of the string with respect to the separators\n */\ngoog.string.lastComponent = function(str, separators) {\n  if (!separators) {\n    return str;\n  } else if (typeof separators == 'string') {\n    separators = [separators];\n  }\n\n  var lastSeparatorIndex = -1;\n  for (var i = 0; i < separators.length; i++) {\n    if (separators[i] == '') {\n      continue;\n    }\n    var currentSeparatorIndex = str.lastIndexOf(separators[i]);\n    if (currentSeparatorIndex > lastSeparatorIndex) {\n      lastSeparatorIndex = currentSeparatorIndex;\n    }\n  }\n  if (lastSeparatorIndex == -1) {\n    return str;\n  }\n  return str.slice(lastSeparatorIndex + 1);\n};\n\n\n/**\n * Computes the Levenshtein edit distance between two strings.\n * @param {string} a\n * @param {string} b\n * @return {number} The edit distance between the two strings.\n */\ngoog.string.editDistance = function(a, b) {\n  var v0 = [];\n  var v1 = [];\n\n  if (a == b) {\n    return 0;\n  }\n\n  if (!a.length || !b.length) {\n    return Math.max(a.length, b.length);\n  }\n\n  for (var i = 0; i < b.length + 1; i++) {\n    v0[i] = i;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    v1[0] = i + 1;\n\n    for (var j = 0; j < b.length; j++) {\n      var cost = Number(a[i] != b[j]);\n      // Cost for the substring is the minimum of adding one character, removing\n      // one character, or a swap.\n      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);\n    }\n\n    for (var j = 0; j < v0.length; j++) {\n      v0[j] = v1[j];\n    }\n  }\n\n  return v1[b.length];\n};\n","~:compiled-at",1574163695943,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.string.string.js\",\n\"lineCount\":901,\n\"mappings\":\"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\",\n\"sources\":[\"goog/string/string.js\"],\n\"sourcesContent\":[\"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Utilities for string manipulation.\\n * @author arv@google.com (Erik Arvidsson)\\n */\\n\\n\\n/**\\n * Namespace for string utilities\\n */\\ngoog.provide('goog.string');\\ngoog.provide('goog.string.Unicode');\\n\\n\\n/**\\n * @define {boolean} Enables HTML escaping of lowercase letter \\\"e\\\" which helps\\n * with detection of double-escaping as this letter is frequently used.\\n */\\ngoog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);\\n\\n\\n/**\\n * @define {boolean} Whether to force non-dom html unescaping.\\n */\\ngoog.define('goog.string.FORCE_NON_DOM_HTML_UNESCAPING', false);\\n\\n\\n/**\\n * Common Unicode string characters.\\n * @enum {string}\\n */\\ngoog.string.Unicode = {\\n  NBSP: '\\\\xa0'\\n};\\n\\n\\n/**\\n * Fast prefix-checker.\\n * @param {string} str The string to check.\\n * @param {string} prefix A string to look for at the start of {@code str}.\\n * @return {boolean} True if {@code str} begins with {@code prefix}.\\n */\\ngoog.string.startsWith = function(str, prefix) {\\n  return str.lastIndexOf(prefix, 0) == 0;\\n};\\n\\n\\n/**\\n * Fast suffix-checker.\\n * @param {string} str The string to check.\\n * @param {string} suffix A string to look for at the end of {@code str}.\\n * @return {boolean} True if {@code str} ends with {@code suffix}.\\n */\\ngoog.string.endsWith = function(str, suffix) {\\n  var l = str.length - suffix.length;\\n  return l >= 0 && str.indexOf(suffix, l) == l;\\n};\\n\\n\\n/**\\n * Case-insensitive prefix-checker.\\n * @param {string} str The string to check.\\n * @param {string} prefix  A string to look for at the end of {@code str}.\\n * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring\\n *     case).\\n */\\ngoog.string.caseInsensitiveStartsWith = function(str, prefix) {\\n  return goog.string.caseInsensitiveCompare(\\n             prefix, str.substr(0, prefix.length)) == 0;\\n};\\n\\n\\n/**\\n * Case-insensitive suffix-checker.\\n * @param {string} str The string to check.\\n * @param {string} suffix A string to look for at the end of {@code str}.\\n * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring\\n *     case).\\n */\\ngoog.string.caseInsensitiveEndsWith = function(str, suffix) {\\n  return (\\n      goog.string.caseInsensitiveCompare(\\n          suffix, str.substr(str.length - suffix.length, suffix.length)) == 0);\\n};\\n\\n\\n/**\\n * Case-insensitive equality checker.\\n * @param {string} str1 First string to check.\\n * @param {string} str2 Second string to check.\\n * @return {boolean} True if {@code str1} and {@code str2} are the same string,\\n *     ignoring case.\\n */\\ngoog.string.caseInsensitiveEquals = function(str1, str2) {\\n  return str1.toLowerCase() == str2.toLowerCase();\\n};\\n\\n\\n/**\\n * Does simple python-style string substitution.\\n * subs(\\\"foo%s hot%s\\\", \\\"bar\\\", \\\"dog\\\") becomes \\\"foobar hotdog\\\".\\n * @param {string} str The string containing the pattern.\\n * @param {...*} var_args The items to substitute into the pattern.\\n * @return {string} A copy of {@code str} in which each occurrence of\\n *     {@code %s} has been replaced an argument from {@code var_args}.\\n */\\ngoog.string.subs = function(str, var_args) {\\n  var splitParts = str.split('%s');\\n  var returnString = '';\\n\\n  var subsArguments = Array.prototype.slice.call(arguments, 1);\\n  while (subsArguments.length &&\\n         // Replace up to the last split part. We are inserting in the\\n         // positions between split parts.\\n         splitParts.length > 1) {\\n    returnString += splitParts.shift() + subsArguments.shift();\\n  }\\n\\n  return returnString + splitParts.join('%s');  // Join unused '%s'\\n};\\n\\n\\n/**\\n * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines\\n * and tabs) to a single space, and strips leading and trailing whitespace.\\n * @param {string} str Input string.\\n * @return {string} A copy of {@code str} with collapsed whitespace.\\n */\\ngoog.string.collapseWhitespace = function(str) {\\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\\\s character\\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\\n  // include it in the regexp to enforce consistent cross-browser behavior.\\n  return str.replace(/[\\\\s\\\\xa0]+/g, ' ').replace(/^\\\\s+|\\\\s+$/g, '');\\n};\\n\\n\\n/**\\n * Checks if a string is empty or contains only whitespaces.\\n * @param {string} str The string to check.\\n * @return {boolean} Whether {@code str} is empty or whitespace only.\\n */\\ngoog.string.isEmptyOrWhitespace = function(str) {\\n  // testing length == 0 first is actually slower in all browsers (about the\\n  // same in Opera).\\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\\\s character\\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\\n  // include it in the regexp to enforce consistent cross-browser behavior.\\n  return /^[\\\\s\\\\xa0]*$/.test(str);\\n};\\n\\n\\n/**\\n * Checks if a string is empty.\\n * @param {string} str The string to check.\\n * @return {boolean} Whether {@code str} is empty.\\n */\\ngoog.string.isEmptyString = function(str) {\\n  return str.length == 0;\\n};\\n\\n\\n/**\\n * Checks if a string is empty or contains only whitespaces.\\n *\\n * @param {string} str The string to check.\\n * @return {boolean} Whether {@code str} is empty or whitespace only.\\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\\n */\\ngoog.string.isEmpty = goog.string.isEmptyOrWhitespace;\\n\\n\\n/**\\n * Checks if a string is null, undefined, empty or contains only whitespaces.\\n * @param {*} str The string to check.\\n * @return {boolean} Whether {@code str} is null, undefined, empty, or\\n *     whitespace only.\\n * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))\\n *     instead.\\n */\\ngoog.string.isEmptyOrWhitespaceSafe = function(str) {\\n  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));\\n};\\n\\n\\n/**\\n * Checks if a string is null, undefined, empty or contains only whitespaces.\\n *\\n * @param {*} str The string to check.\\n * @return {boolean} Whether {@code str} is null, undefined, empty, or\\n *     whitespace only.\\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\\n */\\ngoog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;\\n\\n\\n/**\\n * Checks if a string is all breaking whitespace.\\n * @param {string} str The string to check.\\n * @return {boolean} Whether the string is all breaking whitespace.\\n */\\ngoog.string.isBreakingWhitespace = function(str) {\\n  return !/[^\\\\t\\\\n\\\\r ]/.test(str);\\n};\\n\\n\\n/**\\n * Checks if a string contains all letters.\\n * @param {string} str string to check.\\n * @return {boolean} True if {@code str} consists entirely of letters.\\n */\\ngoog.string.isAlpha = function(str) {\\n  return !/[^a-zA-Z]/.test(str);\\n};\\n\\n\\n/**\\n * Checks if a string contains only numbers.\\n * @param {*} str string to check. If not a string, it will be\\n *     casted to one.\\n * @return {boolean} True if {@code str} is numeric.\\n */\\ngoog.string.isNumeric = function(str) {\\n  return !/[^0-9]/.test(str);\\n};\\n\\n\\n/**\\n * Checks if a string contains only numbers or letters.\\n * @param {string} str string to check.\\n * @return {boolean} True if {@code str} is alphanumeric.\\n */\\ngoog.string.isAlphaNumeric = function(str) {\\n  return !/[^a-zA-Z0-9]/.test(str);\\n};\\n\\n\\n/**\\n * Checks if a character is a space character.\\n * @param {string} ch Character to check.\\n * @return {boolean} True if {@code ch} is a space.\\n */\\ngoog.string.isSpace = function(ch) {\\n  return ch == ' ';\\n};\\n\\n\\n/**\\n * Checks if a character is a valid unicode character.\\n * @param {string} ch Character to check.\\n * @return {boolean} True if {@code ch} is a valid unicode character.\\n */\\ngoog.string.isUnicodeChar = function(ch) {\\n  return ch.length == 1 && ch >= ' ' && ch <= '~' ||\\n      ch >= '\\\\u0080' && ch <= '\\\\uFFFD';\\n};\\n\\n\\n/**\\n * Takes a string and replaces newlines with a space. Multiple lines are\\n * replaced with a single space.\\n * @param {string} str The string from which to strip newlines.\\n * @return {string} A copy of {@code str} stripped of newlines.\\n */\\ngoog.string.stripNewlines = function(str) {\\n  return str.replace(/(\\\\r\\\\n|\\\\r|\\\\n)+/g, ' ');\\n};\\n\\n\\n/**\\n * Replaces Windows and Mac new lines with unix style: \\\\r or \\\\r\\\\n with \\\\n.\\n * @param {string} str The string to in which to canonicalize newlines.\\n * @return {string} {@code str} A copy of {@code} with canonicalized newlines.\\n */\\ngoog.string.canonicalizeNewlines = function(str) {\\n  return str.replace(/(\\\\r\\\\n|\\\\r|\\\\n)/g, '\\\\n');\\n};\\n\\n\\n/**\\n * Normalizes whitespace in a string, replacing all whitespace chars with\\n * a space.\\n * @param {string} str The string in which to normalize whitespace.\\n * @return {string} A copy of {@code str} with all whitespace normalized.\\n */\\ngoog.string.normalizeWhitespace = function(str) {\\n  return str.replace(/\\\\xa0|\\\\s/g, ' ');\\n};\\n\\n\\n/**\\n * Normalizes spaces in a string, replacing all consecutive spaces and tabs\\n * with a single space. Replaces non-breaking space with a space.\\n * @param {string} str The string in which to normalize spaces.\\n * @return {string} A copy of {@code str} with all consecutive spaces and tabs\\n *    replaced with a single space.\\n */\\ngoog.string.normalizeSpaces = function(str) {\\n  return str.replace(/\\\\xa0|[ \\\\t]+/g, ' ');\\n};\\n\\n\\n/**\\n * Removes the breaking spaces from the left and right of the string and\\n * collapses the sequences of breaking spaces in the middle into single spaces.\\n * The original and the result strings render the same way in HTML.\\n * @param {string} str A string in which to collapse spaces.\\n * @return {string} Copy of the string with normalized breaking spaces.\\n */\\ngoog.string.collapseBreakingSpaces = function(str) {\\n  return str.replace(/[\\\\t\\\\r\\\\n ]+/g, ' ')\\n      .replace(/^[\\\\t\\\\r\\\\n ]+|[\\\\t\\\\r\\\\n ]+$/g, '');\\n};\\n\\n\\n/**\\n * Trims white spaces to the left and right of a string.\\n * @param {string} str The string to trim.\\n * @return {string} A trimmed copy of {@code str}.\\n */\\ngoog.string.trim =\\n    (goog.TRUSTED_SITE && String.prototype.trim) ? function(str) {\\n      return str.trim();\\n    } : function(str) {\\n      // Since IE doesn't include non-breaking-space (0xa0) in their \\\\s\\n      // character class (as required by section 7.2 of the ECMAScript spec),\\n      // we explicitly include it in the regexp to enforce consistent\\n      // cross-browser behavior.\\n      return str.replace(/^[\\\\s\\\\xa0]+|[\\\\s\\\\xa0]+$/g, '');\\n    };\\n\\n\\n/**\\n * Trims whitespaces at the left end of a string.\\n * @param {string} str The string to left trim.\\n * @return {string} A trimmed copy of {@code str}.\\n */\\ngoog.string.trimLeft = function(str) {\\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\\\s character\\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\\n  // include it in the regexp to enforce consistent cross-browser behavior.\\n  return str.replace(/^[\\\\s\\\\xa0]+/, '');\\n};\\n\\n\\n/**\\n * Trims whitespaces at the right end of a string.\\n * @param {string} str The string to right trim.\\n * @return {string} A trimmed copy of {@code str}.\\n */\\ngoog.string.trimRight = function(str) {\\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\\\s character\\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\\n  // include it in the regexp to enforce consistent cross-browser behavior.\\n  return str.replace(/[\\\\s\\\\xa0]+$/, '');\\n};\\n\\n\\n/**\\n * A string comparator that ignores case.\\n * -1 = str1 less than str2\\n *  0 = str1 equals str2\\n *  1 = str1 greater than str2\\n *\\n * @param {string} str1 The string to compare.\\n * @param {string} str2 The string to compare {@code str1} to.\\n * @return {number} The comparator result, as described above.\\n */\\ngoog.string.caseInsensitiveCompare = function(str1, str2) {\\n  var test1 = String(str1).toLowerCase();\\n  var test2 = String(str2).toLowerCase();\\n\\n  if (test1 < test2) {\\n    return -1;\\n  } else if (test1 == test2) {\\n    return 0;\\n  } else {\\n    return 1;\\n  }\\n};\\n\\n\\n/**\\n * Compares two strings interpreting their numeric substrings as numbers.\\n *\\n * @param {string} str1 First string.\\n * @param {string} str2 Second string.\\n * @param {!RegExp} tokenizerRegExp Splits a string into substrings of\\n *     non-negative integers, non-numeric characters and optionally fractional\\n *     numbers starting with a decimal point.\\n * @return {number} Negative if str1 < str2, 0 is str1 == str2, positive if\\n *     str1 > str2.\\n * @private\\n */\\ngoog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {\\n  if (str1 == str2) {\\n    return 0;\\n  }\\n  if (!str1) {\\n    return -1;\\n  }\\n  if (!str2) {\\n    return 1;\\n  }\\n\\n  // Using match to split the entire string ahead of time turns out to be faster\\n  // for most inputs than using RegExp.exec or iterating over each character.\\n  var tokens1 = str1.toLowerCase().match(tokenizerRegExp);\\n  var tokens2 = str2.toLowerCase().match(tokenizerRegExp);\\n\\n  var count = Math.min(tokens1.length, tokens2.length);\\n\\n  for (var i = 0; i < count; i++) {\\n    var a = tokens1[i];\\n    var b = tokens2[i];\\n\\n    // Compare pairs of tokens, returning if one token sorts before the other.\\n    if (a != b) {\\n      // Only if both tokens are integers is a special comparison required.\\n      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').\\n      var num1 = parseInt(a, 10);\\n      if (!isNaN(num1)) {\\n        var num2 = parseInt(b, 10);\\n        if (!isNaN(num2) && num1 - num2) {\\n          return num1 - num2;\\n        }\\n      }\\n      return a < b ? -1 : 1;\\n    }\\n  }\\n\\n  // If one string is a substring of the other, the shorter string sorts first.\\n  if (tokens1.length != tokens2.length) {\\n    return tokens1.length - tokens2.length;\\n  }\\n\\n  // The two strings must be equivalent except for case (perfect equality is\\n  // tested at the head of the function.) Revert to default ASCII string\\n  // comparison to stabilize the sort.\\n  return str1 < str2 ? -1 : 1;\\n};\\n\\n\\n/**\\n * String comparison function that handles non-negative integer numbers in a\\n * way humans might expect. Using this function, the string 'File 2.jpg' sorts\\n * before 'File 10.jpg', and 'Version 1.9' before 'Version 1.10'. The comparison\\n * is mostly case-insensitive, though strings that are identical except for case\\n * are sorted with the upper-case strings before lower-case.\\n *\\n * This comparison function is up to 50x slower than either the default or the\\n * case-insensitive compare. It should not be used in time-critical code, but\\n * should be fast enough to sort several hundred short strings (like filenames)\\n * with a reasonable delay.\\n *\\n * @param {string} str1 The string to compare in a numerically sensitive way.\\n * @param {string} str2 The string to compare {@code str1} to.\\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\\n *     0 if str1 > str2.\\n */\\ngoog.string.intAwareCompare = function(str1, str2) {\\n  return goog.string.numberAwareCompare_(str1, str2, /\\\\d+|\\\\D+/g);\\n};\\n\\n\\n/**\\n * String comparison function that handles non-negative integer and fractional\\n * numbers in a way humans might expect. Using this function, the string\\n * 'File 2.jpg' sorts before 'File 10.jpg', and '3.14' before '3.2'. Equivalent\\n * to {@link goog.string.intAwareCompare} apart from the way how it interprets\\n * dots.\\n *\\n * @param {string} str1 The string to compare in a numerically sensitive way.\\n * @param {string} str2 The string to compare {@code str1} to.\\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\\n *     0 if str1 > str2.\\n */\\ngoog.string.floatAwareCompare = function(str1, str2) {\\n  return goog.string.numberAwareCompare_(str1, str2, /\\\\d+|\\\\.\\\\d+|\\\\D+/g);\\n};\\n\\n\\n/**\\n * Alias for {@link goog.string.floatAwareCompare}.\\n *\\n * @param {string} str1\\n * @param {string} str2\\n * @return {number}\\n */\\ngoog.string.numerateCompare = goog.string.floatAwareCompare;\\n\\n\\n/**\\n * URL-encodes a string\\n * @param {*} str The string to url-encode.\\n * @return {string} An encoded copy of {@code str} that is safe for urls.\\n *     Note that '#', ':', and other characters used to delimit portions\\n *     of URLs *will* be encoded.\\n */\\ngoog.string.urlEncode = function(str) {\\n  return encodeURIComponent(String(str));\\n};\\n\\n\\n/**\\n * URL-decodes the string. We need to specially handle '+'s because\\n * the javascript library doesn't convert them to spaces.\\n * @param {string} str The string to url decode.\\n * @return {string} The decoded {@code str}.\\n */\\ngoog.string.urlDecode = function(str) {\\n  return decodeURIComponent(str.replace(/\\\\+/g, ' '));\\n};\\n\\n\\n/**\\n * Converts \\\\n to <br>s or <br />s.\\n * @param {string} str The string in which to convert newlines.\\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\\n * @return {string} A copy of {@code str} with converted newlines.\\n */\\ngoog.string.newLineToBr = function(str, opt_xml) {\\n  return str.replace(/(\\\\r\\\\n|\\\\r|\\\\n)/g, opt_xml ? '<br />' : '<br>');\\n};\\n\\n\\n/**\\n * Escapes double quote '\\\"' and single quote '\\\\'' characters in addition to\\n * '&', '<', and '>' so that a string can be included in an HTML tag attribute\\n * value within double or single quotes.\\n *\\n * It should be noted that > doesn't need to be escaped for the HTML or XML to\\n * be valid, but it has been decided to escape it for consistency with other\\n * implementations.\\n *\\n * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the\\n * lowercase letter \\\"e\\\".\\n *\\n * NOTE(user):\\n * HtmlEscape is often called during the generation of large blocks of HTML.\\n * Using statics for the regular expressions and strings is an optimization\\n * that can more than half the amount of time IE spends in this function for\\n * large apps, since strings and regexes both contribute to GC allocations.\\n *\\n * Testing for the presence of a character before escaping increases the number\\n * of function calls, but actually provides a speed increase for the average\\n * case -- since the average case often doesn't require the escaping of all 4\\n * characters and indexOf() is much cheaper than replace().\\n * The worst case does suffer slightly from the additional calls, therefore the\\n * opt_isLikelyToContainHtmlChars option has been included for situations\\n * where all 4 HTML entities are very likely to be present and need escaping.\\n *\\n * Some benchmarks (times tended to fluctuate +-0.05ms):\\n *                                     FireFox                     IE6\\n * (no chars / average (mix of cases) / all 4 chars)\\n * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80\\n * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84\\n * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85\\n *\\n * An additional advantage of checking if replace actually needs to be called\\n * is a reduction in the number of object allocations, so as the size of the\\n * application grows the difference between the various methods would increase.\\n *\\n * @param {string} str string to be escaped.\\n * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see\\n *     if the character needs replacing - use this option if you expect each of\\n *     the characters to appear often. Leave false if you expect few html\\n *     characters to occur in your strings, such as if you are escaping HTML.\\n * @return {string} An escaped copy of {@code str}.\\n */\\ngoog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {\\n\\n  if (opt_isLikelyToContainHtmlChars) {\\n    str = str.replace(goog.string.AMP_RE_, '&amp;')\\n              .replace(goog.string.LT_RE_, '&lt;')\\n              .replace(goog.string.GT_RE_, '&gt;')\\n              .replace(goog.string.QUOT_RE_, '&quot;')\\n              .replace(goog.string.SINGLE_QUOTE_RE_, '&#39;')\\n              .replace(goog.string.NULL_RE_, '&#0;');\\n    if (goog.string.DETECT_DOUBLE_ESCAPING) {\\n      str = str.replace(goog.string.E_RE_, '&#101;');\\n    }\\n    return str;\\n\\n  } else {\\n    // quick test helps in the case when there are no chars to replace, in\\n    // worst case this makes barely a difference to the time taken\\n    if (!goog.string.ALL_RE_.test(str)) return str;\\n\\n    // str.indexOf is faster than regex.test in this case\\n    if (str.indexOf('&') != -1) {\\n      str = str.replace(goog.string.AMP_RE_, '&amp;');\\n    }\\n    if (str.indexOf('<') != -1) {\\n      str = str.replace(goog.string.LT_RE_, '&lt;');\\n    }\\n    if (str.indexOf('>') != -1) {\\n      str = str.replace(goog.string.GT_RE_, '&gt;');\\n    }\\n    if (str.indexOf('\\\"') != -1) {\\n      str = str.replace(goog.string.QUOT_RE_, '&quot;');\\n    }\\n    if (str.indexOf('\\\\'') != -1) {\\n      str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');\\n    }\\n    if (str.indexOf('\\\\x00') != -1) {\\n      str = str.replace(goog.string.NULL_RE_, '&#0;');\\n    }\\n    if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {\\n      str = str.replace(goog.string.E_RE_, '&#101;');\\n    }\\n    return str;\\n  }\\n};\\n\\n\\n/**\\n * Regular expression that matches an ampersand, for use in escaping.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.AMP_RE_ = /&/g;\\n\\n\\n/**\\n * Regular expression that matches a less than sign, for use in escaping.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.LT_RE_ = /</g;\\n\\n\\n/**\\n * Regular expression that matches a greater than sign, for use in escaping.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.GT_RE_ = />/g;\\n\\n\\n/**\\n * Regular expression that matches a double quote, for use in escaping.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.QUOT_RE_ = /\\\"/g;\\n\\n\\n/**\\n * Regular expression that matches a single quote, for use in escaping.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.SINGLE_QUOTE_RE_ = /'/g;\\n\\n\\n/**\\n * Regular expression that matches null character, for use in escaping.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.NULL_RE_ = /\\\\x00/g;\\n\\n\\n/**\\n * Regular expression that matches a lowercase letter \\\"e\\\", for use in escaping.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.E_RE_ = /e/g;\\n\\n\\n/**\\n * Regular expression that matches any character that needs to be escaped.\\n * @const {!RegExp}\\n * @private\\n */\\ngoog.string.ALL_RE_ =\\n    (goog.string.DETECT_DOUBLE_ESCAPING ? /[\\\\x00&<>\\\"'e]/ : /[\\\\x00&<>\\\"']/);\\n\\n\\n/**\\n * Unescapes an HTML string.\\n *\\n * @param {string} str The string to unescape.\\n * @return {string} An unescaped copy of {@code str}.\\n */\\ngoog.string.unescapeEntities = function(str) {\\n  if (goog.string.contains(str, '&')) {\\n    // We are careful not to use a DOM if we do not have one or we explicitly\\n    // requested non-DOM html unescaping.\\n    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &&\\n        'document' in goog.global) {\\n      return goog.string.unescapeEntitiesUsingDom_(str);\\n    } else {\\n      // Fall back on pure XML entities\\n      return goog.string.unescapePureXmlEntities_(str);\\n    }\\n  }\\n  return str;\\n};\\n\\n\\n/**\\n * Unescapes a HTML string using the provided document.\\n *\\n * @param {string} str The string to unescape.\\n * @param {!Document} document A document to use in escaping the string.\\n * @return {string} An unescaped copy of {@code str}.\\n */\\ngoog.string.unescapeEntitiesWithDocument = function(str, document) {\\n  if (goog.string.contains(str, '&')) {\\n    return goog.string.unescapeEntitiesUsingDom_(str, document);\\n  }\\n  return str;\\n};\\n\\n\\n/**\\n * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric\\n * entities. This function is XSS-safe and whitespace-preserving.\\n * @private\\n * @param {string} str The string to unescape.\\n * @param {Document=} opt_document An optional document to use for creating\\n *     elements. If this is not specified then the default window.document\\n *     will be used.\\n * @return {string} The unescaped {@code str} string.\\n */\\ngoog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {\\n  /** @type {!Object<string, string>} */\\n  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\\\"'};\\n  var div;\\n  if (opt_document) {\\n    div = opt_document.createElement('div');\\n  } else {\\n    div = goog.global.document.createElement('div');\\n  }\\n  // Match as many valid entity characters as possible. If the actual entity\\n  // happens to be shorter, it will still work as innerHTML will return the\\n  // trailing characters unchanged. Since the entity characters do not include\\n  // open angle bracket, there is no chance of XSS from the innerHTML use.\\n  // Since no whitespace is passed to innerHTML, whitespace is preserved.\\n  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {\\n    // Check for cached entity.\\n    var value = seen[s];\\n    if (value) {\\n      return value;\\n    }\\n    // Check for numeric entity.\\n    if (entity.charAt(0) == '#') {\\n      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.\\n      var n = Number('0' + entity.substr(1));\\n      if (!isNaN(n)) {\\n        value = String.fromCharCode(n);\\n      }\\n    }\\n    // Fall back to innerHTML otherwise.\\n    if (!value) {\\n      // Append a non-entity character to avoid a bug in Webkit that parses\\n      // an invalid entity at the end of innerHTML text as the empty string.\\n      div.innerHTML = s + ' ';\\n      // Then remove the trailing character from the result.\\n      value = div.firstChild.nodeValue.slice(0, -1);\\n    }\\n    // Cache and return.\\n    return seen[s] = value;\\n  });\\n};\\n\\n\\n/**\\n * Unescapes XML entities.\\n * @private\\n * @param {string} str The string to unescape.\\n * @return {string} An unescaped copy of {@code str}.\\n */\\ngoog.string.unescapePureXmlEntities_ = function(str) {\\n  return str.replace(/&([^;]+);/g, function(s, entity) {\\n    switch (entity) {\\n      case 'amp':\\n        return '&';\\n      case 'lt':\\n        return '<';\\n      case 'gt':\\n        return '>';\\n      case 'quot':\\n        return '\\\"';\\n      default:\\n        if (entity.charAt(0) == '#') {\\n          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.\\n          var n = Number('0' + entity.substr(1));\\n          if (!isNaN(n)) {\\n            return String.fromCharCode(n);\\n          }\\n        }\\n        // For invalid entities we just return the entity\\n        return s;\\n    }\\n  });\\n};\\n\\n\\n/**\\n * Regular expression that matches an HTML entity.\\n * See also HTML5: Tokenization / Tokenizing character references.\\n * @private\\n * @type {!RegExp}\\n */\\ngoog.string.HTML_ENTITY_PATTERN_ = /&([^;\\\\s<&]+);?/g;\\n\\n\\n/**\\n * Do escaping of whitespace to preserve spatial formatting. We use character\\n * entity #160 to make it safer for xml.\\n * @param {string} str The string in which to escape whitespace.\\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\\n * @return {string} An escaped copy of {@code str}.\\n */\\ngoog.string.whitespaceEscape = function(str, opt_xml) {\\n  // This doesn't use goog.string.preserveSpaces for backwards compatibility.\\n  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);\\n};\\n\\n\\n/**\\n * Preserve spaces that would be otherwise collapsed in HTML by replacing them\\n * with non-breaking space Unicode characters.\\n * @param {string} str The string in which to preserve whitespace.\\n * @return {string} A copy of {@code str} with preserved whitespace.\\n */\\ngoog.string.preserveSpaces = function(str) {\\n  return str.replace(/(^|[\\\\n ]) /g, '$1' + goog.string.Unicode.NBSP);\\n};\\n\\n\\n/**\\n * Strip quote characters around a string.  The second argument is a string of\\n * characters to treat as quotes.  This can be a single character or a string of\\n * multiple character and in that case each of those are treated as possible\\n * quote characters. For example:\\n *\\n * <pre>\\n * goog.string.stripQuotes('\\\"abc\\\"', '\\\"`') --\\u003e 'abc'\\n * goog.string.stripQuotes('`abc`', '\\\"`') --\\u003e 'abc'\\n * </pre>\\n *\\n * @param {string} str The string to strip.\\n * @param {string} quoteChars The quote characters to strip.\\n * @return {string} A copy of {@code str} without the quotes.\\n */\\ngoog.string.stripQuotes = function(str, quoteChars) {\\n  var length = quoteChars.length;\\n  for (var i = 0; i < length; i++) {\\n    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);\\n    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {\\n      return str.substring(1, str.length - 1);\\n    }\\n  }\\n  return str;\\n};\\n\\n\\n/**\\n * Truncates a string to a certain length and adds '...' if necessary.  The\\n * length also accounts for the ellipsis, so a maximum length of 10 and a string\\n * 'Hello World!' produces 'Hello W...'.\\n * @param {string} str The string to truncate.\\n * @param {number} chars Max number of characters.\\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\\n *     characters from being cut off in the middle.\\n * @return {string} The truncated {@code str} string.\\n */\\ngoog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {\\n  if (opt_protectEscapedCharacters) {\\n    str = goog.string.unescapeEntities(str);\\n  }\\n\\n  if (str.length > chars) {\\n    str = str.substring(0, chars - 3) + '...';\\n  }\\n\\n  if (opt_protectEscapedCharacters) {\\n    str = goog.string.htmlEscape(str);\\n  }\\n\\n  return str;\\n};\\n\\n\\n/**\\n * Truncate a string in the middle, adding \\\"...\\\" if necessary,\\n * and favoring the beginning of the string.\\n * @param {string} str The string to truncate the middle of.\\n * @param {number} chars Max number of characters.\\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\\n *     characters from being cutoff in the middle.\\n * @param {number=} opt_trailingChars Optional number of trailing characters to\\n *     leave at the end of the string, instead of truncating as close to the\\n *     middle as possible.\\n * @return {string} A truncated copy of {@code str}.\\n */\\ngoog.string.truncateMiddle = function(\\n    str, chars, opt_protectEscapedCharacters, opt_trailingChars) {\\n  if (opt_protectEscapedCharacters) {\\n    str = goog.string.unescapeEntities(str);\\n  }\\n\\n  if (opt_trailingChars && str.length > chars) {\\n    if (opt_trailingChars > chars) {\\n      opt_trailingChars = chars;\\n    }\\n    var endPoint = str.length - opt_trailingChars;\\n    var startPoint = chars - opt_trailingChars;\\n    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);\\n  } else if (str.length > chars) {\\n    // Favor the beginning of the string:\\n    var half = Math.floor(chars / 2);\\n    var endPos = str.length - half;\\n    half += chars % 2;\\n    str = str.substring(0, half) + '...' + str.substring(endPos);\\n  }\\n\\n  if (opt_protectEscapedCharacters) {\\n    str = goog.string.htmlEscape(str);\\n  }\\n\\n  return str;\\n};\\n\\n\\n/**\\n * Special chars that need to be escaped for goog.string.quote.\\n * @private {!Object<string, string>}\\n */\\ngoog.string.specialEscapeChars_ = {\\n  '\\\\0': '\\\\\\\\0',\\n  '\\\\b': '\\\\\\\\b',\\n  '\\\\f': '\\\\\\\\f',\\n  '\\\\n': '\\\\\\\\n',\\n  '\\\\r': '\\\\\\\\r',\\n  '\\\\t': '\\\\\\\\t',\\n  '\\\\x0B': '\\\\\\\\x0B',  // '\\\\v' is not supported in JScript\\n  '\\\"': '\\\\\\\\\\\"',\\n  '\\\\\\\\': '\\\\\\\\\\\\\\\\',\\n  // To support the use case of embedding quoted strings inside of script\\n  // tags, we have to make sure HTML comments and opening/closing script tags do\\n  // not appear in the resulting string. The specific strings that must be\\n  // escaped are documented at:\\n  // http://www.w3.org/TR/html51/semantics.html#restrictions-for-contents-of-script-elements\\n  '<': '\\\\x3c'\\n};\\n\\n\\n/**\\n * Character mappings used internally for goog.string.escapeChar.\\n * @private {!Object<string, string>}\\n */\\ngoog.string.jsEscapeCache_ = {\\n  '\\\\'': '\\\\\\\\\\\\''\\n};\\n\\n\\n/**\\n * Encloses a string in double quotes and escapes characters so that the\\n * string is a valid JS string. The resulting string is safe to embed in\\n * `<script>` tags as \\\"<\\\" is escaped.\\n * @param {string} s The string to quote.\\n * @return {string} A copy of {@code s} surrounded by double quotes.\\n */\\ngoog.string.quote = function(s) {\\n  s = String(s);\\n  var sb = ['\\\"'];\\n  for (var i = 0; i < s.length; i++) {\\n    var ch = s.charAt(i);\\n    var cc = ch.charCodeAt(0);\\n    sb[i + 1] = goog.string.specialEscapeChars_[ch] ||\\n        ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));\\n  }\\n  sb.push('\\\"');\\n  return sb.join('');\\n};\\n\\n\\n/**\\n * Takes a string and returns the escaped string for that input string.\\n * @param {string} str The string to escape.\\n * @return {string} An escaped string representing {@code str}.\\n */\\ngoog.string.escapeString = function(str) {\\n  var sb = [];\\n  for (var i = 0; i < str.length; i++) {\\n    sb[i] = goog.string.escapeChar(str.charAt(i));\\n  }\\n  return sb.join('');\\n};\\n\\n\\n/**\\n * Takes a character and returns the escaped string for that character. For\\n * example escapeChar(String.fromCharCode(15)) -> \\\"\\\\\\\\x0E\\\".\\n * @param {string} c The character to escape.\\n * @return {string} An escaped string representing {@code c}.\\n */\\ngoog.string.escapeChar = function(c) {\\n  if (c in goog.string.jsEscapeCache_) {\\n    return goog.string.jsEscapeCache_[c];\\n  }\\n\\n  if (c in goog.string.specialEscapeChars_) {\\n    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];\\n  }\\n\\n  var rv = c;\\n  var cc = c.charCodeAt(0);\\n  if (cc > 31 && cc < 127) {\\n    rv = c;\\n  } else {\\n    // tab is 9 but handled above\\n    if (cc < 256) {\\n      rv = '\\\\\\\\x';\\n      if (cc < 16 || cc > 256) {\\n        rv += '0';\\n      }\\n    } else {\\n      rv = '\\\\\\\\u';\\n      if (cc < 4096) {  // \\\\u1000\\n        rv += '0';\\n      }\\n    }\\n    rv += cc.toString(16).toUpperCase();\\n  }\\n\\n  return goog.string.jsEscapeCache_[c] = rv;\\n};\\n\\n\\n/**\\n * Determines whether a string contains a substring.\\n * @param {string} str The string to search.\\n * @param {string} subString The substring to search for.\\n * @return {boolean} Whether {@code str} contains {@code subString}.\\n */\\ngoog.string.contains = function(str, subString) {\\n  return str.indexOf(subString) != -1;\\n};\\n\\n\\n/**\\n * Determines whether a string contains a substring, ignoring case.\\n * @param {string} str The string to search.\\n * @param {string} subString The substring to search for.\\n * @return {boolean} Whether {@code str} contains {@code subString}.\\n */\\ngoog.string.caseInsensitiveContains = function(str, subString) {\\n  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());\\n};\\n\\n\\n/**\\n * Returns the non-overlapping occurrences of ss in s.\\n * If either s or ss evalutes to false, then returns zero.\\n * @param {string} s The string to look in.\\n * @param {string} ss The string to look for.\\n * @return {number} Number of occurrences of ss in s.\\n */\\ngoog.string.countOf = function(s, ss) {\\n  return s && ss ? s.split(ss).length - 1 : 0;\\n};\\n\\n\\n/**\\n * Removes a substring of a specified length at a specific\\n * index in a string.\\n * @param {string} s The base string from which to remove.\\n * @param {number} index The index at which to remove the substring.\\n * @param {number} stringLength The length of the substring to remove.\\n * @return {string} A copy of {@code s} with the substring removed or the full\\n *     string if nothing is removed or the input is invalid.\\n */\\ngoog.string.removeAt = function(s, index, stringLength) {\\n  var resultStr = s;\\n  // If the index is greater or equal to 0 then remove substring\\n  if (index >= 0 && index < s.length && stringLength > 0) {\\n    resultStr = s.substr(0, index) +\\n        s.substr(index + stringLength, s.length - index - stringLength);\\n  }\\n  return resultStr;\\n};\\n\\n\\n/**\\n * Removes the first occurrence of a substring from a string.\\n * @param {string} str The base string from which to remove.\\n * @param {string} substr The string to remove.\\n * @return {string} A copy of {@code str} with {@code substr} removed or the\\n *     full string if nothing is removed.\\n */\\ngoog.string.remove = function(str, substr) {\\n  return str.replace(substr, '');\\n};\\n\\n\\n/**\\n *  Removes all occurrences of a substring from a string.\\n *  @param {string} s The base string from which to remove.\\n *  @param {string} ss The string to remove.\\n *  @return {string} A copy of {@code s} with {@code ss} removed or the full\\n *      string if nothing is removed.\\n */\\ngoog.string.removeAll = function(s, ss) {\\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\\n  return s.replace(re, '');\\n};\\n\\n\\n/**\\n *  Replaces all occurrences of a substring of a string with a new substring.\\n *  @param {string} s The base string from which to remove.\\n *  @param {string} ss The string to replace.\\n *  @param {string} replacement The replacement string.\\n *  @return {string} A copy of {@code s} with {@code ss} replaced by\\n *      {@code replacement} or the original string if nothing is replaced.\\n */\\ngoog.string.replaceAll = function(s, ss, replacement) {\\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\\n  return s.replace(re, replacement.replace(/\\\\$/g, '$$$$'));\\n};\\n\\n\\n/**\\n * Escapes characters in the string that are not safe to use in a RegExp.\\n * @param {*} s The string to escape. If not a string, it will be casted\\n *     to one.\\n * @return {string} A RegExp safe, escaped copy of {@code s}.\\n */\\ngoog.string.regExpEscape = function(s) {\\n  return String(s)\\n      .replace(/([-()\\\\[\\\\]{}+?*.$\\\\^|,:#<!\\\\\\\\])/g, '\\\\\\\\$1')\\n      .replace(/\\\\x08/g, '\\\\\\\\x08');\\n};\\n\\n\\n/**\\n * Repeats a string n times.\\n * @param {string} string The string to repeat.\\n * @param {number} length The number of times to repeat.\\n * @return {string} A string containing {@code length} repetitions of\\n *     {@code string}.\\n */\\ngoog.string.repeat = (String.prototype.repeat) ? function(string, length) {\\n  // The native method is over 100 times faster than the alternative.\\n  return string.repeat(length);\\n} : function(string, length) {\\n  return new Array(length + 1).join(string);\\n};\\n\\n\\n/**\\n * Pads number to given length and optionally rounds it to a given precision.\\n * For example:\\n * <pre>padNumber(1.25, 2, 3) -> '01.250'\\n * padNumber(1.25, 2) -> '01.25'\\n * padNumber(1.25, 2, 1) -> '01.3'\\n * padNumber(1.25, 0) -> '1.25'</pre>\\n *\\n * @param {number} num The number to pad.\\n * @param {number} length The desired length.\\n * @param {number=} opt_precision The desired precision.\\n * @return {string} {@code num} as a string with the given options.\\n */\\ngoog.string.padNumber = function(num, length, opt_precision) {\\n  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);\\n  var index = s.indexOf('.');\\n  if (index == -1) {\\n    index = s.length;\\n  }\\n  return goog.string.repeat('0', Math.max(0, length - index)) + s;\\n};\\n\\n\\n/**\\n * Returns a string representation of the given object, with\\n * null and undefined being returned as the empty string.\\n *\\n * @param {*} obj The object to convert.\\n * @return {string} A string representation of the {@code obj}.\\n */\\ngoog.string.makeSafe = function(obj) {\\n  return obj == null ? '' : String(obj);\\n};\\n\\n\\n/**\\n * Concatenates string expressions. This is useful\\n * since some browsers are very inefficient when it comes to using plus to\\n * concat strings. Be careful when using null and undefined here since\\n * these will not be included in the result. If you need to represent these\\n * be sure to cast the argument to a String first.\\n * For example:\\n * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'\\n * buildString(null, undefined) -> ''\\n * </pre>\\n * @param {...*} var_args A list of strings to concatenate. If not a string,\\n *     it will be casted to one.\\n * @return {string} The concatenation of {@code var_args}.\\n */\\ngoog.string.buildString = function(var_args) {\\n  return Array.prototype.join.call(arguments, '');\\n};\\n\\n\\n/**\\n * Returns a string with at least 64-bits of randomness.\\n *\\n * Doesn't trust Javascript's random function entirely. Uses a combination of\\n * random and current timestamp, and then encodes the string in base-36 to\\n * make it shorter.\\n *\\n * @return {string} A random string, e.g. sn1s7vb4gcic.\\n */\\ngoog.string.getRandomString = function() {\\n  var x = 2147483648;\\n  return Math.floor(Math.random() * x).toString(36) +\\n      Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);\\n};\\n\\n\\n/**\\n * Compares two version numbers.\\n *\\n * @param {string|number} version1 Version of first item.\\n * @param {string|number} version2 Version of second item.\\n *\\n * @return {number}  1 if {@code version1} is higher.\\n *                   0 if arguments are equal.\\n *                  -1 if {@code version2} is higher.\\n */\\ngoog.string.compareVersions = function(version1, version2) {\\n  var order = 0;\\n  // Trim leading and trailing whitespace and split the versions into\\n  // subversions.\\n  var v1Subs = goog.string.trim(String(version1)).split('.');\\n  var v2Subs = goog.string.trim(String(version2)).split('.');\\n  var subCount = Math.max(v1Subs.length, v2Subs.length);\\n\\n  // Iterate over the subversions, as long as they appear to be equivalent.\\n  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {\\n    var v1Sub = v1Subs[subIdx] || '';\\n    var v2Sub = v2Subs[subIdx] || '';\\n\\n    do {\\n      // Split the subversions into pairs of numbers and qualifiers (like 'b').\\n      // Two different RegExp objects are use to make it clear the code\\n      // is side-effect free\\n      var v1Comp = /(\\\\d*)(\\\\D*)(.*)/.exec(v1Sub) || ['', '', '', ''];\\n      var v2Comp = /(\\\\d*)(\\\\D*)(.*)/.exec(v2Sub) || ['', '', '', ''];\\n      // Break if there are no more matches.\\n      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {\\n        break;\\n      }\\n\\n      // Parse the numeric part of the subversion. A missing number is\\n      // equivalent to 0.\\n      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);\\n      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);\\n\\n      // Compare the subversion components. The number has the highest\\n      // precedence. Next, if the numbers are equal, a subversion without any\\n      // qualifier is always higher than a subversion with any qualifier. Next,\\n      // the qualifiers are compared as strings.\\n      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||\\n          goog.string.compareElements_(\\n              v1Comp[2].length == 0, v2Comp[2].length == 0) ||\\n          goog.string.compareElements_(v1Comp[2], v2Comp[2]);\\n      // Stop as soon as an inequality is discovered.\\n\\n      v1Sub = v1Comp[3];\\n      v2Sub = v2Comp[3];\\n    } while (order == 0);\\n  }\\n\\n  return order;\\n};\\n\\n\\n/**\\n * Compares elements of a version number.\\n *\\n * @param {string|number|boolean} left An element from a version number.\\n * @param {string|number|boolean} right An element from a version number.\\n *\\n * @return {number}  1 if {@code left} is higher.\\n *                   0 if arguments are equal.\\n *                  -1 if {@code right} is higher.\\n * @private\\n */\\ngoog.string.compareElements_ = function(left, right) {\\n  if (left < right) {\\n    return -1;\\n  } else if (left > right) {\\n    return 1;\\n  }\\n  return 0;\\n};\\n\\n\\n/**\\n * String hash function similar to java.lang.String.hashCode().\\n * The hash code for a string is computed as\\n * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\\n * where s[i] is the ith character of the string and n is the length of\\n * the string. We mod the result to make it between 0 (inclusive) and 2^32\\n * (exclusive).\\n * @param {string} str A string.\\n * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32\\n *  (exclusive). The empty string returns 0.\\n */\\ngoog.string.hashCode = function(str) {\\n  var result = 0;\\n  for (var i = 0; i < str.length; ++i) {\\n    // Normalize to 4 byte range, 0 ... 2^32.\\n    result = (31 * result + str.charCodeAt(i)) >>> 0;\\n  }\\n  return result;\\n};\\n\\n\\n/**\\n * The most recent unique ID. |0 is equivalent to Math.floor in this case.\\n * @type {number}\\n * @private\\n */\\ngoog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;\\n\\n\\n/**\\n * Generates and returns a string which is unique in the current document.\\n * This is useful, for example, to create unique IDs for DOM elements.\\n * @return {string} A unique id.\\n */\\ngoog.string.createUniqueString = function() {\\n  return 'goog_' + goog.string.uniqueStringCounter_++;\\n};\\n\\n\\n/**\\n * Converts the supplied string to a number, which may be Infinity or NaN.\\n * This function strips whitespace: (toNumber(' 123') === 123)\\n * This function accepts scientific notation: (toNumber('1e1') === 10)\\n *\\n * This is better than Javascript's built-in conversions because, sadly:\\n *     (Number(' ') === 0) and (parseFloat('123a') === 123)\\n *\\n * @param {string} str The string to convert.\\n * @return {number} The number the supplied string represents, or NaN.\\n */\\ngoog.string.toNumber = function(str) {\\n  var num = Number(str);\\n  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {\\n    return NaN;\\n  }\\n  return num;\\n};\\n\\n\\n/**\\n * Returns whether the given string is lower camel case (e.g. \\\"isFooBar\\\").\\n *\\n * Note that this assumes the string is entirely letters.\\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\\n *\\n * @param {string} str String to test.\\n * @return {boolean} Whether the string is lower camel case.\\n */\\ngoog.string.isLowerCamelCase = function(str) {\\n  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);\\n};\\n\\n\\n/**\\n * Returns whether the given string is upper camel case (e.g. \\\"FooBarBaz\\\").\\n *\\n * Note that this assumes the string is entirely letters.\\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\\n *\\n * @param {string} str String to test.\\n * @return {boolean} Whether the string is upper camel case.\\n */\\ngoog.string.isUpperCamelCase = function(str) {\\n  return /^([A-Z][a-z]*)+$/.test(str);\\n};\\n\\n\\n/**\\n * Converts a string from selector-case to camelCase (e.g. from\\n * \\\"multi-part-string\\\" to \\\"multiPartString\\\"), useful for converting\\n * CSS selectors and HTML dataset keys to their equivalent JS properties.\\n * @param {string} str The string in selector-case form.\\n * @return {string} The string in camelCase form.\\n */\\ngoog.string.toCamelCase = function(str) {\\n  return String(str).replace(\\n      /\\\\-([a-z])/g, function(all, match) { return match.toUpperCase(); });\\n};\\n\\n\\n/**\\n * Converts a string from camelCase to selector-case (e.g. from\\n * \\\"multiPartString\\\" to \\\"multi-part-string\\\"), useful for converting JS\\n * style and dataset properties to equivalent CSS selectors and HTML keys.\\n * @param {string} str The string in camelCase form.\\n * @return {string} The string in selector-case form.\\n */\\ngoog.string.toSelectorCase = function(str) {\\n  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();\\n};\\n\\n\\n/**\\n * Converts a string into TitleCase. First character of the string is always\\n * capitalized in addition to the first letter of every subsequent word.\\n * Words are delimited by one or more whitespaces by default. Custom delimiters\\n * can optionally be specified to replace the default, which doesn't preserve\\n * whitespace delimiters and instead must be explicitly included if needed.\\n *\\n * Default delimiter => \\\" \\\":\\n *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'\\n *    goog.string.toTitleCase('one two three')  => 'One Two Three'\\n *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '\\n *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'\\n *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'\\n *\\n * Custom delimiter => \\\"_-.\\\":\\n *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'\\n *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'\\n *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '\\n *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'\\n *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'\\n *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'\\n *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'\\n *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'\\n *\\n * @param {string} str String value in camelCase form.\\n * @param {string=} opt_delimiters Custom delimiter character set used to\\n *      distinguish words in the string value. Each character represents a\\n *      single delimiter. When provided, default whitespace delimiter is\\n *      overridden and must be explicitly included if needed.\\n * @return {string} String value in TitleCase form.\\n */\\ngoog.string.toTitleCase = function(str, opt_delimiters) {\\n  var delimiters = goog.isString(opt_delimiters) ?\\n      goog.string.regExpEscape(opt_delimiters) :\\n      '\\\\\\\\s';\\n\\n  // For IE8, we need to prevent using an empty character set. Otherwise,\\n  // incorrect matching will occur.\\n  delimiters = delimiters ? '|[' + delimiters + ']+' : '';\\n\\n  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');\\n  return str.replace(\\n      regexp, function(all, p1, p2) { return p1 + p2.toUpperCase(); });\\n};\\n\\n\\n/**\\n * Capitalizes a string, i.e. converts the first letter to uppercase\\n * and all other letters to lowercase, e.g.:\\n *\\n * goog.string.capitalize('one')     => 'One'\\n * goog.string.capitalize('ONE')     => 'One'\\n * goog.string.capitalize('one two') => 'One two'\\n *\\n * Note that this function does not trim initial whitespace.\\n *\\n * @param {string} str String value to capitalize.\\n * @return {string} String value with first letter in uppercase.\\n */\\ngoog.string.capitalize = function(str) {\\n  return String(str.charAt(0)).toUpperCase() +\\n      String(str.substr(1)).toLowerCase();\\n};\\n\\n\\n/**\\n * Parse a string in decimal or hexidecimal ('0xFFFF') form.\\n *\\n * To parse a particular radix, please use parseInt(string, radix) directly. See\\n * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt\\n *\\n * This is a wrapper for the built-in parseInt function that will only parse\\n * numbers as base 10 or base 16.  Some JS implementations assume strings\\n * starting with \\\"0\\\" are intended to be octal. ES3 allowed but discouraged\\n * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.\\n *\\n * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj\\n *\\n * @param {string|number|null|undefined} value The value to be parsed.\\n * @return {number} The number, parsed. If the string failed to parse, this\\n *     will be NaN.\\n */\\ngoog.string.parseInt = function(value) {\\n  // Force finite numbers to strings.\\n  if (isFinite(value)) {\\n    value = String(value);\\n  }\\n\\n  if (goog.isString(value)) {\\n    // If the string starts with '0x' or '-0x', parse as hex.\\n    return /^\\\\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);\\n  }\\n\\n  return NaN;\\n};\\n\\n\\n/**\\n * Splits a string on a separator a limited number of times.\\n *\\n * This implementation is more similar to Python or Java, where the limit\\n * parameter specifies the maximum number of splits rather than truncating\\n * the number of results.\\n *\\n * See http://docs.python.org/2/library/stdtypes.html#str.split\\n * See JavaDoc: http://goo.gl/F2AsY\\n * See Mozilla reference: http://goo.gl/dZdZs\\n *\\n * @param {string} str String to split.\\n * @param {string} separator The separator.\\n * @param {number} limit The limit to the number of splits. The resulting array\\n *     will have a maximum length of limit+1.  Negative numbers are the same\\n *     as zero.\\n * @return {!Array<string>} The string, split.\\n */\\ngoog.string.splitLimit = function(str, separator, limit) {\\n  var parts = str.split(separator);\\n  var returnVal = [];\\n\\n  // Only continue doing this while we haven't hit the limit and we have\\n  // parts left.\\n  while (limit > 0 && parts.length) {\\n    returnVal.push(parts.shift());\\n    limit--;\\n  }\\n\\n  // If there are remaining parts, append them to the end.\\n  if (parts.length) {\\n    returnVal.push(parts.join(separator));\\n  }\\n\\n  return returnVal;\\n};\\n\\n\\n/**\\n * Finds the characters to the right of the last instance of any separator\\n *\\n * This function is similar to goog.string.path.baseName, except it can take a\\n * list of characters to split the string on. It will return the rightmost\\n * grouping of characters to the right of any separator as a left-to-right\\n * oriented string.\\n *\\n * @see goog.string.path.baseName\\n * @param {string} str The string\\n * @param {string|!Array<string>} separators A list of separator characters\\n * @return {string} The last part of the string with respect to the separators\\n */\\ngoog.string.lastComponent = function(str, separators) {\\n  if (!separators) {\\n    return str;\\n  } else if (typeof separators == 'string') {\\n    separators = [separators];\\n  }\\n\\n  var lastSeparatorIndex = -1;\\n  for (var i = 0; i < separators.length; i++) {\\n    if (separators[i] == '') {\\n      continue;\\n    }\\n    var currentSeparatorIndex = str.lastIndexOf(separators[i]);\\n    if (currentSeparatorIndex > lastSeparatorIndex) {\\n      lastSeparatorIndex = currentSeparatorIndex;\\n    }\\n  }\\n  if (lastSeparatorIndex == -1) {\\n    return str;\\n  }\\n  return str.slice(lastSeparatorIndex + 1);\\n};\\n\\n\\n/**\\n * Computes the Levenshtein edit distance between two strings.\\n * @param {string} a\\n * @param {string} b\\n * @return {number} The edit distance between the two strings.\\n */\\ngoog.string.editDistance = function(a, b) {\\n  var v0 = [];\\n  var v1 = [];\\n\\n  if (a == b) {\\n    return 0;\\n  }\\n\\n  if (!a.length || !b.length) {\\n    return Math.max(a.length, b.length);\\n  }\\n\\n  for (var i = 0; i < b.length + 1; i++) {\\n    v0[i] = i;\\n  }\\n\\n  for (var i = 0; i < a.length; i++) {\\n    v1[0] = i + 1;\\n\\n    for (var j = 0; j < b.length; j++) {\\n      var cost = Number(a[i] != b[j]);\\n      // Cost for the substring is the minimum of adding one character, removing\\n      // one character, or a swap.\\n      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);\\n    }\\n\\n    for (var j = 0; j < v0.length; j++) {\\n      v0[j] = v1[j];\\n    }\\n  }\\n\\n  return v1[b.length];\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"define\",\"string\",\"Unicode\",\"NBSP\",\"startsWith\",\"goog.string.startsWith\",\"str\",\"prefix\",\"lastIndexOf\",\"endsWith\",\"goog.string.endsWith\",\"suffix\",\"l\",\"length\",\"indexOf\",\"caseInsensitiveStartsWith\",\"goog.string.caseInsensitiveStartsWith\",\"caseInsensitiveCompare\",\"substr\",\"caseInsensitiveEndsWith\",\"goog.string.caseInsensitiveEndsWith\",\"caseInsensitiveEquals\",\"goog.string.caseInsensitiveEquals\",\"str1\",\"str2\",\"toLowerCase\",\"subs\",\"goog.string.subs\",\"var_args\",\"splitParts\",\"split\",\"returnString\",\"subsArguments\",\"Array\",\"prototype\",\"slice\",\"call\",\"arguments\",\"shift\",\"join\",\"collapseWhitespace\",\"goog.string.collapseWhitespace\",\"replace\",\"isEmptyOrWhitespace\",\"goog.string.isEmptyOrWhitespace\",\"test\",\"isEmptyString\",\"goog.string.isEmptyString\",\"isEmpty\",\"isEmptyOrWhitespaceSafe\",\"goog.string.isEmptyOrWhitespaceSafe\",\"makeSafe\",\"isEmptySafe\",\"isBreakingWhitespace\",\"goog.string.isBreakingWhitespace\",\"isAlpha\",\"goog.string.isAlpha\",\"isNumeric\",\"goog.string.isNumeric\",\"isAlphaNumeric\",\"goog.string.isAlphaNumeric\",\"isSpace\",\"goog.string.isSpace\",\"ch\",\"isUnicodeChar\",\"goog.string.isUnicodeChar\",\"stripNewlines\",\"goog.string.stripNewlines\",\"canonicalizeNewlines\",\"goog.string.canonicalizeNewlines\",\"normalizeWhitespace\",\"goog.string.normalizeWhitespace\",\"normalizeSpaces\",\"goog.string.normalizeSpaces\",\"collapseBreakingSpaces\",\"goog.string.collapseBreakingSpaces\",\"trim\",\"TRUSTED_SITE\",\"String\",\"trimLeft\",\"goog.string.trimLeft\",\"trimRight\",\"goog.string.trimRight\",\"goog.string.caseInsensitiveCompare\",\"test1\",\"test2\",\"numberAwareCompare_\",\"goog.string.numberAwareCompare_\",\"tokenizerRegExp\",\"tokens1\",\"match\",\"tokens2\",\"count\",\"Math\",\"min\",\"i\",\"a\",\"b\",\"num1\",\"parseInt\",\"isNaN\",\"num2\",\"intAwareCompare\",\"goog.string.intAwareCompare\",\"floatAwareCompare\",\"goog.string.floatAwareCompare\",\"numerateCompare\",\"urlEncode\",\"goog.string.urlEncode\",\"encodeURIComponent\",\"urlDecode\",\"goog.string.urlDecode\",\"decodeURIComponent\",\"newLineToBr\",\"goog.string.newLineToBr\",\"opt_xml\",\"htmlEscape\",\"goog.string.htmlEscape\",\"opt_isLikelyToContainHtmlChars\",\"AMP_RE_\",\"LT_RE_\",\"GT_RE_\",\"QUOT_RE_\",\"SINGLE_QUOTE_RE_\",\"NULL_RE_\",\"DETECT_DOUBLE_ESCAPING\",\"E_RE_\",\"ALL_RE_\",\"unescapeEntities\",\"goog.string.unescapeEntities\",\"contains\",\"FORCE_NON_DOM_HTML_UNESCAPING\",\"global\",\"unescapeEntitiesUsingDom_\",\"unescapePureXmlEntities_\",\"unescapeEntitiesWithDocument\",\"goog.string.unescapeEntitiesWithDocument\",\"document\",\"goog.string.unescapeEntitiesUsingDom_\",\"opt_document\",\"seen\",\"div\",\"createElement\",\"HTML_ENTITY_PATTERN_\",\"s\",\"entity\",\"value\",\"charAt\",\"n\",\"Number\",\"fromCharCode\",\"innerHTML\",\"firstChild\",\"nodeValue\",\"goog.string.unescapePureXmlEntities_\",\"whitespaceEscape\",\"goog.string.whitespaceEscape\",\"preserveSpaces\",\"goog.string.preserveSpaces\",\"stripQuotes\",\"goog.string.stripQuotes\",\"quoteChars\",\"quoteChar\",\"substring\",\"truncate\",\"goog.string.truncate\",\"chars\",\"opt_protectEscapedCharacters\",\"truncateMiddle\",\"goog.string.truncateMiddle\",\"opt_trailingChars\",\"endPoint\",\"startPoint\",\"half\",\"floor\",\"endPos\",\"specialEscapeChars_\",\"jsEscapeCache_\",\"quote\",\"goog.string.quote\",\"sb\",\"cc\",\"charCodeAt\",\"escapeChar\",\"push\",\"escapeString\",\"goog.string.escapeString\",\"goog.string.escapeChar\",\"c\",\"rv\",\"toString\",\"toUpperCase\",\"goog.string.contains\",\"subString\",\"caseInsensitiveContains\",\"goog.string.caseInsensitiveContains\",\"countOf\",\"goog.string.countOf\",\"ss\",\"removeAt\",\"goog.string.removeAt\",\"index\",\"stringLength\",\"resultStr\",\"remove\",\"goog.string.remove\",\"removeAll\",\"goog.string.removeAll\",\"re\",\"RegExp\",\"regExpEscape\",\"replaceAll\",\"goog.string.replaceAll\",\"replacement\",\"goog.string.regExpEscape\",\"repeat\",\"padNumber\",\"goog.string.padNumber\",\"num\",\"opt_precision\",\"isDef\",\"toFixed\",\"max\",\"goog.string.makeSafe\",\"obj\",\"buildString\",\"goog.string.buildString\",\"getRandomString\",\"goog.string.getRandomString\",\"x\",\"random\",\"abs\",\"now\",\"compareVersions\",\"goog.string.compareVersions\",\"version1\",\"version2\",\"order\",\"v1Subs\",\"v2Subs\",\"subCount\",\"subIdx\",\"v1Sub\",\"v2Sub\",\"v1Comp\",\"exec\",\"v2Comp\",\"v1CompNum\",\"v2CompNum\",\"compareElements_\",\"goog.string.compareElements_\",\"left\",\"right\",\"hashCode\",\"goog.string.hashCode\",\"result\",\"uniqueStringCounter_\",\"createUniqueString\",\"goog.string.createUniqueString\",\"toNumber\",\"goog.string.toNumber\",\"NaN\",\"isLowerCamelCase\",\"goog.string.isLowerCamelCase\",\"isUpperCamelCase\",\"goog.string.isUpperCamelCase\",\"toCamelCase\",\"goog.string.toCamelCase\",\"all\",\"toSelectorCase\",\"goog.string.toSelectorCase\",\"toTitleCase\",\"goog.string.toTitleCase\",\"opt_delimiters\",\"delimiters\",\"isString\",\"regexp\",\"p1\",\"p2\",\"capitalize\",\"goog.string.capitalize\",\"goog.string.parseInt\",\"isFinite\",\"splitLimit\",\"goog.string.splitLimit\",\"separator\",\"limit\",\"parts\",\"returnVal\",\"lastComponent\",\"goog.string.lastComponent\",\"separators\",\"lastSeparatorIndex\",\"currentSeparatorIndex\",\"editDistance\",\"goog.string.editDistance\",\"v0\",\"v1\",\"j\",\"cost\"]\n}\n"]