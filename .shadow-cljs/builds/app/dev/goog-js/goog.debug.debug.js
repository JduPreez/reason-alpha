["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/debug/debug.js"],"~:js","goog.provide(\"goog.debug\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.debug.errorcontext\");\ngoog.require(\"goog.userAgent\");\n/** @define {boolean} */ goog.define(\"goog.debug.LOGGING_ENABLED\", goog.DEBUG);\n/** @define {boolean} */ goog.define(\"goog.debug.FORCE_SLOPPY_STACKS\", false);\n/**\n * @param {function(Object)} logFunc\n * @param {boolean=} opt_cancel\n * @param {Object=} opt_target\n */\ngoog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {\n  var target = opt_target || goog.global;\n  var oldErrorHandler = target.onerror;\n  var retVal = !!opt_cancel;\n  if (goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher(\"535.3\")) {\n    retVal = !retVal;\n  }\n  /**\n   * @param {string} message\n   * @param {string} url\n   * @param {number} line\n   * @param {number=} opt_col\n   * @param {Error=} opt_error\n   * @return {boolean}\n   */\n  target.onerror = function(message, url, line, opt_col, opt_error) {\n    if (oldErrorHandler) {\n      oldErrorHandler(message, url, line, opt_col, opt_error);\n    }\n    logFunc({message:message, fileName:url, line:line, col:opt_col, error:opt_error});\n    return retVal;\n  };\n};\n/**\n * @param {(Object|null|undefined)} obj\n * @param {boolean=} opt_showFn\n * @return {string}\n */\ngoog.debug.expose = function(obj, opt_showFn) {\n  if (typeof obj == \"undefined\") {\n    return \"undefined\";\n  }\n  if (obj == null) {\n    return \"NULL\";\n  }\n  var str = [];\n  for (var x in obj) {\n    if (!opt_showFn && goog.isFunction(obj[x])) {\n      continue;\n    }\n    var s = x + \" \\x3d \";\n    try {\n      s += obj[x];\n    } catch (e) {\n      s += \"*** \" + e + \" ***\";\n    }\n    str.push(s);\n  }\n  return str.join(\"\\n\");\n};\n/**\n * @param {*} obj\n * @param {boolean=} opt_showFn\n * @return {string}\n */\ngoog.debug.deepExpose = function(obj, opt_showFn) {\n  var str = [];\n  var uidsToCleanup = [];\n  var ancestorUids = {};\n  var helper = function(obj, space) {\n    var nestspace = space + \"  \";\n    var indentMultiline = function(str) {\n      return str.replace(/\\n/g, \"\\n\" + space);\n    };\n    try {\n      if (!goog.isDef(obj)) {\n        str.push(\"undefined\");\n      } else {\n        if (goog.isNull(obj)) {\n          str.push(\"NULL\");\n        } else {\n          if (goog.isString(obj)) {\n            str.push('\"' + indentMultiline(obj) + '\"');\n          } else {\n            if (goog.isFunction(obj)) {\n              str.push(indentMultiline(String(obj)));\n            } else {\n              if (goog.isObject(obj)) {\n                if (!goog.hasUid(obj)) {\n                  uidsToCleanup.push(obj);\n                }\n                var uid = goog.getUid(obj);\n                if (ancestorUids[uid]) {\n                  str.push(\"*** reference loop detected (id\\x3d\" + uid + \") ***\");\n                } else {\n                  ancestorUids[uid] = true;\n                  str.push(\"{\");\n                  for (var x in obj) {\n                    if (!opt_showFn && goog.isFunction(obj[x])) {\n                      continue;\n                    }\n                    str.push(\"\\n\");\n                    str.push(nestspace);\n                    str.push(x + \" \\x3d \");\n                    helper(obj[x], nestspace);\n                  }\n                  str.push(\"\\n\" + space + \"}\");\n                  delete ancestorUids[uid];\n                }\n              } else {\n                str.push(obj);\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      str.push(\"*** \" + e + \" ***\");\n    }\n  };\n  helper(obj, \"\");\n  for (var i = 0; i < uidsToCleanup.length; i++) {\n    goog.removeUid(uidsToCleanup[i]);\n  }\n  return str.join(\"\");\n};\n/**\n * @param {Array<?>} arr\n * @return {string}\n */\ngoog.debug.exposeArray = function(arr) {\n  var str = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (goog.isArray(arr[i])) {\n      str.push(goog.debug.exposeArray(arr[i]));\n    } else {\n      str.push(arr[i]);\n    }\n  }\n  return \"[ \" + str.join(\", \") + \" ]\";\n};\n/**\n * @param {*} err\n * @return {!{message:(?|undefined),name:(?|undefined),lineNumber:(?|undefined),fileName:(?|undefined),stack:(?|undefined)}}\n */\ngoog.debug.normalizeErrorObject = function(err) {\n  var href = goog.getObjectByName(\"window.location.href\");\n  if (goog.isString(err)) {\n    return {\"message\":err, \"name\":\"Unknown error\", \"lineNumber\":\"Not available\", \"fileName\":href, \"stack\":\"Not available\"};\n  }\n  var lineNumber, fileName;\n  var threwError = false;\n  try {\n    lineNumber = err.lineNumber || err.line || \"Not available\";\n  } catch (e) {\n    lineNumber = \"Not available\";\n    threwError = true;\n  }\n  try {\n    fileName = err.fileName || err.filename || err.sourceURL || goog.global[\"$googDebugFname\"] || href;\n  } catch (e$2) {\n    fileName = \"Not available\";\n    threwError = true;\n  }\n  if (threwError || !err.lineNumber || !err.fileName || !err.stack || !err.message || !err.name) {\n    return {\"message\":err.message || \"Not available\", \"name\":err.name || \"UnknownError\", \"lineNumber\":lineNumber, \"fileName\":fileName, \"stack\":err.stack || \"Not available\"};\n  }\n  return (/** @type {?} */ (err));\n};\n/**\n * @param {*} err\n * @param {string=} opt_message\n * @return {!Error}\n */\ngoog.debug.enhanceError = function(err, opt_message) {\n  var error;\n  if (!(err instanceof Error)) {\n    error = Error(err);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, goog.debug.enhanceError);\n    }\n  } else {\n    error = err;\n  }\n  if (!error.stack) {\n    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);\n  }\n  if (opt_message) {\n    var x = 0;\n    while (error[\"message\" + x]) {\n      ++x;\n    }\n    error[\"message\" + x] = String(opt_message);\n  }\n  return error;\n};\n/**\n * @param {*} err\n * @param {!Object<string,string>=} opt_context\n * @return {!Error}\n */\ngoog.debug.enhanceErrorWithContext = function(err, opt_context) {\n  var error = goog.debug.enhanceError(err);\n  if (opt_context) {\n    for (var key in opt_context) {\n      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);\n    }\n  }\n  return error;\n};\n/**\n * @param {number=} opt_depth\n * @return {string}\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktraceSimple = function(opt_depth) {\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);\n    if (stack) {\n      return stack;\n    }\n  }\n  var sb = [];\n  var fn = arguments.callee.caller;\n  var depth = 0;\n  while (fn && (!opt_depth || depth < opt_depth)) {\n    sb.push(goog.debug.getFunctionName(fn));\n    sb.push(\"()\\n\");\n    try {\n      fn = fn.caller;\n    } catch (e) {\n      sb.push(\"[exception trying to get caller]\\n\");\n      break;\n    }\n    depth++;\n    if (depth >= goog.debug.MAX_STACK_DEPTH) {\n      sb.push(\"[...long stack...]\");\n      break;\n    }\n  }\n  if (opt_depth && depth >= opt_depth) {\n    sb.push(\"[...reached max depth limit...]\");\n  } else {\n    sb.push(\"[end]\");\n  }\n  return sb.join(\"\");\n};\n/** @type {number} */ goog.debug.MAX_STACK_DEPTH = 50;\n/**\n * @private\n * @param {Function} fn\n * @return {?string}\n */\ngoog.debug.getNativeStackTrace_ = function(fn) {\n  var tempErr = new Error;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(tempErr, fn);\n    return String(tempErr.stack);\n  } else {\n    try {\n      throw tempErr;\n    } catch (e) {\n      tempErr = e;\n    }\n    var stack = tempErr.stack;\n    if (stack) {\n      return String(stack);\n    }\n  }\n  return null;\n};\n/**\n * @param {?Function=} fn\n * @return {string}\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktrace = function(fn) {\n  var stack;\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    var contextFn = fn || goog.debug.getStacktrace;\n    stack = goog.debug.getNativeStackTrace_(contextFn);\n  }\n  if (!stack) {\n    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);\n  }\n  return stack;\n};\n/**\n * @private\n * @param {?Function} fn\n * @param {Array<!Function>} visited\n * @return {string}\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktraceHelper_ = function(fn, visited) {\n  var sb = [];\n  if (goog.array.contains(visited, fn)) {\n    sb.push(\"[...circular reference...]\");\n  } else {\n    if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {\n      sb.push(goog.debug.getFunctionName(fn) + \"(\");\n      var args = fn.arguments;\n      for (var i = 0; args && i < args.length; i++) {\n        if (i > 0) {\n          sb.push(\", \");\n        }\n        var argDesc;\n        var arg = args[i];\n        switch(typeof arg) {\n          case \"object\":\n            argDesc = arg ? \"object\" : \"null\";\n            break;\n          case \"string\":\n            argDesc = arg;\n            break;\n          case \"number\":\n            argDesc = String(arg);\n            break;\n          case \"boolean\":\n            argDesc = arg ? \"true\" : \"false\";\n            break;\n          case \"function\":\n            argDesc = goog.debug.getFunctionName(arg);\n            argDesc = argDesc ? argDesc : \"[fn]\";\n            break;\n          case \"undefined\":\n          default:\n            argDesc = typeof arg;\n            break;\n        }\n        if (argDesc.length > 40) {\n          argDesc = argDesc.substr(0, 40) + \"...\";\n        }\n        sb.push(argDesc);\n      }\n      visited.push(fn);\n      sb.push(\")\\n\");\n      try {\n        sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));\n      } catch (e) {\n        sb.push(\"[exception trying to get caller]\\n\");\n      }\n    } else {\n      if (fn) {\n        sb.push(\"[...long stack...]\");\n      } else {\n        sb.push(\"[end]\");\n      }\n    }\n  }\n  return sb.join(\"\");\n};\n/**\n * @param {function(Function):string} resolver\n */\ngoog.debug.setFunctionResolver = function(resolver) {\n  goog.debug.fnNameResolver_ = resolver;\n};\n/**\n * @param {Function} fn\n * @return {string}\n */\ngoog.debug.getFunctionName = function(fn) {\n  if (goog.debug.fnNameCache_[fn]) {\n    return goog.debug.fnNameCache_[fn];\n  }\n  if (goog.debug.fnNameResolver_) {\n    var name = goog.debug.fnNameResolver_(fn);\n    if (name) {\n      goog.debug.fnNameCache_[fn] = name;\n      return name;\n    }\n  }\n  var functionSource = String(fn);\n  if (!goog.debug.fnNameCache_[functionSource]) {\n    var matches = /function ([^\\(]+)/.exec(functionSource);\n    if (matches) {\n      var method = matches[1];\n      goog.debug.fnNameCache_[functionSource] = method;\n    } else {\n      goog.debug.fnNameCache_[functionSource] = \"[Anonymous]\";\n    }\n  }\n  return goog.debug.fnNameCache_[functionSource];\n};\n/**\n * @param {string} string\n * @return {string}\n */\ngoog.debug.makeWhitespaceVisible = function(string) {\n  return string.replace(/ /g, \"[_]\").replace(/\\f/g, \"[f]\").replace(/\\n/g, \"[n]\\n\").replace(/\\r/g, \"[r]\").replace(/\\t/g, \"[t]\");\n};\n/**\n * @param {*} value\n * @return {string}\n */\ngoog.debug.runtimeType = function(value) {\n  if (value instanceof Function) {\n    return value.displayName || value.name || \"unknown type name\";\n  } else {\n    if (value instanceof Object) {\n      return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);\n    } else {\n      return value === null ? \"null\" : typeof value;\n    }\n  }\n};\n/** @private @type {Object} */ goog.debug.fnNameCache_ = {};\n/** @private @type {function(Function):string} */ goog.debug.fnNameResolver_;\n","~:source","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Logging and debugging utilities.\n *\n * @see ../demos/debug.html\n */\n\ngoog.provide('goog.debug');\n\ngoog.require('goog.array');\ngoog.require('goog.debug.errorcontext');\ngoog.require('goog.userAgent');\n\n\n/** @define {boolean} Whether logging should be enabled. */\ngoog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);\n\n\n/** @define {boolean} Whether to force \"sloppy\" stack building. */\ngoog.define('goog.debug.FORCE_SLOPPY_STACKS', false);\n\n\n/**\n * Catches onerror events fired by windows and similar objects.\n * @param {function(Object)} logFunc The function to call with the error\n *    information.\n * @param {boolean=} opt_cancel Whether to stop the error from reaching the\n *    browser.\n * @param {Object=} opt_target Object that fires onerror events.\n */\ngoog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {\n  var target = opt_target || goog.global;\n  var oldErrorHandler = target.onerror;\n  var retVal = !!opt_cancel;\n\n  // Chrome interprets onerror return value backwards (http://crbug.com/92062)\n  // until it was fixed in webkit revision r94061 (Webkit 535.3). This\n  // workaround still needs to be skipped in Safari after the webkit change\n  // gets pushed out in Safari.\n  // See https://bugs.webkit.org/show_bug.cgi?id=67119\n  if (goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher('535.3')) {\n    retVal = !retVal;\n  }\n\n  /**\n   * New onerror handler for this target. This onerror handler follows the spec\n   * according to\n   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors\n   * The spec was changed in August 2013 to support receiving column information\n   * and an error object for all scripts on the same origin or cross origin\n   * scripts with the proper headers. See\n   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n   *\n   * @param {string} message The error message. For cross-origin errors, this\n   *     will be scrubbed to just \"Script error.\". For new browsers that have\n   *     updated to follow the latest spec, errors that come from origins that\n   *     have proper cross origin headers will not be scrubbed.\n   * @param {string} url The URL of the script that caused the error. The URL\n   *     will be scrubbed to \"\" for cross origin scripts unless the script has\n   *     proper cross origin headers and the browser has updated to the latest\n   *     spec.\n   * @param {number} line The line number in the script that the error\n   *     occurred on.\n   * @param {number=} opt_col The optional column number that the error\n   *     occurred on. Only browsers that have updated to the latest spec will\n   *     include this.\n   * @param {Error=} opt_error The optional actual error object for this\n   *     error that should include the stack. Only browsers that have updated\n   *     to the latest spec will inlude this parameter.\n   * @return {boolean} Whether to prevent the error from reaching the browser.\n   */\n  target.onerror = function(message, url, line, opt_col, opt_error) {\n    if (oldErrorHandler) {\n      oldErrorHandler(message, url, line, opt_col, opt_error);\n    }\n    logFunc({\n      message: message,\n      fileName: url,\n      line: line,\n      col: opt_col,\n      error: opt_error\n    });\n    return retVal;\n  };\n};\n\n\n/**\n * Creates a string representing an object and all its properties.\n * @param {Object|null|undefined} obj Object to expose.\n * @param {boolean=} opt_showFn Show the functions as well as the properties,\n *     default is false.\n * @return {string} The string representation of {@code obj}.\n */\ngoog.debug.expose = function(obj, opt_showFn) {\n  if (typeof obj == 'undefined') {\n    return 'undefined';\n  }\n  if (obj == null) {\n    return 'NULL';\n  }\n  var str = [];\n\n  for (var x in obj) {\n    if (!opt_showFn && goog.isFunction(obj[x])) {\n      continue;\n    }\n    var s = x + ' = ';\n\n    try {\n      s += obj[x];\n    } catch (e) {\n      s += '*** ' + e + ' ***';\n    }\n    str.push(s);\n  }\n  return str.join('\\n');\n};\n\n\n/**\n * Creates a string representing a given primitive or object, and for an\n * object, all its properties and nested objects. NOTE: The output will include\n * Uids on all objects that were exposed. Any added Uids will be removed before\n * returning.\n * @param {*} obj Object to expose.\n * @param {boolean=} opt_showFn Also show properties that are functions (by\n *     default, functions are omitted).\n * @return {string} A string representation of {@code obj}.\n */\ngoog.debug.deepExpose = function(obj, opt_showFn) {\n  var str = [];\n\n  // Track any objects where deepExpose added a Uid, so they can be cleaned up\n  // before return. We do this globally, rather than only on ancestors so that\n  // if the same object appears in the output, you can see it.\n  var uidsToCleanup = [];\n  var ancestorUids = {};\n\n  var helper = function(obj, space) {\n    var nestspace = space + '  ';\n\n    var indentMultiline = function(str) {\n      return str.replace(/\\n/g, '\\n' + space);\n    };\n\n\n    try {\n      if (!goog.isDef(obj)) {\n        str.push('undefined');\n      } else if (goog.isNull(obj)) {\n        str.push('NULL');\n      } else if (goog.isString(obj)) {\n        str.push('\"' + indentMultiline(obj) + '\"');\n      } else if (goog.isFunction(obj)) {\n        str.push(indentMultiline(String(obj)));\n      } else if (goog.isObject(obj)) {\n        // Add a Uid if needed. The struct calls implicitly adds them.\n        if (!goog.hasUid(obj)) {\n          uidsToCleanup.push(obj);\n        }\n        var uid = goog.getUid(obj);\n        if (ancestorUids[uid]) {\n          str.push('*** reference loop detected (id=' + uid + ') ***');\n        } else {\n          ancestorUids[uid] = true;\n          str.push('{');\n          for (var x in obj) {\n            if (!opt_showFn && goog.isFunction(obj[x])) {\n              continue;\n            }\n            str.push('\\n');\n            str.push(nestspace);\n            str.push(x + ' = ');\n            helper(obj[x], nestspace);\n          }\n          str.push('\\n' + space + '}');\n          delete ancestorUids[uid];\n        }\n      } else {\n        str.push(obj);\n      }\n    } catch (e) {\n      str.push('*** ' + e + ' ***');\n    }\n  };\n\n  helper(obj, '');\n\n  // Cleanup any Uids that were added by the deepExpose.\n  for (var i = 0; i < uidsToCleanup.length; i++) {\n    goog.removeUid(uidsToCleanup[i]);\n  }\n\n  return str.join('');\n};\n\n\n/**\n * Recursively outputs a nested array as a string.\n * @param {Array<?>} arr The array.\n * @return {string} String representing nested array.\n */\ngoog.debug.exposeArray = function(arr) {\n  var str = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (goog.isArray(arr[i])) {\n      str.push(goog.debug.exposeArray(arr[i]));\n    } else {\n      str.push(arr[i]);\n    }\n  }\n  return '[ ' + str.join(', ') + ' ]';\n};\n\n\n/**\n * Normalizes the error/exception object between browsers.\n * @param {*} err Raw error object.\n * @return {!{\n *    message: (?|undefined),\n *    name: (?|undefined),\n *    lineNumber: (?|undefined),\n *    fileName: (?|undefined),\n *    stack: (?|undefined)\n * }} Normalized error object.\n */\ngoog.debug.normalizeErrorObject = function(err) {\n  var href = goog.getObjectByName('window.location.href');\n  if (goog.isString(err)) {\n    return {\n      'message': err,\n      'name': 'Unknown error',\n      'lineNumber': 'Not available',\n      'fileName': href,\n      'stack': 'Not available'\n    };\n  }\n\n  var lineNumber, fileName;\n  var threwError = false;\n\n  try {\n    lineNumber = err.lineNumber || err.line || 'Not available';\n  } catch (e) {\n    // Firefox 2 sometimes throws an error when accessing 'lineNumber':\n    // Message: Permission denied to get property UnnamedClass.lineNumber\n    lineNumber = 'Not available';\n    threwError = true;\n  }\n\n  try {\n    fileName = err.fileName || err.filename || err.sourceURL ||\n        // $googDebugFname may be set before a call to eval to set the filename\n        // that the eval is supposed to present.\n        goog.global['$googDebugFname'] || href;\n  } catch (e) {\n    // Firefox 2 may also throw an error when accessing 'filename'.\n    fileName = 'Not available';\n    threwError = true;\n  }\n\n  // The IE Error object contains only the name and the message.\n  // The Safari Error object uses the line and sourceURL fields.\n  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||\n      !err.message || !err.name) {\n    return {\n      'message': err.message || 'Not available',\n      'name': err.name || 'UnknownError',\n      'lineNumber': lineNumber,\n      'fileName': fileName,\n      'stack': err.stack || 'Not available'\n    };\n  }\n\n  // Standards error object\n  // Typed !Object. Should be a subtype of the return type, but it's not.\n  return /** @type {?} */ (err);\n};\n\n\n/**\n * Converts an object to an Error using the object's toString if it's not\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\n * an extra message.\n * @param {*} err The original thrown error, object, or string.\n * @param {string=} opt_message  optional additional message to add to the\n *     error.\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\n *     it is converted to an Error which is enhanced and returned.\n */\ngoog.debug.enhanceError = function(err, opt_message) {\n  var error;\n  if (!(err instanceof Error)) {\n    error = Error(err);\n    if (Error.captureStackTrace) {\n      // Trim this function off the call stack, if we can.\n      Error.captureStackTrace(error, goog.debug.enhanceError);\n    }\n  } else {\n    error = err;\n  }\n\n  if (!error.stack) {\n    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);\n  }\n  if (opt_message) {\n    // find the first unoccupied 'messageX' property\n    var x = 0;\n    while (error['message' + x]) {\n      ++x;\n    }\n    error['message' + x] = String(opt_message);\n  }\n  return error;\n};\n\n\n/**\n * Converts an object to an Error using the object's toString if it's not\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\n * context to the Error, which is reported by the closure error reporter.\n * @param {*} err The original thrown error, object, or string.\n * @param {!Object<string, string>=} opt_context Key-value context to add to the\n *     Error.\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\n *     it is converted to an Error which is enhanced and returned.\n */\ngoog.debug.enhanceErrorWithContext = function(err, opt_context) {\n  var error = goog.debug.enhanceError(err);\n  if (opt_context) {\n    for (var key in opt_context) {\n      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);\n    }\n  }\n  return error;\n};\n\n\n/**\n * Gets the current stack trace. Simple and iterative - doesn't worry about\n * catching circular references or getting the args.\n * @param {number=} opt_depth Optional maximum depth to trace back to.\n * @return {string} A string with the function names of all functions in the\n *     stack, separated by \\n.\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktraceSimple = function(opt_depth) {\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);\n    if (stack) {\n      return stack;\n    }\n    // NOTE: browsers that have strict mode support also have native \"stack\"\n    // properties.  Fall-through for legacy browser support.\n  }\n\n  var sb = [];\n  var fn = arguments.callee.caller;\n  var depth = 0;\n\n  while (fn && (!opt_depth || depth < opt_depth)) {\n    sb.push(goog.debug.getFunctionName(fn));\n    sb.push('()\\n');\n\n    try {\n      fn = fn.caller;\n    } catch (e) {\n      sb.push('[exception trying to get caller]\\n');\n      break;\n    }\n    depth++;\n    if (depth >= goog.debug.MAX_STACK_DEPTH) {\n      sb.push('[...long stack...]');\n      break;\n    }\n  }\n  if (opt_depth && depth >= opt_depth) {\n    sb.push('[...reached max depth limit...]');\n  } else {\n    sb.push('[end]');\n  }\n\n  return sb.join('');\n};\n\n\n/**\n * Max length of stack to try and output\n * @type {number}\n */\ngoog.debug.MAX_STACK_DEPTH = 50;\n\n\n/**\n * @param {Function} fn The function to start getting the trace from.\n * @return {?string}\n * @private\n */\ngoog.debug.getNativeStackTrace_ = function(fn) {\n  var tempErr = new Error();\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(tempErr, fn);\n    return String(tempErr.stack);\n  } else {\n    // IE10, only adds stack traces when an exception is thrown.\n    try {\n      throw tempErr;\n    } catch (e) {\n      tempErr = e;\n    }\n    var stack = tempErr.stack;\n    if (stack) {\n      return String(stack);\n    }\n  }\n  return null;\n};\n\n\n/**\n * Gets the current stack trace, either starting from the caller or starting\n * from a specified function that's currently on the call stack.\n * @param {?Function=} fn If provided, when collecting the stack trace all\n *     frames above the topmost call to this function, including that call,\n *     will be left out of the stack trace.\n * @return {string} Stack trace.\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktrace = function(fn) {\n  var stack;\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    // Try to get the stack trace from the environment if it is available.\n    var contextFn = fn || goog.debug.getStacktrace;\n    stack = goog.debug.getNativeStackTrace_(contextFn);\n  }\n  if (!stack) {\n    // NOTE: browsers that have strict mode support also have native \"stack\"\n    // properties. This function will throw in strict mode.\n    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);\n  }\n  return stack;\n};\n\n\n/**\n * Private helper for getStacktrace().\n * @param {?Function} fn If provided, when collecting the stack trace all\n *     frames above the topmost call to this function, including that call,\n *     will be left out of the stack trace.\n * @param {Array<!Function>} visited List of functions visited so far.\n * @return {string} Stack trace starting from function fn.\n * @suppress {es5Strict}\n * @private\n */\ngoog.debug.getStacktraceHelper_ = function(fn, visited) {\n  var sb = [];\n\n  // Circular reference, certain functions like bind seem to cause a recursive\n  // loop so we need to catch circular references\n  if (goog.array.contains(visited, fn)) {\n    sb.push('[...circular reference...]');\n\n    // Traverse the call stack until function not found or max depth is reached\n  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {\n    sb.push(goog.debug.getFunctionName(fn) + '(');\n    var args = fn.arguments;\n    // Args may be null for some special functions such as host objects or eval.\n    for (var i = 0; args && i < args.length; i++) {\n      if (i > 0) {\n        sb.push(', ');\n      }\n      var argDesc;\n      var arg = args[i];\n      switch (typeof arg) {\n        case 'object':\n          argDesc = arg ? 'object' : 'null';\n          break;\n\n        case 'string':\n          argDesc = arg;\n          break;\n\n        case 'number':\n          argDesc = String(arg);\n          break;\n\n        case 'boolean':\n          argDesc = arg ? 'true' : 'false';\n          break;\n\n        case 'function':\n          argDesc = goog.debug.getFunctionName(arg);\n          argDesc = argDesc ? argDesc : '[fn]';\n          break;\n\n        case 'undefined':\n        default:\n          argDesc = typeof arg;\n          break;\n      }\n\n      if (argDesc.length > 40) {\n        argDesc = argDesc.substr(0, 40) + '...';\n      }\n      sb.push(argDesc);\n    }\n    visited.push(fn);\n    sb.push(')\\n');\n\n    try {\n      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));\n    } catch (e) {\n      sb.push('[exception trying to get caller]\\n');\n    }\n\n  } else if (fn) {\n    sb.push('[...long stack...]');\n  } else {\n    sb.push('[end]');\n  }\n  return sb.join('');\n};\n\n\n/**\n * Set a custom function name resolver.\n * @param {function(Function): string} resolver Resolves functions to their\n *     names.\n */\ngoog.debug.setFunctionResolver = function(resolver) {\n  goog.debug.fnNameResolver_ = resolver;\n};\n\n\n/**\n * Gets a function name\n * @param {Function} fn Function to get name of.\n * @return {string} Function's name.\n */\ngoog.debug.getFunctionName = function(fn) {\n  if (goog.debug.fnNameCache_[fn]) {\n    return goog.debug.fnNameCache_[fn];\n  }\n  if (goog.debug.fnNameResolver_) {\n    var name = goog.debug.fnNameResolver_(fn);\n    if (name) {\n      goog.debug.fnNameCache_[fn] = name;\n      return name;\n    }\n  }\n\n  // Heuristically determine function name based on code.\n  var functionSource = String(fn);\n  if (!goog.debug.fnNameCache_[functionSource]) {\n    var matches = /function ([^\\(]+)/.exec(functionSource);\n    if (matches) {\n      var method = matches[1];\n      goog.debug.fnNameCache_[functionSource] = method;\n    } else {\n      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';\n    }\n  }\n\n  return goog.debug.fnNameCache_[functionSource];\n};\n\n\n/**\n * Makes whitespace visible by replacing it with printable characters.\n * This is useful in finding diffrences between the expected and the actual\n * output strings of a testcase.\n * @param {string} string whose whitespace needs to be made visible.\n * @return {string} string whose whitespace is made visible.\n */\ngoog.debug.makeWhitespaceVisible = function(string) {\n  return string.replace(/ /g, '[_]')\n      .replace(/\\f/g, '[f]')\n      .replace(/\\n/g, '[n]\\n')\n      .replace(/\\r/g, '[r]')\n      .replace(/\\t/g, '[t]');\n};\n\n\n/**\n * Returns the type of a value. If a constructor is passed, and a suitable\n * string cannot be found, 'unknown type name' will be returned.\n *\n * <p>Forked rather than moved from {@link goog.asserts.getType_}\n * to avoid adding a dependency to goog.asserts.\n * @param {*} value A constructor, object, or primitive.\n * @return {string} The best display name for the value, or 'unknown type name'.\n */\ngoog.debug.runtimeType = function(value) {\n  if (value instanceof Function) {\n    return value.displayName || value.name || 'unknown type name';\n  } else if (value instanceof Object) {\n    return value.constructor.displayName || value.constructor.name ||\n        Object.prototype.toString.call(value);\n  } else {\n    return value === null ? 'null' : typeof value;\n  }\n};\n\n\n/**\n * Hash map for storing function names that have already been looked up.\n * @type {Object}\n * @private\n */\ngoog.debug.fnNameCache_ = {};\n\n\n/**\n * Resolves functions to their names.  Resolved function names will be cached.\n * @type {function(Function):string}\n * @private\n */\ngoog.debug.fnNameResolver_;\n","~:compiled-at",1574163696288,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.debug.debug.js\",\n\"lineCount\":411,\n\"mappings\":\"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\",\n\"sources\":[\"goog/debug/debug.js\"],\n\"sourcesContent\":[\"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Logging and debugging utilities.\\n *\\n * @see ../demos/debug.html\\n */\\n\\ngoog.provide('goog.debug');\\n\\ngoog.require('goog.array');\\ngoog.require('goog.debug.errorcontext');\\ngoog.require('goog.userAgent');\\n\\n\\n/** @define {boolean} Whether logging should be enabled. */\\ngoog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);\\n\\n\\n/** @define {boolean} Whether to force \\\"sloppy\\\" stack building. */\\ngoog.define('goog.debug.FORCE_SLOPPY_STACKS', false);\\n\\n\\n/**\\n * Catches onerror events fired by windows and similar objects.\\n * @param {function(Object)} logFunc The function to call with the error\\n *    information.\\n * @param {boolean=} opt_cancel Whether to stop the error from reaching the\\n *    browser.\\n * @param {Object=} opt_target Object that fires onerror events.\\n */\\ngoog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {\\n  var target = opt_target || goog.global;\\n  var oldErrorHandler = target.onerror;\\n  var retVal = !!opt_cancel;\\n\\n  // Chrome interprets onerror return value backwards (http://crbug.com/92062)\\n  // until it was fixed in webkit revision r94061 (Webkit 535.3). This\\n  // workaround still needs to be skipped in Safari after the webkit change\\n  // gets pushed out in Safari.\\n  // See https://bugs.webkit.org/show_bug.cgi?id=67119\\n  if (goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher('535.3')) {\\n    retVal = !retVal;\\n  }\\n\\n  /**\\n   * New onerror handler for this target. This onerror handler follows the spec\\n   * according to\\n   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors\\n   * The spec was changed in August 2013 to support receiving column information\\n   * and an error object for all scripts on the same origin or cross origin\\n   * scripts with the proper headers. See\\n   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\\n   *\\n   * @param {string} message The error message. For cross-origin errors, this\\n   *     will be scrubbed to just \\\"Script error.\\\". For new browsers that have\\n   *     updated to follow the latest spec, errors that come from origins that\\n   *     have proper cross origin headers will not be scrubbed.\\n   * @param {string} url The URL of the script that caused the error. The URL\\n   *     will be scrubbed to \\\"\\\" for cross origin scripts unless the script has\\n   *     proper cross origin headers and the browser has updated to the latest\\n   *     spec.\\n   * @param {number} line The line number in the script that the error\\n   *     occurred on.\\n   * @param {number=} opt_col The optional column number that the error\\n   *     occurred on. Only browsers that have updated to the latest spec will\\n   *     include this.\\n   * @param {Error=} opt_error The optional actual error object for this\\n   *     error that should include the stack. Only browsers that have updated\\n   *     to the latest spec will inlude this parameter.\\n   * @return {boolean} Whether to prevent the error from reaching the browser.\\n   */\\n  target.onerror = function(message, url, line, opt_col, opt_error) {\\n    if (oldErrorHandler) {\\n      oldErrorHandler(message, url, line, opt_col, opt_error);\\n    }\\n    logFunc({\\n      message: message,\\n      fileName: url,\\n      line: line,\\n      col: opt_col,\\n      error: opt_error\\n    });\\n    return retVal;\\n  };\\n};\\n\\n\\n/**\\n * Creates a string representing an object and all its properties.\\n * @param {Object|null|undefined} obj Object to expose.\\n * @param {boolean=} opt_showFn Show the functions as well as the properties,\\n *     default is false.\\n * @return {string} The string representation of {@code obj}.\\n */\\ngoog.debug.expose = function(obj, opt_showFn) {\\n  if (typeof obj == 'undefined') {\\n    return 'undefined';\\n  }\\n  if (obj == null) {\\n    return 'NULL';\\n  }\\n  var str = [];\\n\\n  for (var x in obj) {\\n    if (!opt_showFn && goog.isFunction(obj[x])) {\\n      continue;\\n    }\\n    var s = x + ' = ';\\n\\n    try {\\n      s += obj[x];\\n    } catch (e) {\\n      s += '*** ' + e + ' ***';\\n    }\\n    str.push(s);\\n  }\\n  return str.join('\\\\n');\\n};\\n\\n\\n/**\\n * Creates a string representing a given primitive or object, and for an\\n * object, all its properties and nested objects. NOTE: The output will include\\n * Uids on all objects that were exposed. Any added Uids will be removed before\\n * returning.\\n * @param {*} obj Object to expose.\\n * @param {boolean=} opt_showFn Also show properties that are functions (by\\n *     default, functions are omitted).\\n * @return {string} A string representation of {@code obj}.\\n */\\ngoog.debug.deepExpose = function(obj, opt_showFn) {\\n  var str = [];\\n\\n  // Track any objects where deepExpose added a Uid, so they can be cleaned up\\n  // before return. We do this globally, rather than only on ancestors so that\\n  // if the same object appears in the output, you can see it.\\n  var uidsToCleanup = [];\\n  var ancestorUids = {};\\n\\n  var helper = function(obj, space) {\\n    var nestspace = space + '  ';\\n\\n    var indentMultiline = function(str) {\\n      return str.replace(/\\\\n/g, '\\\\n' + space);\\n    };\\n\\n\\n    try {\\n      if (!goog.isDef(obj)) {\\n        str.push('undefined');\\n      } else if (goog.isNull(obj)) {\\n        str.push('NULL');\\n      } else if (goog.isString(obj)) {\\n        str.push('\\\"' + indentMultiline(obj) + '\\\"');\\n      } else if (goog.isFunction(obj)) {\\n        str.push(indentMultiline(String(obj)));\\n      } else if (goog.isObject(obj)) {\\n        // Add a Uid if needed. The struct calls implicitly adds them.\\n        if (!goog.hasUid(obj)) {\\n          uidsToCleanup.push(obj);\\n        }\\n        var uid = goog.getUid(obj);\\n        if (ancestorUids[uid]) {\\n          str.push('*** reference loop detected (id=' + uid + ') ***');\\n        } else {\\n          ancestorUids[uid] = true;\\n          str.push('{');\\n          for (var x in obj) {\\n            if (!opt_showFn && goog.isFunction(obj[x])) {\\n              continue;\\n            }\\n            str.push('\\\\n');\\n            str.push(nestspace);\\n            str.push(x + ' = ');\\n            helper(obj[x], nestspace);\\n          }\\n          str.push('\\\\n' + space + '}');\\n          delete ancestorUids[uid];\\n        }\\n      } else {\\n        str.push(obj);\\n      }\\n    } catch (e) {\\n      str.push('*** ' + e + ' ***');\\n    }\\n  };\\n\\n  helper(obj, '');\\n\\n  // Cleanup any Uids that were added by the deepExpose.\\n  for (var i = 0; i < uidsToCleanup.length; i++) {\\n    goog.removeUid(uidsToCleanup[i]);\\n  }\\n\\n  return str.join('');\\n};\\n\\n\\n/**\\n * Recursively outputs a nested array as a string.\\n * @param {Array<?>} arr The array.\\n * @return {string} String representing nested array.\\n */\\ngoog.debug.exposeArray = function(arr) {\\n  var str = [];\\n  for (var i = 0; i < arr.length; i++) {\\n    if (goog.isArray(arr[i])) {\\n      str.push(goog.debug.exposeArray(arr[i]));\\n    } else {\\n      str.push(arr[i]);\\n    }\\n  }\\n  return '[ ' + str.join(', ') + ' ]';\\n};\\n\\n\\n/**\\n * Normalizes the error/exception object between browsers.\\n * @param {*} err Raw error object.\\n * @return {!{\\n *    message: (?|undefined),\\n *    name: (?|undefined),\\n *    lineNumber: (?|undefined),\\n *    fileName: (?|undefined),\\n *    stack: (?|undefined)\\n * }} Normalized error object.\\n */\\ngoog.debug.normalizeErrorObject = function(err) {\\n  var href = goog.getObjectByName('window.location.href');\\n  if (goog.isString(err)) {\\n    return {\\n      'message': err,\\n      'name': 'Unknown error',\\n      'lineNumber': 'Not available',\\n      'fileName': href,\\n      'stack': 'Not available'\\n    };\\n  }\\n\\n  var lineNumber, fileName;\\n  var threwError = false;\\n\\n  try {\\n    lineNumber = err.lineNumber || err.line || 'Not available';\\n  } catch (e) {\\n    // Firefox 2 sometimes throws an error when accessing 'lineNumber':\\n    // Message: Permission denied to get property UnnamedClass.lineNumber\\n    lineNumber = 'Not available';\\n    threwError = true;\\n  }\\n\\n  try {\\n    fileName = err.fileName || err.filename || err.sourceURL ||\\n        // $googDebugFname may be set before a call to eval to set the filename\\n        // that the eval is supposed to present.\\n        goog.global['$googDebugFname'] || href;\\n  } catch (e) {\\n    // Firefox 2 may also throw an error when accessing 'filename'.\\n    fileName = 'Not available';\\n    threwError = true;\\n  }\\n\\n  // The IE Error object contains only the name and the message.\\n  // The Safari Error object uses the line and sourceURL fields.\\n  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||\\n      !err.message || !err.name) {\\n    return {\\n      'message': err.message || 'Not available',\\n      'name': err.name || 'UnknownError',\\n      'lineNumber': lineNumber,\\n      'fileName': fileName,\\n      'stack': err.stack || 'Not available'\\n    };\\n  }\\n\\n  // Standards error object\\n  // Typed !Object. Should be a subtype of the return type, but it's not.\\n  return /** @type {?} */ (err);\\n};\\n\\n\\n/**\\n * Converts an object to an Error using the object's toString if it's not\\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\\n * an extra message.\\n * @param {*} err The original thrown error, object, or string.\\n * @param {string=} opt_message  optional additional message to add to the\\n *     error.\\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\\n *     it is converted to an Error which is enhanced and returned.\\n */\\ngoog.debug.enhanceError = function(err, opt_message) {\\n  var error;\\n  if (!(err instanceof Error)) {\\n    error = Error(err);\\n    if (Error.captureStackTrace) {\\n      // Trim this function off the call stack, if we can.\\n      Error.captureStackTrace(error, goog.debug.enhanceError);\\n    }\\n  } else {\\n    error = err;\\n  }\\n\\n  if (!error.stack) {\\n    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);\\n  }\\n  if (opt_message) {\\n    // find the first unoccupied 'messageX' property\\n    var x = 0;\\n    while (error['message' + x]) {\\n      ++x;\\n    }\\n    error['message' + x] = String(opt_message);\\n  }\\n  return error;\\n};\\n\\n\\n/**\\n * Converts an object to an Error using the object's toString if it's not\\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\\n * context to the Error, which is reported by the closure error reporter.\\n * @param {*} err The original thrown error, object, or string.\\n * @param {!Object<string, string>=} opt_context Key-value context to add to the\\n *     Error.\\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\\n *     it is converted to an Error which is enhanced and returned.\\n */\\ngoog.debug.enhanceErrorWithContext = function(err, opt_context) {\\n  var error = goog.debug.enhanceError(err);\\n  if (opt_context) {\\n    for (var key in opt_context) {\\n      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);\\n    }\\n  }\\n  return error;\\n};\\n\\n\\n/**\\n * Gets the current stack trace. Simple and iterative - doesn't worry about\\n * catching circular references or getting the args.\\n * @param {number=} opt_depth Optional maximum depth to trace back to.\\n * @return {string} A string with the function names of all functions in the\\n *     stack, separated by \\\\n.\\n * @suppress {es5Strict}\\n */\\ngoog.debug.getStacktraceSimple = function(opt_depth) {\\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\\n    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);\\n    if (stack) {\\n      return stack;\\n    }\\n    // NOTE: browsers that have strict mode support also have native \\\"stack\\\"\\n    // properties.  Fall-through for legacy browser support.\\n  }\\n\\n  var sb = [];\\n  var fn = arguments.callee.caller;\\n  var depth = 0;\\n\\n  while (fn && (!opt_depth || depth < opt_depth)) {\\n    sb.push(goog.debug.getFunctionName(fn));\\n    sb.push('()\\\\n');\\n\\n    try {\\n      fn = fn.caller;\\n    } catch (e) {\\n      sb.push('[exception trying to get caller]\\\\n');\\n      break;\\n    }\\n    depth++;\\n    if (depth >= goog.debug.MAX_STACK_DEPTH) {\\n      sb.push('[...long stack...]');\\n      break;\\n    }\\n  }\\n  if (opt_depth && depth >= opt_depth) {\\n    sb.push('[...reached max depth limit...]');\\n  } else {\\n    sb.push('[end]');\\n  }\\n\\n  return sb.join('');\\n};\\n\\n\\n/**\\n * Max length of stack to try and output\\n * @type {number}\\n */\\ngoog.debug.MAX_STACK_DEPTH = 50;\\n\\n\\n/**\\n * @param {Function} fn The function to start getting the trace from.\\n * @return {?string}\\n * @private\\n */\\ngoog.debug.getNativeStackTrace_ = function(fn) {\\n  var tempErr = new Error();\\n  if (Error.captureStackTrace) {\\n    Error.captureStackTrace(tempErr, fn);\\n    return String(tempErr.stack);\\n  } else {\\n    // IE10, only adds stack traces when an exception is thrown.\\n    try {\\n      throw tempErr;\\n    } catch (e) {\\n      tempErr = e;\\n    }\\n    var stack = tempErr.stack;\\n    if (stack) {\\n      return String(stack);\\n    }\\n  }\\n  return null;\\n};\\n\\n\\n/**\\n * Gets the current stack trace, either starting from the caller or starting\\n * from a specified function that's currently on the call stack.\\n * @param {?Function=} fn If provided, when collecting the stack trace all\\n *     frames above the topmost call to this function, including that call,\\n *     will be left out of the stack trace.\\n * @return {string} Stack trace.\\n * @suppress {es5Strict}\\n */\\ngoog.debug.getStacktrace = function(fn) {\\n  var stack;\\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\\n    // Try to get the stack trace from the environment if it is available.\\n    var contextFn = fn || goog.debug.getStacktrace;\\n    stack = goog.debug.getNativeStackTrace_(contextFn);\\n  }\\n  if (!stack) {\\n    // NOTE: browsers that have strict mode support also have native \\\"stack\\\"\\n    // properties. This function will throw in strict mode.\\n    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);\\n  }\\n  return stack;\\n};\\n\\n\\n/**\\n * Private helper for getStacktrace().\\n * @param {?Function} fn If provided, when collecting the stack trace all\\n *     frames above the topmost call to this function, including that call,\\n *     will be left out of the stack trace.\\n * @param {Array<!Function>} visited List of functions visited so far.\\n * @return {string} Stack trace starting from function fn.\\n * @suppress {es5Strict}\\n * @private\\n */\\ngoog.debug.getStacktraceHelper_ = function(fn, visited) {\\n  var sb = [];\\n\\n  // Circular reference, certain functions like bind seem to cause a recursive\\n  // loop so we need to catch circular references\\n  if (goog.array.contains(visited, fn)) {\\n    sb.push('[...circular reference...]');\\n\\n    // Traverse the call stack until function not found or max depth is reached\\n  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {\\n    sb.push(goog.debug.getFunctionName(fn) + '(');\\n    var args = fn.arguments;\\n    // Args may be null for some special functions such as host objects or eval.\\n    for (var i = 0; args && i < args.length; i++) {\\n      if (i > 0) {\\n        sb.push(', ');\\n      }\\n      var argDesc;\\n      var arg = args[i];\\n      switch (typeof arg) {\\n        case 'object':\\n          argDesc = arg ? 'object' : 'null';\\n          break;\\n\\n        case 'string':\\n          argDesc = arg;\\n          break;\\n\\n        case 'number':\\n          argDesc = String(arg);\\n          break;\\n\\n        case 'boolean':\\n          argDesc = arg ? 'true' : 'false';\\n          break;\\n\\n        case 'function':\\n          argDesc = goog.debug.getFunctionName(arg);\\n          argDesc = argDesc ? argDesc : '[fn]';\\n          break;\\n\\n        case 'undefined':\\n        default:\\n          argDesc = typeof arg;\\n          break;\\n      }\\n\\n      if (argDesc.length > 40) {\\n        argDesc = argDesc.substr(0, 40) + '...';\\n      }\\n      sb.push(argDesc);\\n    }\\n    visited.push(fn);\\n    sb.push(')\\\\n');\\n\\n    try {\\n      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));\\n    } catch (e) {\\n      sb.push('[exception trying to get caller]\\\\n');\\n    }\\n\\n  } else if (fn) {\\n    sb.push('[...long stack...]');\\n  } else {\\n    sb.push('[end]');\\n  }\\n  return sb.join('');\\n};\\n\\n\\n/**\\n * Set a custom function name resolver.\\n * @param {function(Function): string} resolver Resolves functions to their\\n *     names.\\n */\\ngoog.debug.setFunctionResolver = function(resolver) {\\n  goog.debug.fnNameResolver_ = resolver;\\n};\\n\\n\\n/**\\n * Gets a function name\\n * @param {Function} fn Function to get name of.\\n * @return {string} Function's name.\\n */\\ngoog.debug.getFunctionName = function(fn) {\\n  if (goog.debug.fnNameCache_[fn]) {\\n    return goog.debug.fnNameCache_[fn];\\n  }\\n  if (goog.debug.fnNameResolver_) {\\n    var name = goog.debug.fnNameResolver_(fn);\\n    if (name) {\\n      goog.debug.fnNameCache_[fn] = name;\\n      return name;\\n    }\\n  }\\n\\n  // Heuristically determine function name based on code.\\n  var functionSource = String(fn);\\n  if (!goog.debug.fnNameCache_[functionSource]) {\\n    var matches = /function ([^\\\\(]+)/.exec(functionSource);\\n    if (matches) {\\n      var method = matches[1];\\n      goog.debug.fnNameCache_[functionSource] = method;\\n    } else {\\n      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';\\n    }\\n  }\\n\\n  return goog.debug.fnNameCache_[functionSource];\\n};\\n\\n\\n/**\\n * Makes whitespace visible by replacing it with printable characters.\\n * This is useful in finding diffrences between the expected and the actual\\n * output strings of a testcase.\\n * @param {string} string whose whitespace needs to be made visible.\\n * @return {string} string whose whitespace is made visible.\\n */\\ngoog.debug.makeWhitespaceVisible = function(string) {\\n  return string.replace(/ /g, '[_]')\\n      .replace(/\\\\f/g, '[f]')\\n      .replace(/\\\\n/g, '[n]\\\\n')\\n      .replace(/\\\\r/g, '[r]')\\n      .replace(/\\\\t/g, '[t]');\\n};\\n\\n\\n/**\\n * Returns the type of a value. If a constructor is passed, and a suitable\\n * string cannot be found, 'unknown type name' will be returned.\\n *\\n * <p>Forked rather than moved from {@link goog.asserts.getType_}\\n * to avoid adding a dependency to goog.asserts.\\n * @param {*} value A constructor, object, or primitive.\\n * @return {string} The best display name for the value, or 'unknown type name'.\\n */\\ngoog.debug.runtimeType = function(value) {\\n  if (value instanceof Function) {\\n    return value.displayName || value.name || 'unknown type name';\\n  } else if (value instanceof Object) {\\n    return value.constructor.displayName || value.constructor.name ||\\n        Object.prototype.toString.call(value);\\n  } else {\\n    return value === null ? 'null' : typeof value;\\n  }\\n};\\n\\n\\n/**\\n * Hash map for storing function names that have already been looked up.\\n * @type {Object}\\n * @private\\n */\\ngoog.debug.fnNameCache_ = {};\\n\\n\\n/**\\n * Resolves functions to their names.  Resolved function names will be cached.\\n * @type {function(Function):string}\\n * @private\\n */\\ngoog.debug.fnNameResolver_;\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"define\",\"DEBUG\",\"debug\",\"catchErrors\",\"goog.debug.catchErrors\",\"logFunc\",\"opt_cancel\",\"opt_target\",\"target\",\"global\",\"oldErrorHandler\",\"onerror\",\"retVal\",\"userAgent\",\"WEBKIT\",\"isVersionOrHigher\",\"target.onerror\",\"message\",\"url\",\"line\",\"opt_col\",\"opt_error\",\"fileName\",\"col\",\"error\",\"expose\",\"goog.debug.expose\",\"obj\",\"opt_showFn\",\"str\",\"x\",\"isFunction\",\"s\",\"e\",\"push\",\"join\",\"deepExpose\",\"goog.debug.deepExpose\",\"uidsToCleanup\",\"ancestorUids\",\"helper\",\"space\",\"nestspace\",\"indentMultiline\",\"replace\",\"isDef\",\"isNull\",\"isString\",\"String\",\"isObject\",\"hasUid\",\"uid\",\"getUid\",\"i\",\"length\",\"removeUid\",\"exposeArray\",\"goog.debug.exposeArray\",\"arr\",\"isArray\",\"normalizeErrorObject\",\"goog.debug.normalizeErrorObject\",\"err\",\"href\",\"getObjectByName\",\"lineNumber\",\"threwError\",\"filename\",\"sourceURL\",\"stack\",\"name\",\"enhanceError\",\"goog.debug.enhanceError\",\"opt_message\",\"Error\",\"captureStackTrace\",\"getStacktrace\",\"enhanceErrorWithContext\",\"goog.debug.enhanceErrorWithContext\",\"opt_context\",\"key\",\"errorcontext\",\"addErrorContext\",\"getStacktraceSimple\",\"goog.debug.getStacktraceSimple\",\"opt_depth\",\"FORCE_SLOPPY_STACKS\",\"getNativeStackTrace_\",\"sb\",\"fn\",\"arguments\",\"callee\",\"caller\",\"depth\",\"getFunctionName\",\"MAX_STACK_DEPTH\",\"goog.debug.getNativeStackTrace_\",\"tempErr\",\"goog.debug.getStacktrace\",\"contextFn\",\"getStacktraceHelper_\",\"goog.debug.getStacktraceHelper_\",\"visited\",\"array\",\"contains\",\"args\",\"argDesc\",\"arg\",\"substr\",\"setFunctionResolver\",\"goog.debug.setFunctionResolver\",\"resolver\",\"fnNameResolver_\",\"goog.debug.getFunctionName\",\"fnNameCache_\",\"functionSource\",\"matches\",\"exec\",\"method\",\"makeWhitespaceVisible\",\"goog.debug.makeWhitespaceVisible\",\"string\",\"runtimeType\",\"goog.debug.runtimeType\",\"value\",\"Function\",\"displayName\",\"Object\",\"constructor\",\"prototype\",\"toString\",\"call\"]\n}\n"]