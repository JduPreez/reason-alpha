["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/async/run.js"],"~:js","goog.provide(\"goog.async.run\");\ngoog.require(\"goog.async.WorkQueue\");\ngoog.require(\"goog.async.nextTick\");\ngoog.require(\"goog.async.throwException\");\n/**\n * @param {function(this:THIS)} callback\n * @param {THIS=} opt_context\n * @template THIS\n */\ngoog.async.run = function(callback, opt_context) {\n  if (!goog.async.run.schedule_) {\n    goog.async.run.initializeRunner_();\n  }\n  if (!goog.async.run.workQueueScheduled_) {\n    goog.async.run.schedule_();\n    goog.async.run.workQueueScheduled_ = true;\n  }\n  goog.async.run.workQueue_.add(callback, opt_context);\n};\n/** @private */ goog.async.run.initializeRunner_ = function() {\n  if (String(goog.global.Promise).indexOf(\"[native code]\") != -1) {\n    var promise = goog.global.Promise.resolve(undefined);\n    goog.async.run.schedule_ = function() {\n      promise.then(goog.async.run.processWorkQueue);\n    };\n  } else {\n    goog.async.run.schedule_ = function() {\n      goog.async.nextTick(goog.async.run.processWorkQueue);\n    };\n  }\n};\n/**\n * @param {function(function())=} opt_realSetTimeout\n */\ngoog.async.run.forceNextTick = function(opt_realSetTimeout) {\n  goog.async.run.schedule_ = function() {\n    goog.async.nextTick(goog.async.run.processWorkQueue);\n    if (opt_realSetTimeout) {\n      opt_realSetTimeout(goog.async.run.processWorkQueue);\n    }\n  };\n};\n/** @private @type {function()} */ goog.async.run.schedule_;\n/** @private @type {boolean} */ goog.async.run.workQueueScheduled_ = false;\n/** @private @type {!goog.async.WorkQueue} */ goog.async.run.workQueue_ = new goog.async.WorkQueue;\nif (goog.DEBUG) {\n  goog.async.run.resetQueue = function() {\n    goog.async.run.workQueueScheduled_ = false;\n    goog.async.run.workQueue_ = new goog.async.WorkQueue;\n  };\n}\ngoog.async.run.processWorkQueue = function() {\n  var item = null;\n  while (item = goog.async.run.workQueue_.remove()) {\n    try {\n      item.fn.call(item.scope);\n    } catch (e) {\n      goog.async.throwException(e);\n    }\n    goog.async.run.workQueue_.returnUnused(item);\n  }\n  goog.async.run.workQueueScheduled_ = false;\n};\n","~:source","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.async.run');\n\ngoog.require('goog.async.WorkQueue');\ngoog.require('goog.async.nextTick');\ngoog.require('goog.async.throwException');\n\n\n/**\n * Fires the provided callback just before the current callstack unwinds, or as\n * soon as possible after the current JS execution context.\n * @param {function(this:THIS)} callback\n * @param {THIS=} opt_context Object to use as the \"this value\" when calling\n *     the provided function.\n * @template THIS\n */\ngoog.async.run = function(callback, opt_context) {\n  if (!goog.async.run.schedule_) {\n    goog.async.run.initializeRunner_();\n  }\n  if (!goog.async.run.workQueueScheduled_) {\n    // Nothing is currently scheduled, schedule it now.\n    goog.async.run.schedule_();\n    goog.async.run.workQueueScheduled_ = true;\n  }\n\n  goog.async.run.workQueue_.add(callback, opt_context);\n};\n\n\n/**\n * Initializes the function to use to process the work queue.\n * @private\n */\ngoog.async.run.initializeRunner_ = function() {\n  // If native Promises are available in the browser, just schedule the callback\n  // on a fulfilled promise, which is specified to be async, but as fast as\n  // possible.  Use goog.global.Promise instead of just Promise because the\n  // relevant externs may be missing, and don't alias it because this could\n  // confuse the compiler into thinking the polyfill is required when it should\n  // be treated as optional.\n  if (String(goog.global.Promise).indexOf('[native code]') != -1) {\n    var promise = goog.global.Promise.resolve(undefined);\n    goog.async.run.schedule_ = function() {\n      promise.then(goog.async.run.processWorkQueue);\n    };\n  } else {\n    goog.async.run.schedule_ = function() {\n      goog.async.nextTick(goog.async.run.processWorkQueue);\n    };\n  }\n};\n\n\n/**\n * Forces goog.async.run to use nextTick instead of Promise.\n *\n * This should only be done in unit tests. It's useful because MockClock\n * replaces nextTick, but not the browser Promise implementation, so it allows\n * Promise-based code to be tested with MockClock.\n *\n * However, we also want to run promises if the MockClock is no longer in\n * control so we schedule a backup \"setTimeout\" to the unmocked timeout if\n * provided.\n *\n * @param {function(function())=} opt_realSetTimeout\n */\ngoog.async.run.forceNextTick = function(opt_realSetTimeout) {\n  goog.async.run.schedule_ = function() {\n    goog.async.nextTick(goog.async.run.processWorkQueue);\n    if (opt_realSetTimeout) {\n      opt_realSetTimeout(goog.async.run.processWorkQueue);\n    }\n  };\n};\n\n\n/**\n * The function used to schedule work asynchronousely.\n * @private {function()}\n */\ngoog.async.run.schedule_;\n\n\n/** @private {boolean} */\ngoog.async.run.workQueueScheduled_ = false;\n\n\n/** @private {!goog.async.WorkQueue} */\ngoog.async.run.workQueue_ = new goog.async.WorkQueue();\n\n\nif (goog.DEBUG) {\n  /**\n   * Reset the work queue. Only available for tests in debug mode.\n   */\n  goog.async.run.resetQueue = function() {\n    goog.async.run.workQueueScheduled_ = false;\n    goog.async.run.workQueue_ = new goog.async.WorkQueue();\n  };\n}\n\n\n/**\n * Run any pending goog.async.run work items. This function is not intended\n * for general use, but for use by entry point handlers to run items ahead of\n * goog.async.nextTick.\n */\ngoog.async.run.processWorkQueue = function() {\n  // NOTE: additional work queue items may be added while processing.\n  var item = null;\n  while (item = goog.async.run.workQueue_.remove()) {\n    try {\n      item.fn.call(item.scope);\n    } catch (e) {\n      goog.async.throwException(e);\n    }\n    goog.async.run.workQueue_.returnUnused(item);\n  }\n\n  // There are no more work items, allow processing to be scheduled again.\n  goog.async.run.workQueueScheduled_ = false;\n};\n","~:compiled-at",1574163696276,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.async.run.js\",\n\"lineCount\":64,\n\"mappings\":\"AAcAA,IAAAC,QAAA,CAAa,gBAAb,CAAA;AAEAD,IAAAE,QAAA,CAAa,sBAAb,CAAA;AACAF,IAAAE,QAAA,CAAa,qBAAb,CAAA;AACAF,IAAAE,QAAA,CAAa,2BAAb,CAAA;AAWA;;;;;AAAAF,IAAAG,MAAAC,IAAA,GAAiBC,QAAQ,CAACC,QAAD,EAAWC,WAAX,CAAwB;AAC/C,MAAI,CAACP,IAAAG,MAAAC,IAAAI,UAAL;AACER,QAAAG,MAAAC,IAAAK,kBAAA,EAAA;AADF;AAGA,MAAI,CAACT,IAAAG,MAAAC,IAAAM,oBAAL,CAAyC;AAEvCV,QAAAG,MAAAC,IAAAI,UAAA,EAAA;AACAR,QAAAG,MAAAC,IAAAM,oBAAA,GAAqC,IAArC;AAHuC;AAMzCV,MAAAG,MAAAC,IAAAO,WAAAC,IAAA,CAA8BN,QAA9B,EAAwCC,WAAxC,CAAA;AAV+C,CAAjD;AAkBA,gBAAAP,IAAAG,MAAAC,IAAAK,kBAAA,GAAmCI,QAAQ,EAAG;AAO5C,MAAIC,MAAA,CAAOd,IAAAe,OAAAC,QAAP,CAAAC,QAAA,CAAoC,eAApC,CAAJ,IAA6D,EAA7D,CAAgE;AAC9D,QAAIC,UAAUlB,IAAAe,OAAAC,QAAAG,QAAA,CAA4BC,SAA5B,CAAd;AACApB,QAAAG,MAAAC,IAAAI,UAAA,GAA2Ba,QAAQ,EAAG;AACpCH,aAAAI,KAAA,CAAatB,IAAAG,MAAAC,IAAAmB,iBAAb,CAAA;AADoC,KAAtC;AAF8D,GAAhE;AAMEvB,QAAAG,MAAAC,IAAAI,UAAA,GAA2Ba,QAAQ,EAAG;AACpCrB,UAAAG,MAAAqB,SAAA,CAAoBxB,IAAAG,MAAAC,IAAAmB,iBAApB,CAAA;AADoC,KAAtC;AANF;AAP4C,CAA9C;AAiCA;;;AAAAvB,IAAAG,MAAAC,IAAAqB,cAAA,GAA+BC,QAAQ,CAACC,kBAAD,CAAqB;AAC1D3B,MAAAG,MAAAC,IAAAI,UAAA,GAA2Ba,QAAQ,EAAG;AACpCrB,QAAAG,MAAAqB,SAAA,CAAoBxB,IAAAG,MAAAC,IAAAmB,iBAApB,CAAA;AACA,QAAII,kBAAJ;AACEA,wBAAA,CAAmB3B,IAAAG,MAAAC,IAAAmB,iBAAnB,CAAA;AADF;AAFoC,GAAtC;AAD0D,CAA5D;AAcA,mCAAAvB,IAAAG,MAAAC,IAAAI,UAAA;AAIA,gCAAAR,IAAAG,MAAAC,IAAAM,oBAAA,GAAqC,KAArC;AAIA,8CAAAV,IAAAG,MAAAC,IAAAO,WAAA,GAA4B,IAAIX,IAAAG,MAAAyB,UAAhC;AAGA,IAAI5B,IAAA6B,MAAJ;AAIE7B,MAAAG,MAAAC,IAAA0B,WAAA,GAA4BC,QAAQ,EAAG;AACrC/B,QAAAG,MAAAC,IAAAM,oBAAA,GAAqC,KAArC;AACAV,QAAAG,MAAAC,IAAAO,WAAA,GAA4B,IAAIX,IAAAG,MAAAyB,UAAhC;AAFqC,GAAvC;AAJF;AAgBA5B,IAAAG,MAAAC,IAAAmB,iBAAA,GAAkCS,QAAQ,EAAG;AAE3C,MAAIC,OAAO,IAAX;AACA,SAAOA,IAAP,GAAcjC,IAAAG,MAAAC,IAAAO,WAAAuB,OAAA,EAAd,CAAkD;AAChD,OAAI;AACFD,UAAAE,GAAAC,KAAA,CAAaH,IAAAI,MAAb,CAAA;AADE,KAEF,QAAOC,CAAP,CAAU;AACVtC,UAAAG,MAAAoC,eAAA,CAA0BD,CAA1B,CAAA;AADU;AAGZtC,QAAAG,MAAAC,IAAAO,WAAA6B,aAAA,CAAuCP,IAAvC,CAAA;AANgD;AAUlDjC,MAAAG,MAAAC,IAAAM,oBAAA,GAAqC,KAArC;AAb2C,CAA7C;;\",\n\"sources\":[\"goog/async/run.js\"],\n\"sourcesContent\":[\"// Copyright 2013 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\ngoog.provide('goog.async.run');\\n\\ngoog.require('goog.async.WorkQueue');\\ngoog.require('goog.async.nextTick');\\ngoog.require('goog.async.throwException');\\n\\n\\n/**\\n * Fires the provided callback just before the current callstack unwinds, or as\\n * soon as possible after the current JS execution context.\\n * @param {function(this:THIS)} callback\\n * @param {THIS=} opt_context Object to use as the \\\"this value\\\" when calling\\n *     the provided function.\\n * @template THIS\\n */\\ngoog.async.run = function(callback, opt_context) {\\n  if (!goog.async.run.schedule_) {\\n    goog.async.run.initializeRunner_();\\n  }\\n  if (!goog.async.run.workQueueScheduled_) {\\n    // Nothing is currently scheduled, schedule it now.\\n    goog.async.run.schedule_();\\n    goog.async.run.workQueueScheduled_ = true;\\n  }\\n\\n  goog.async.run.workQueue_.add(callback, opt_context);\\n};\\n\\n\\n/**\\n * Initializes the function to use to process the work queue.\\n * @private\\n */\\ngoog.async.run.initializeRunner_ = function() {\\n  // If native Promises are available in the browser, just schedule the callback\\n  // on a fulfilled promise, which is specified to be async, but as fast as\\n  // possible.  Use goog.global.Promise instead of just Promise because the\\n  // relevant externs may be missing, and don't alias it because this could\\n  // confuse the compiler into thinking the polyfill is required when it should\\n  // be treated as optional.\\n  if (String(goog.global.Promise).indexOf('[native code]') != -1) {\\n    var promise = goog.global.Promise.resolve(undefined);\\n    goog.async.run.schedule_ = function() {\\n      promise.then(goog.async.run.processWorkQueue);\\n    };\\n  } else {\\n    goog.async.run.schedule_ = function() {\\n      goog.async.nextTick(goog.async.run.processWorkQueue);\\n    };\\n  }\\n};\\n\\n\\n/**\\n * Forces goog.async.run to use nextTick instead of Promise.\\n *\\n * This should only be done in unit tests. It's useful because MockClock\\n * replaces nextTick, but not the browser Promise implementation, so it allows\\n * Promise-based code to be tested with MockClock.\\n *\\n * However, we also want to run promises if the MockClock is no longer in\\n * control so we schedule a backup \\\"setTimeout\\\" to the unmocked timeout if\\n * provided.\\n *\\n * @param {function(function())=} opt_realSetTimeout\\n */\\ngoog.async.run.forceNextTick = function(opt_realSetTimeout) {\\n  goog.async.run.schedule_ = function() {\\n    goog.async.nextTick(goog.async.run.processWorkQueue);\\n    if (opt_realSetTimeout) {\\n      opt_realSetTimeout(goog.async.run.processWorkQueue);\\n    }\\n  };\\n};\\n\\n\\n/**\\n * The function used to schedule work asynchronousely.\\n * @private {function()}\\n */\\ngoog.async.run.schedule_;\\n\\n\\n/** @private {boolean} */\\ngoog.async.run.workQueueScheduled_ = false;\\n\\n\\n/** @private {!goog.async.WorkQueue} */\\ngoog.async.run.workQueue_ = new goog.async.WorkQueue();\\n\\n\\nif (goog.DEBUG) {\\n  /**\\n   * Reset the work queue. Only available for tests in debug mode.\\n   */\\n  goog.async.run.resetQueue = function() {\\n    goog.async.run.workQueueScheduled_ = false;\\n    goog.async.run.workQueue_ = new goog.async.WorkQueue();\\n  };\\n}\\n\\n\\n/**\\n * Run any pending goog.async.run work items. This function is not intended\\n * for general use, but for use by entry point handlers to run items ahead of\\n * goog.async.nextTick.\\n */\\ngoog.async.run.processWorkQueue = function() {\\n  // NOTE: additional work queue items may be added while processing.\\n  var item = null;\\n  while (item = goog.async.run.workQueue_.remove()) {\\n    try {\\n      item.fn.call(item.scope);\\n    } catch (e) {\\n      goog.async.throwException(e);\\n    }\\n    goog.async.run.workQueue_.returnUnused(item);\\n  }\\n\\n  // There are no more work items, allow processing to be scheduled again.\\n  goog.async.run.workQueueScheduled_ = false;\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"async\",\"run\",\"goog.async.run\",\"callback\",\"opt_context\",\"schedule_\",\"initializeRunner_\",\"workQueueScheduled_\",\"workQueue_\",\"add\",\"goog.async.run.initializeRunner_\",\"String\",\"global\",\"Promise\",\"indexOf\",\"promise\",\"resolve\",\"undefined\",\"goog.async.run.schedule_\",\"then\",\"processWorkQueue\",\"nextTick\",\"forceNextTick\",\"goog.async.run.forceNextTick\",\"opt_realSetTimeout\",\"WorkQueue\",\"DEBUG\",\"resetQueue\",\"goog.async.run.resetQueue\",\"goog.async.run.processWorkQueue\",\"item\",\"remove\",\"fn\",\"call\",\"scope\",\"e\",\"throwException\",\"returnUnused\"]\n}\n"]