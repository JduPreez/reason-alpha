["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/i18n/messageformat.js"],"~:js","goog.provide(\"goog.i18n.MessageFormat\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.i18n.CompactNumberFormatSymbols\");\ngoog.require(\"goog.i18n.NumberFormat\");\ngoog.require(\"goog.i18n.NumberFormatSymbols\");\ngoog.require(\"goog.i18n.ordinalRules\");\ngoog.require(\"goog.i18n.pluralRules\");\n/**\n * @final\n * @constructor\n * @param {string} pattern\n */\ngoog.i18n.MessageFormat = function(pattern) {\n  /** @private @type {?string} */ this.pattern_ = pattern;\n  /** @private @type {?Array<string>} */ this.initialLiterals_ = null;\n  /** @private @type {?Array<string>} */ this.literals_ = null;\n  /** @private @type {?Array<!Object>} */ this.parsedPattern_ = null;\n  /** @private @type {!goog.i18n.NumberFormat} */ this.numberFormatter_ = goog.i18n.MessageFormat.getNumberFormatter_();\n};\n/** @private @type {?Object} */ goog.i18n.MessageFormat.numberFormatterSymbols_ = null;\n/** @private @type {?Object} */ goog.i18n.MessageFormat.compactNumberFormatterSymbols_ = null;\n/** @private @type {?goog.i18n.NumberFormat} */ goog.i18n.MessageFormat.numberFormatter_ = null;\n/** @private @type {string} */ goog.i18n.MessageFormat.LITERAL_PLACEHOLDER_ = \"ï·Ÿ_\";\n/** @private @enum {number} */ goog.i18n.MessageFormat.Element_ = {STRING:0, BLOCK:1};\n/** @private @enum {number} */ goog.i18n.MessageFormat.BlockType_ = {PLURAL:0, ORDINAL:1, SELECT:2, SIMPLE:3, STRING:4, UNKNOWN:5};\n/** @private @type {string} */ goog.i18n.MessageFormat.OTHER_ = \"other\";\n/** @private @type {RegExp} */ goog.i18n.MessageFormat.REGEX_LITERAL_ = new RegExp(\"'([{}#].*?)'\", \"g\");\n/** @private @type {RegExp} */ goog.i18n.MessageFormat.REGEX_DOUBLE_APOSTROPHE_ = new RegExp(\"''\", \"g\");\n/** @typedef {{type:goog.i18n.MessageFormat.Element_,value:?}} */ goog.i18n.MessageFormat.TypeVal_;\n/**\n * @private\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.MessageFormat.getNumberFormatter_ = function() {\n  var currentSymbols = goog.i18n.NumberFormatSymbols;\n  var currentCompactSymbols = goog.i18n.CompactNumberFormatSymbols;\n  if (goog.i18n.MessageFormat.numberFormatterSymbols_ !== currentSymbols || goog.i18n.MessageFormat.compactNumberFormatterSymbols_ !== currentCompactSymbols) {\n    goog.i18n.MessageFormat.numberFormatterSymbols_ = currentSymbols;\n    goog.i18n.MessageFormat.compactNumberFormatterSymbols_ = currentCompactSymbols;\n    goog.i18n.MessageFormat.numberFormatter_ = new goog.i18n.NumberFormat(goog.i18n.NumberFormat.Format.DECIMAL);\n  }\n  return (/** @type {!goog.i18n.NumberFormat} */ (goog.i18n.MessageFormat.numberFormatter_));\n};\n/**\n * @param {!Object} namedParameters\n * @return {string}\n */\ngoog.i18n.MessageFormat.prototype.format = function(namedParameters) {\n  return this.format_(namedParameters, false);\n};\n/**\n * @param {!Object} namedParameters\n * @return {string}\n */\ngoog.i18n.MessageFormat.prototype.formatIgnoringPound = function(namedParameters) {\n  return this.format_(namedParameters, true);\n};\n/**\n * @private\n * @param {!Object} namedParameters\n * @param {boolean} ignorePound\n * @return {string}\n */\ngoog.i18n.MessageFormat.prototype.format_ = function(namedParameters, ignorePound) {\n  this.init_();\n  if (!this.parsedPattern_ || this.parsedPattern_.length == 0) {\n    return \"\";\n  }\n  this.literals_ = goog.array.clone(this.initialLiterals_);\n  var result = [];\n  this.formatBlock_(this.parsedPattern_, namedParameters, ignorePound, result);\n  var message = result.join(\"\");\n  if (!ignorePound) {\n    goog.asserts.assert(message.search(\"#\") == -1, \"Not all # were replaced.\");\n  }\n  while (this.literals_.length > 0) {\n    message = message.replace(this.buildPlaceholder_(this.literals_), this.literals_.pop());\n  }\n  return message;\n};\n/**\n * @private\n * @param {!Array<!goog.i18n.MessageFormat.TypeVal_>} parsedPattern\n * @param {!Object} namedParameters\n * @param {boolean} ignorePound\n * @param {!Array<string>} result\n */\ngoog.i18n.MessageFormat.prototype.formatBlock_ = function(parsedPattern, namedParameters, ignorePound, result) {\n  for (var i = 0; i < parsedPattern.length; i++) {\n    switch(parsedPattern[i].type) {\n      case goog.i18n.MessageFormat.BlockType_.STRING:\n        result.push(parsedPattern[i].value);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.SIMPLE:\n        var pattern = parsedPattern[i].value;\n        this.formatSimplePlaceholder_(pattern, namedParameters, result);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.SELECT:\n        var pattern = parsedPattern[i].value;\n        this.formatSelectBlock_(pattern, namedParameters, ignorePound, result);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.PLURAL:\n        var pattern = parsedPattern[i].value;\n        this.formatPluralOrdinalBlock_(pattern, namedParameters, goog.i18n.pluralRules.select, ignorePound, result);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.ORDINAL:\n        var pattern = parsedPattern[i].value;\n        this.formatPluralOrdinalBlock_(pattern, namedParameters, goog.i18n.ordinalRules.select, ignorePound, result);\n        break;\n      default:\n        goog.asserts.fail(\"Unrecognized block type: \" + parsedPattern[i].type);\n    }\n  }\n};\n/**\n * @private\n * @param {!Object} parsedPattern\n * @param {!Object} namedParameters\n * @param {!Array<string>} result\n */\ngoog.i18n.MessageFormat.prototype.formatSimplePlaceholder_ = function(parsedPattern, namedParameters, result) {\n  var value = namedParameters[parsedPattern];\n  if (!goog.isDef(value)) {\n    result.push(\"Undefined parameter - \" + parsedPattern);\n    return;\n  }\n  this.literals_.push(value);\n  result.push(this.buildPlaceholder_(this.literals_));\n};\n/**\n * @private\n * @param {!{argumentIndex:?}} parsedPattern\n * @param {!Object} namedParameters\n * @param {boolean} ignorePound\n * @param {!Array<string>} result\n */\ngoog.i18n.MessageFormat.prototype.formatSelectBlock_ = function(parsedPattern, namedParameters, ignorePound, result) {\n  var argumentIndex = parsedPattern.argumentIndex;\n  if (!goog.isDef(namedParameters[argumentIndex])) {\n    result.push(\"Undefined parameter - \" + argumentIndex);\n    return;\n  }\n  var option = parsedPattern[namedParameters[argumentIndex]];\n  if (!goog.isDef(option)) {\n    option = parsedPattern[goog.i18n.MessageFormat.OTHER_];\n    goog.asserts.assertArray(option, \"Invalid option or missing other option for select block.\");\n  }\n  this.formatBlock_(option, namedParameters, ignorePound, result);\n};\n/**\n * @private\n * @param {!{argumentIndex,argumentOffset}} parsedPattern\n * @param {!Object} namedParameters\n * @param {function(number,number=):string} pluralSelector\n * @param {boolean} ignorePound\n * @param {!Array<string>} result\n */\ngoog.i18n.MessageFormat.prototype.formatPluralOrdinalBlock_ = function(parsedPattern, namedParameters, pluralSelector, ignorePound, result) {\n  var argumentIndex = parsedPattern.argumentIndex;\n  var argumentOffset = parsedPattern.argumentOffset;\n  var pluralValue = +namedParameters[argumentIndex];\n  if (isNaN(pluralValue)) {\n    result.push(\"Undefined or invalid parameter - \" + argumentIndex);\n    return;\n  }\n  var diff = pluralValue - argumentOffset;\n  var option = parsedPattern[namedParameters[argumentIndex]];\n  if (!goog.isDef(option)) {\n    goog.asserts.assert(diff >= 0, \"Argument index smaller than offset.\");\n    var item;\n    if (this.numberFormatter_.getMinimumFractionDigits) {\n      item = pluralSelector(diff, this.numberFormatter_.getMinimumFractionDigits());\n    } else {\n      item = pluralSelector(diff);\n    }\n    goog.asserts.assertString(item, \"Invalid plural key.\");\n    option = parsedPattern[item];\n    if (!goog.isDef(option)) {\n      option = parsedPattern[goog.i18n.MessageFormat.OTHER_];\n    }\n    goog.asserts.assertArray(option, \"Invalid option or missing other option for plural block.\");\n  }\n  var pluralResult = [];\n  this.formatBlock_(option, namedParameters, ignorePound, pluralResult);\n  var plural = pluralResult.join(\"\");\n  goog.asserts.assertString(plural, \"Empty block in plural.\");\n  if (ignorePound) {\n    result.push(plural);\n  } else {\n    var localeAwareDiff = this.numberFormatter_.format(diff);\n    result.push(plural.replace(/#/g, localeAwareDiff));\n  }\n};\n/** @private */ goog.i18n.MessageFormat.prototype.init_ = function() {\n  if (this.pattern_) {\n    this.initialLiterals_ = [];\n    var pattern = this.insertPlaceholders_(this.pattern_);\n    this.parsedPattern_ = this.parseBlock_(pattern);\n    this.pattern_ = null;\n  }\n};\n/**\n * @private\n * @param {string} pattern\n * @return {string}\n */\ngoog.i18n.MessageFormat.prototype.insertPlaceholders_ = function(pattern) {\n  var literals = this.initialLiterals_;\n  var buildPlaceholder = goog.bind(this.buildPlaceholder_, this);\n  pattern = pattern.replace(goog.i18n.MessageFormat.REGEX_DOUBLE_APOSTROPHE_, function() {\n    literals.push(\"'\");\n    return buildPlaceholder(literals);\n  });\n  pattern = pattern.replace(goog.i18n.MessageFormat.REGEX_LITERAL_, function(match, text) {\n    literals.push(text);\n    return buildPlaceholder(literals);\n  });\n  return pattern;\n};\n/**\n * @private\n * @param {string} pattern\n * @return {!Array<goog.i18n.MessageFormat.TypeVal_>}\n */\ngoog.i18n.MessageFormat.prototype.extractParts_ = function(pattern) {\n  var prevPos = 0;\n  var braceStack = [];\n  var results = [];\n  var braces = /[{}]/g;\n  braces.lastIndex = 0;\n  var match;\n  while (match = braces.exec(pattern)) {\n    var pos = match.index;\n    if (match[0] == \"}\") {\n      var brace = braceStack.pop();\n      goog.asserts.assert(goog.isDef(brace) && brace == \"{\", \"No matching { for }.\");\n      if (braceStack.length == 0) {\n        var part = {};\n        part.type = goog.i18n.MessageFormat.Element_.BLOCK;\n        part.value = pattern.substring(prevPos, pos);\n        results.push(part);\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        var substring = pattern.substring(prevPos, pos);\n        if (substring != \"\") {\n          results.push({type:goog.i18n.MessageFormat.Element_.STRING, value:substring});\n        }\n        prevPos = pos + 1;\n      }\n      braceStack.push(\"{\");\n    }\n  }\n  goog.asserts.assert(braceStack.length == 0, \"There are mismatched { or } in the pattern.\");\n  var substring = pattern.substring(prevPos);\n  if (substring != \"\") {\n    results.push({type:goog.i18n.MessageFormat.Element_.STRING, value:substring});\n  }\n  return results;\n};\n/** @private @type {RegExp} */ goog.i18n.MessageFormat.PLURAL_BLOCK_RE_ = /^\\s*(\\w+)\\s*,\\s*plural\\s*,(?:\\s*offset:(\\d+))?/;\n/** @private @type {RegExp} */ goog.i18n.MessageFormat.ORDINAL_BLOCK_RE_ = /^\\s*(\\w+)\\s*,\\s*selectordinal\\s*,/;\n/** @private @type {RegExp} */ goog.i18n.MessageFormat.SELECT_BLOCK_RE_ = /^\\s*(\\w+)\\s*,\\s*select\\s*,/;\n/**\n * @private\n * @param {string} pattern\n * @return {goog.i18n.MessageFormat.BlockType_}\n */\ngoog.i18n.MessageFormat.prototype.parseBlockType_ = function(pattern) {\n  if (goog.i18n.MessageFormat.PLURAL_BLOCK_RE_.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.PLURAL;\n  }\n  if (goog.i18n.MessageFormat.ORDINAL_BLOCK_RE_.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.ORDINAL;\n  }\n  if (goog.i18n.MessageFormat.SELECT_BLOCK_RE_.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.SELECT;\n  }\n  if (/^\\s*\\w+\\s*/.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.SIMPLE;\n  }\n  return goog.i18n.MessageFormat.BlockType_.UNKNOWN;\n};\n/**\n * @private\n * @param {string} pattern\n * @return {!Array<!Object>}\n */\ngoog.i18n.MessageFormat.prototype.parseBlock_ = function(pattern) {\n  var result = [];\n  var parts = this.extractParts_(pattern);\n  for (var i = 0; i < parts.length; i++) {\n    var block = {};\n    if (goog.i18n.MessageFormat.Element_.STRING == parts[i].type) {\n      block.type = goog.i18n.MessageFormat.BlockType_.STRING;\n      block.value = parts[i].value;\n    } else {\n      if (goog.i18n.MessageFormat.Element_.BLOCK == parts[i].type) {\n        var blockType = this.parseBlockType_(parts[i].value);\n        switch(blockType) {\n          case goog.i18n.MessageFormat.BlockType_.SELECT:\n            block.type = goog.i18n.MessageFormat.BlockType_.SELECT;\n            block.value = this.parseSelectBlock_(parts[i].value);\n            break;\n          case goog.i18n.MessageFormat.BlockType_.PLURAL:\n            block.type = goog.i18n.MessageFormat.BlockType_.PLURAL;\n            block.value = this.parsePluralBlock_(parts[i].value);\n            break;\n          case goog.i18n.MessageFormat.BlockType_.ORDINAL:\n            block.type = goog.i18n.MessageFormat.BlockType_.ORDINAL;\n            block.value = this.parseOrdinalBlock_(parts[i].value);\n            break;\n          case goog.i18n.MessageFormat.BlockType_.SIMPLE:\n            block.type = goog.i18n.MessageFormat.BlockType_.SIMPLE;\n            block.value = parts[i].value;\n            break;\n          default:\n            goog.asserts.fail(\"Unknown block type for pattern: \" + parts[i].value);\n        }\n      } else {\n        goog.asserts.fail(\"Unknown part of the pattern.\");\n      }\n    }\n    result.push(block);\n  }\n  return result;\n};\n/**\n * @private\n * @param {string} pattern\n * @return {!Object}\n */\ngoog.i18n.MessageFormat.prototype.parseSelectBlock_ = function(pattern) {\n  var argumentIndex = \"\";\n  var replaceRegex = goog.i18n.MessageFormat.SELECT_BLOCK_RE_;\n  pattern = pattern.replace(replaceRegex, function(string, name) {\n    argumentIndex = name;\n    return \"\";\n  });\n  var result = {};\n  result.argumentIndex = argumentIndex;\n  var parts = this.extractParts_(pattern);\n  var pos = 0;\n  while (pos < parts.length) {\n    var key = parts[pos].value;\n    goog.asserts.assertString(key, \"Missing select key element.\");\n    pos++;\n    goog.asserts.assert(pos < parts.length, \"Missing or invalid select value element.\");\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\n      var value = this.parseBlock_(parts[pos].value);\n    } else {\n      goog.asserts.fail(\"Expected block type.\");\n    }\n    result[key.replace(/\\s/g, \"\")] = value;\n    pos++;\n  }\n  goog.asserts.assertArray(result[goog.i18n.MessageFormat.OTHER_], \"Missing other key in select statement.\");\n  return result;\n};\n/**\n * @private\n * @param {string} pattern\n * @return {!Object}\n */\ngoog.i18n.MessageFormat.prototype.parsePluralBlock_ = function(pattern) {\n  var argumentIndex = \"\";\n  var argumentOffset = 0;\n  var replaceRegex = goog.i18n.MessageFormat.PLURAL_BLOCK_RE_;\n  pattern = pattern.replace(replaceRegex, function(string, name, offset) {\n    argumentIndex = name;\n    if (offset) {\n      argumentOffset = parseInt(offset, 10);\n    }\n    return \"\";\n  });\n  var result = {};\n  result.argumentIndex = argumentIndex;\n  result.argumentOffset = argumentOffset;\n  var parts = this.extractParts_(pattern);\n  var pos = 0;\n  while (pos < parts.length) {\n    var key = parts[pos].value;\n    goog.asserts.assertString(key, \"Missing plural key element.\");\n    pos++;\n    goog.asserts.assert(pos < parts.length, \"Missing or invalid plural value element.\");\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\n      var value = this.parseBlock_(parts[pos].value);\n    } else {\n      goog.asserts.fail(\"Expected block type.\");\n    }\n    result[key.replace(/\\s*(?:=)?(\\w+)\\s*/, \"$1\")] = value;\n    pos++;\n  }\n  goog.asserts.assertArray(result[goog.i18n.MessageFormat.OTHER_], \"Missing other key in plural statement.\");\n  return result;\n};\n/**\n * @private\n * @param {string} pattern\n * @return {!Object}\n */\ngoog.i18n.MessageFormat.prototype.parseOrdinalBlock_ = function(pattern) {\n  var argumentIndex = \"\";\n  var replaceRegex = goog.i18n.MessageFormat.ORDINAL_BLOCK_RE_;\n  pattern = pattern.replace(replaceRegex, function(string, name) {\n    argumentIndex = name;\n    return \"\";\n  });\n  var result = {};\n  result.argumentIndex = argumentIndex;\n  result.argumentOffset = 0;\n  var parts = this.extractParts_(pattern);\n  var pos = 0;\n  while (pos < parts.length) {\n    var key = parts[pos].value;\n    goog.asserts.assertString(key, \"Missing ordinal key element.\");\n    pos++;\n    goog.asserts.assert(pos < parts.length, \"Missing or invalid ordinal value element.\");\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\n      var value = this.parseBlock_(parts[pos].value);\n    } else {\n      goog.asserts.fail(\"Expected block type.\");\n    }\n    result[key.replace(/\\s*(?:=)?(\\w+)\\s*/, \"$1\")] = value;\n    pos++;\n  }\n  goog.asserts.assertArray(result[goog.i18n.MessageFormat.OTHER_], \"Missing other key in selectordinal statement.\");\n  return result;\n};\n/**\n * @private\n * @param {!Array<string>} literals\n * @return {string}\n */\ngoog.i18n.MessageFormat.prototype.buildPlaceholder_ = function(literals) {\n  goog.asserts.assert(literals.length > 0, \"Literal array is empty.\");\n  var index = (literals.length - 1).toString(10);\n  return goog.i18n.MessageFormat.LITERAL_PLACEHOLDER_ + index + \"_\";\n};\n","~:source","// Copyright 2010 The Closure Library Authors. All Rights Reserved\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Message/plural format library with locale support.\n *\n * Message format grammar:\n *\n * messageFormatPattern := string ( \"{\" messageFormatElement \"}\" string )*\n * messageFormatElement := argumentIndex [ \",\" elementFormat ]\n * elementFormat := \"plural\" \",\" pluralStyle\n *                  | \"selectordinal\" \",\" ordinalStyle\n *                  | \"select\" \",\" selectStyle\n * pluralStyle :=  pluralFormatPattern\n * ordinalStyle :=  selectFormatPattern\n * selectStyle :=  selectFormatPattern\n * pluralFormatPattern := [ \"offset\" \":\" offsetIndex ] pluralForms*\n * selectFormatPattern := pluralForms*\n * pluralForms := stringKey \"{\" ( \"{\" messageFormatElement \"}\"|string )* \"}\"\n *\n * This is a subset of the ICU MessageFormatSyntax:\n *   http://userguide.icu-project.org/formatparse/messages\n * See also http://go/plurals and http://go/ordinals for internal details.\n *\n *\n * Message example:\n *\n * I see {NUM_PEOPLE, plural, offset:1\n *         =0 {no one at all}\n *         =1 {{WHO}}\n *         one {{WHO} and one other person}\n *         other {{WHO} and # other people}}\n * in {PLACE}.\n *\n * Calling format({'NUM_PEOPLE': 2, 'WHO': 'Mark', 'PLACE': 'Athens'}) would\n * produce \"I see Mark and one other person in Athens.\" as output.\n *\n * OR:\n *\n * {NUM_FLOOR, selectordinal,\n *   one {Take the elevator to the #st floor.}\n *   two {Take the elevator to the #nd floor.}\n *   few {Take the elevator to the #rd floor.}\n *   other {Take the elevator to the #th floor.}}\n *\n * Calling format({'NUM_FLOOR': 22}) would produce\n * \"Take the elevator to the 22nd floor\".\n *\n * See messageformat_test.html for more examples.\n */\n\ngoog.provide('goog.i18n.MessageFormat');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.i18n.CompactNumberFormatSymbols');\ngoog.require('goog.i18n.NumberFormat');\ngoog.require('goog.i18n.NumberFormatSymbols');\ngoog.require('goog.i18n.ordinalRules');\ngoog.require('goog.i18n.pluralRules');\n\n\n\n/**\n * Constructor of MessageFormat.\n * @param {string} pattern The pattern we parse and apply positional parameters\n *     to.\n * @constructor\n * @final\n */\ngoog.i18n.MessageFormat = function(pattern) {\n  /**\n   * The pattern we parse and apply positional parameters to.\n   * @type {?string}\n   * @private\n   */\n  this.pattern_ = pattern;\n\n  /**\n   * All encountered literals during parse stage. Indices tell us the order of\n   * replacement.\n   * @type {?Array<string>}\n   * @private\n   */\n  this.initialLiterals_ = null;\n\n  /**\n   * Working array with all encountered literals during parse and format stages.\n   * Indices tell us the order of replacement.\n   * @type {?Array<string>}\n   * @private\n   */\n  this.literals_ = null;\n\n  /**\n   * Input pattern gets parsed into objects for faster formatting.\n   * @type {?Array<!Object>}\n   * @private\n   */\n  this.parsedPattern_ = null;\n\n  /**\n   * Locale aware number formatter.\n   * @type {!goog.i18n.NumberFormat}\n   * @private\n   */\n  this.numberFormatter_ = goog.i18n.MessageFormat.getNumberFormatter_();\n};\n\n\n/**\n * Locale associated with the most recently created NumberFormat.\n * @type {?Object}\n * @private\n */\ngoog.i18n.MessageFormat.numberFormatterSymbols_ = null;\n\n\n/**\n * Locale associated with the most recently created NumberFormat.\n * @type {?Object}\n * @private\n */\ngoog.i18n.MessageFormat.compactNumberFormatterSymbols_ = null;\n\n\n/**\n * Locale aware number formatter. Reference to the most recently created\n * NumberFormat for sharing between MessageFormat instances.\n * @type {?goog.i18n.NumberFormat}\n * @private\n */\ngoog.i18n.MessageFormat.numberFormatter_ = null;\n\n\n/**\n * Literal strings, including '', are replaced with \\uFDDF_x_ for\n * parsing purposes, and recovered during format phase.\n * \\uFDDF is a Unicode nonprinting character, not expected to be found in the\n * typical message.\n * @type {string}\n * @private\n */\ngoog.i18n.MessageFormat.LITERAL_PLACEHOLDER_ = '\\uFDDF_';\n\n\n/**\n * Marks a string and block during parsing.\n * @enum {number}\n * @private\n */\ngoog.i18n.MessageFormat.Element_ = {\n  STRING: 0,\n  BLOCK: 1\n};\n\n\n/**\n * Block type.\n * @enum {number}\n * @private\n */\ngoog.i18n.MessageFormat.BlockType_ = {\n  PLURAL: 0,\n  ORDINAL: 1,\n  SELECT: 2,\n  SIMPLE: 3,\n  STRING: 4,\n  UNKNOWN: 5\n};\n\n\n/**\n * Mandatory option in both select and plural form.\n * @type {string}\n * @private\n */\ngoog.i18n.MessageFormat.OTHER_ = 'other';\n\n\n/**\n * Regular expression for looking for string literals.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.MessageFormat.REGEX_LITERAL_ = new RegExp(\"'([{}#].*?)'\", 'g');\n\n\n/**\n * Regular expression for looking for '' in the message.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.MessageFormat.REGEX_DOUBLE_APOSTROPHE_ = new RegExp(\"''\", 'g');\n\n/** @typedef {{ type: goog.i18n.MessageFormat.Element_, value: ? }} */\ngoog.i18n.MessageFormat.TypeVal_;\n\n\n/**\n * Gets the a NumberFormat instance for the current locale.\n * If the locale is the same as the previous invocation, returns the same\n * NumberFormat instance. Otherwise, creates a new one.\n * @return {!goog.i18n.NumberFormat}\n * @private\n */\ngoog.i18n.MessageFormat.getNumberFormatter_ = function() {\n  var currentSymbols = goog.i18n.NumberFormatSymbols;\n  var currentCompactSymbols = goog.i18n.CompactNumberFormatSymbols;\n\n  if (goog.i18n.MessageFormat.numberFormatterSymbols_ !== currentSymbols ||\n      goog.i18n.MessageFormat.compactNumberFormatterSymbols_ !==\n          currentCompactSymbols) {\n    goog.i18n.MessageFormat.numberFormatterSymbols_ = currentSymbols;\n    goog.i18n.MessageFormat.compactNumberFormatterSymbols_ =\n        currentCompactSymbols;\n    goog.i18n.MessageFormat.numberFormatter_ =\n        new goog.i18n.NumberFormat(goog.i18n.NumberFormat.Format.DECIMAL);\n  }\n\n  return /** @type {!goog.i18n.NumberFormat} */ (\n      goog.i18n.MessageFormat.numberFormatter_);\n};\n\n\n/**\n * Formats a message, treating '#' with special meaning representing\n * the number (plural_variable - offset).\n * @param {!Object} namedParameters Parameters that either\n *     influence the formatting or are used as actual data.\n *     I.e. in call to fmt.format({'NUM_PEOPLE': 5, 'NAME': 'Angela'}),\n *     object {'NUM_PEOPLE': 5, 'NAME': 'Angela'} holds positional parameters.\n *     1st parameter could mean 5 people, which could influence plural format,\n *     and 2nd parameter is just a data to be printed out in proper position.\n * @return {string} Formatted message.\n */\ngoog.i18n.MessageFormat.prototype.format = function(namedParameters) {\n  return this.format_(namedParameters, false);\n};\n\n\n/**\n * Formats a message, treating '#' as literary character.\n * @param {!Object} namedParameters Parameters that either\n *     influence the formatting or are used as actual data.\n *     I.e. in call to fmt.format({'NUM_PEOPLE': 5, 'NAME': 'Angela'}),\n *     object {'NUM_PEOPLE': 5, 'NAME': 'Angela'} holds positional parameters.\n *     1st parameter could mean 5 people, which could influence plural format,\n *     and 2nd parameter is just a data to be printed out in proper position.\n * @return {string} Formatted message.\n */\ngoog.i18n.MessageFormat.prototype.formatIgnoringPound = function(\n    namedParameters) {\n  return this.format_(namedParameters, true);\n};\n\n\n/**\n * Formats a message.\n * @param {!Object} namedParameters Parameters that either\n *     influence the formatting or are used as actual data.\n *     I.e. in call to fmt.format({'NUM_PEOPLE': 5, 'NAME': 'Angela'}),\n *     object {'NUM_PEOPLE': 5, 'NAME': 'Angela'} holds positional parameters.\n *     1st parameter could mean 5 people, which could influence plural format,\n *     and 2nd parameter is just a data to be printed out in proper position.\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\n *     literary character, else treat it as an ICU syntax character, resolving\n *     to the number (plural_variable - offset).\n * @return {string} Formatted message.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.format_ = function(\n    namedParameters, ignorePound) {\n  this.init_();\n  if (!this.parsedPattern_ || this.parsedPattern_.length == 0) {\n    return '';\n  }\n  this.literals_ = goog.array.clone(this.initialLiterals_);\n\n  var result = [];\n  this.formatBlock_(this.parsedPattern_, namedParameters, ignorePound, result);\n  var message = result.join('');\n\n  if (!ignorePound) {\n    goog.asserts.assert(message.search('#') == -1, 'Not all # were replaced.');\n  }\n\n  while (this.literals_.length > 0) {\n    message = message.replace(\n        this.buildPlaceholder_(this.literals_), this.literals_.pop());\n  }\n\n  return message;\n};\n\n\n/**\n * Parses generic block and returns a formatted string.\n * @param {!Array<!goog.i18n.MessageFormat.TypeVal_>} parsedPattern\n *     Holds parsed tree.\n * @param {!Object} namedParameters Parameters that either influence\n *     the formatting or are used as actual data.\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\n *     literary character, else treat it as an ICU syntax character, resolving\n *     to the number (plural_variable - offset).\n * @param {!Array<string>} result Each formatting stage appends its product\n *     to the result.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.formatBlock_ = function(\n    parsedPattern, namedParameters, ignorePound, result) {\n  for (var i = 0; i < parsedPattern.length; i++) {\n    switch (parsedPattern[i].type) {\n      case goog.i18n.MessageFormat.BlockType_.STRING:\n        result.push(parsedPattern[i].value);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.SIMPLE:\n        var pattern = parsedPattern[i].value;\n        this.formatSimplePlaceholder_(pattern, namedParameters, result);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.SELECT:\n        var pattern = parsedPattern[i].value;\n        this.formatSelectBlock_(pattern, namedParameters, ignorePound, result);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.PLURAL:\n        var pattern = parsedPattern[i].value;\n        this.formatPluralOrdinalBlock_(\n            pattern, namedParameters, goog.i18n.pluralRules.select, ignorePound,\n            result);\n        break;\n      case goog.i18n.MessageFormat.BlockType_.ORDINAL:\n        var pattern = parsedPattern[i].value;\n        this.formatPluralOrdinalBlock_(\n            pattern, namedParameters, goog.i18n.ordinalRules.select,\n            ignorePound, result);\n        break;\n      default:\n        goog.asserts.fail('Unrecognized block type: ' + parsedPattern[i].type);\n    }\n  }\n};\n\n\n/**\n * Formats simple placeholder.\n * @param {!Object} parsedPattern JSON object containing placeholder info.\n * @param {!Object} namedParameters Parameters that are used as actual data.\n * @param {!Array<string>} result Each formatting stage appends its product\n *     to the result.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.formatSimplePlaceholder_ = function(\n    parsedPattern, namedParameters, result) {\n  var value = namedParameters[parsedPattern];\n  if (!goog.isDef(value)) {\n    result.push('Undefined parameter - ' + parsedPattern);\n    return;\n  }\n\n  // Don't push the value yet, it may contain any of # { } in it which\n  // will break formatter. Insert a placeholder and replace at the end.\n  this.literals_.push(value);\n  result.push(this.buildPlaceholder_(this.literals_));\n};\n\n\n/**\n * Formats select block. Only one option is selected.\n * @param {!{argumentIndex:?}} parsedPattern JSON object containing select\n *     block info.\n * @param {!Object} namedParameters Parameters that either influence\n *     the formatting or are used as actual data.\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\n *     literary character, else treat it as an ICU syntax character, resolving\n *     to the number (plural_variable - offset).\n * @param {!Array<string>} result Each formatting stage appends its product\n *     to the result.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.formatSelectBlock_ = function(\n    parsedPattern, namedParameters, ignorePound, result) {\n  var argumentIndex = parsedPattern.argumentIndex;\n  if (!goog.isDef(namedParameters[argumentIndex])) {\n    result.push('Undefined parameter - ' + argumentIndex);\n    return;\n  }\n\n  var option = parsedPattern[namedParameters[argumentIndex]];\n  if (!goog.isDef(option)) {\n    option = parsedPattern[goog.i18n.MessageFormat.OTHER_];\n    goog.asserts.assertArray(\n        option, 'Invalid option or missing other option for select block.');\n  }\n\n  this.formatBlock_(option, namedParameters, ignorePound, result);\n};\n\n\n/**\n * Formats plural or selectordinal block. Only one option is selected and all #\n * are replaced.\n * @param {!{argumentIndex, argumentOffset}} parsedPattern JSON object\n *     containing plural block info.\n * @param {!Object} namedParameters Parameters that either influence\n *     the formatting or are used as actual data.\n * @param {function(number, number=):string} pluralSelector  A select function\n *     from goog.i18n.pluralRules or goog.i18n.ordinalRules which determines\n *     which plural/ordinal form to use based on the input number's cardinality.\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\n *     literary character, else treat it as an ICU syntax character, resolving\n *     to the number (plural_variable - offset).\n * @param {!Array<string>} result Each formatting stage appends its product\n *     to the result.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.formatPluralOrdinalBlock_ = function(\n    parsedPattern, namedParameters, pluralSelector, ignorePound, result) {\n  var argumentIndex = parsedPattern.argumentIndex;\n  var argumentOffset = parsedPattern.argumentOffset;\n  var pluralValue = +namedParameters[argumentIndex];\n  if (isNaN(pluralValue)) {\n    // TODO(user): Distinguish between undefined and invalid parameters.\n    result.push('Undefined or invalid parameter - ' + argumentIndex);\n    return;\n  }\n  var diff = pluralValue - argumentOffset;\n\n  // Check if there is an exact match.\n  var option = parsedPattern[namedParameters[argumentIndex]];\n  if (!goog.isDef(option)) {\n    goog.asserts.assert(diff >= 0, 'Argument index smaller than offset.');\n    var item;\n    if (this.numberFormatter_.getMinimumFractionDigits) {  // number formatter?\n      // If we know the number of fractional digits we can make better decisions\n      // We can decide (for instance) between \"1 dollar\" and \"1.00 dollars\".\n      item = pluralSelector(\n          diff, this.numberFormatter_.getMinimumFractionDigits());\n    } else {\n      item = pluralSelector(diff);\n    }\n    goog.asserts.assertString(item, 'Invalid plural key.');\n\n    option = parsedPattern[item];\n\n    // If option is not provided fall back to \"other\".\n    if (!goog.isDef(option)) {\n      option = parsedPattern[goog.i18n.MessageFormat.OTHER_];\n    }\n\n    goog.asserts.assertArray(\n        option, 'Invalid option or missing other option for plural block.');\n  }\n\n  var pluralResult = [];\n  this.formatBlock_(option, namedParameters, ignorePound, pluralResult);\n  var plural = pluralResult.join('');\n  goog.asserts.assertString(plural, 'Empty block in plural.');\n  if (ignorePound) {\n    result.push(plural);\n  } else {\n    var localeAwareDiff = this.numberFormatter_.format(diff);\n    result.push(plural.replace(/#/g, localeAwareDiff));\n  }\n};\n\n\n/**\n * Set up the MessageFormat.\n * Parses input pattern into an array, for faster reformatting with\n * different input parameters.\n * Parsing is locale independent.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.init_ = function() {\n  if (this.pattern_) {\n    this.initialLiterals_ = [];\n    var pattern = this.insertPlaceholders_(this.pattern_);\n\n    this.parsedPattern_ = this.parseBlock_(pattern);\n    this.pattern_ = null;\n  }\n};\n\n\n/**\n * Replaces string literals with literal placeholders.\n * Literals are string of the form '}...', '{...' and '#...' where ... is\n * set of characters not containing '\n * Builds a dictionary so we can recover literals during format phase.\n * @param {string} pattern Pattern to clean up.\n * @return {string} Pattern with literals replaced with placeholders.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.insertPlaceholders_ = function(pattern) {\n  var literals = this.initialLiterals_;\n  var buildPlaceholder = goog.bind(this.buildPlaceholder_, this);\n\n  // First replace '' with single quote placeholder since they can be found\n  // inside other literals.\n  pattern = pattern.replace(\n      goog.i18n.MessageFormat.REGEX_DOUBLE_APOSTROPHE_, function() {\n        literals.push(\"'\");\n        return buildPlaceholder(literals);\n      });\n\n  pattern = pattern.replace(\n      goog.i18n.MessageFormat.REGEX_LITERAL_, function(match, text) {\n        literals.push(text);\n        return buildPlaceholder(literals);\n      });\n\n  return pattern;\n};\n\n\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * @param {string} pattern (sub)Pattern to be broken.\n * @return {!Array<goog.i18n.MessageFormat.TypeVal_>}\n * @private\n */\ngoog.i18n.MessageFormat.prototype.extractParts_ = function(pattern) {\n  var prevPos = 0;\n  var braceStack = [];\n  var results = [];\n\n  var braces = /[{}]/g;\n  braces.lastIndex = 0;  // lastIndex doesn't get set to 0 so we have to.\n  var match;\n\n  while (match = braces.exec(pattern)) {\n    var pos = match.index;\n    if (match[0] == '}') {\n      var brace = braceStack.pop();\n      goog.asserts.assert(\n          goog.isDef(brace) && brace == '{', 'No matching { for }.');\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        var part = {};\n        part.type = goog.i18n.MessageFormat.Element_.BLOCK;\n        part.value = pattern.substring(prevPos, pos);\n        results.push(part);\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        var substring = pattern.substring(prevPos, pos);\n        if (substring != '') {\n          results.push({\n            type: goog.i18n.MessageFormat.Element_.STRING,\n            value: substring\n          });\n        }\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n\n  // Take care of the final string, and check if the braceStack is empty.\n  goog.asserts.assert(\n      braceStack.length == 0, 'There are mismatched { or } in the pattern.');\n\n  var substring = pattern.substring(prevPos);\n  if (substring != '') {\n    results.push(\n        {type: goog.i18n.MessageFormat.Element_.STRING, value: substring});\n  }\n\n  return results;\n};\n\n\n/**\n * A regular expression to parse the plural block, extracting the argument\n * index and offset (if any).\n * @type {RegExp}\n * @private\n */\ngoog.i18n.MessageFormat.PLURAL_BLOCK_RE_ =\n    /^\\s*(\\w+)\\s*,\\s*plural\\s*,(?:\\s*offset:(\\d+))?/;\n\n\n/**\n * A regular expression to parse the ordinal block, extracting the argument\n * index.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.MessageFormat.ORDINAL_BLOCK_RE_ = /^\\s*(\\w+)\\s*,\\s*selectordinal\\s*,/;\n\n\n/**\n * A regular expression to parse the select block, extracting the argument\n * index.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.MessageFormat.SELECT_BLOCK_RE_ = /^\\s*(\\w+)\\s*,\\s*select\\s*,/;\n\n\n/**\n * Detects which type of a block is the pattern.\n * @param {string} pattern Content of the block.\n * @return {goog.i18n.MessageFormat.BlockType_} One of the block types.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.parseBlockType_ = function(pattern) {\n  if (goog.i18n.MessageFormat.PLURAL_BLOCK_RE_.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.PLURAL;\n  }\n\n  if (goog.i18n.MessageFormat.ORDINAL_BLOCK_RE_.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.ORDINAL;\n  }\n\n  if (goog.i18n.MessageFormat.SELECT_BLOCK_RE_.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.SELECT;\n  }\n\n  if (/^\\s*\\w+\\s*/.test(pattern)) {\n    return goog.i18n.MessageFormat.BlockType_.SIMPLE;\n  }\n\n  return goog.i18n.MessageFormat.BlockType_.UNKNOWN;\n};\n\n\n/**\n * Parses generic block.\n * @param {string} pattern Content of the block to parse.\n * @return {!Array<!Object>} Subblocks marked as strings, select...\n * @private\n */\ngoog.i18n.MessageFormat.prototype.parseBlock_ = function(pattern) {\n  var result = [];\n  var parts = this.extractParts_(pattern);\n  for (var i = 0; i < parts.length; i++) {\n    var block = {};\n    if (goog.i18n.MessageFormat.Element_.STRING == parts[i].type) {\n      block.type = goog.i18n.MessageFormat.BlockType_.STRING;\n      block.value = parts[i].value;\n    } else if (goog.i18n.MessageFormat.Element_.BLOCK == parts[i].type) {\n      var blockType = this.parseBlockType_(parts[i].value);\n\n      switch (blockType) {\n        case goog.i18n.MessageFormat.BlockType_.SELECT:\n          block.type = goog.i18n.MessageFormat.BlockType_.SELECT;\n          block.value = this.parseSelectBlock_(parts[i].value);\n          break;\n        case goog.i18n.MessageFormat.BlockType_.PLURAL:\n          block.type = goog.i18n.MessageFormat.BlockType_.PLURAL;\n          block.value = this.parsePluralBlock_(parts[i].value);\n          break;\n        case goog.i18n.MessageFormat.BlockType_.ORDINAL:\n          block.type = goog.i18n.MessageFormat.BlockType_.ORDINAL;\n          block.value = this.parseOrdinalBlock_(parts[i].value);\n          break;\n        case goog.i18n.MessageFormat.BlockType_.SIMPLE:\n          block.type = goog.i18n.MessageFormat.BlockType_.SIMPLE;\n          block.value = parts[i].value;\n          break;\n        default:\n          goog.asserts.fail(\n              'Unknown block type for pattern: ' + parts[i].value);\n      }\n    } else {\n      goog.asserts.fail('Unknown part of the pattern.');\n    }\n    result.push(block);\n  }\n\n  return result;\n};\n\n\n/**\n * Parses a select type of a block and produces JSON object for it.\n * @param {string} pattern Subpattern that needs to be parsed as select pattern.\n * @return {!Object} Object with select block info.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.parseSelectBlock_ = function(pattern) {\n  var argumentIndex = '';\n  var replaceRegex = goog.i18n.MessageFormat.SELECT_BLOCK_RE_;\n  pattern = pattern.replace(replaceRegex, function(string, name) {\n    argumentIndex = name;\n    return '';\n  });\n  var result = {};\n  result.argumentIndex = argumentIndex;\n\n  var parts = this.extractParts_(pattern);\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  var pos = 0;\n  while (pos < parts.length) {\n    var key = parts[pos].value;\n    goog.asserts.assertString(key, 'Missing select key element.');\n\n    pos++;\n    goog.asserts.assert(\n        pos < parts.length, 'Missing or invalid select value element.');\n\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\n      var value = this.parseBlock_(parts[pos].value);\n    } else {\n      goog.asserts.fail('Expected block type.');\n    }\n    result[key.replace(/\\s/g, '')] = value;\n    pos++;\n  }\n\n  goog.asserts.assertArray(\n      result[goog.i18n.MessageFormat.OTHER_],\n      'Missing other key in select statement.');\n  return result;\n};\n\n\n/**\n * Parses a plural type of a block and produces JSON object for it.\n * @param {string} pattern Subpattern that needs to be parsed as plural pattern.\n * @return {!Object} Object with select block info.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.parsePluralBlock_ = function(pattern) {\n  var argumentIndex = '';\n  var argumentOffset = 0;\n  var replaceRegex = goog.i18n.MessageFormat.PLURAL_BLOCK_RE_;\n  pattern = pattern.replace(replaceRegex, function(string, name, offset) {\n    argumentIndex = name;\n    if (offset) {\n      argumentOffset = parseInt(offset, 10);\n    }\n    return '';\n  });\n\n  var result = {};\n  result.argumentIndex = argumentIndex;\n  result.argumentOffset = argumentOffset;\n\n  var parts = this.extractParts_(pattern);\n  // Looking for (key block)+ sequence.\n  var pos = 0;\n  while (pos < parts.length) {\n    var key = parts[pos].value;\n    goog.asserts.assertString(key, 'Missing plural key element.');\n\n    pos++;\n    goog.asserts.assert(\n        pos < parts.length, 'Missing or invalid plural value element.');\n\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\n      var value = this.parseBlock_(parts[pos].value);\n    } else {\n      goog.asserts.fail('Expected block type.');\n    }\n    result[key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1')] = value;\n    pos++;\n  }\n\n  goog.asserts.assertArray(\n      result[goog.i18n.MessageFormat.OTHER_],\n      'Missing other key in plural statement.');\n\n  return result;\n};\n\n\n/**\n * Parses an ordinal type of a block and produces JSON object for it.\n * For example the input string:\n *  '{FOO, selectordinal, one {Message A}other {Message B}}'\n * Should result in the output object:\n * {\n *   argumentIndex: 'FOO',\n *   argumentOffest: 0,\n *   one: [ { type: 4, value: 'Message A' } ],\n *   other: [ { type: 4, value: 'Message B' } ]\n * }\n * @param {string} pattern Subpattern that needs to be parsed as plural pattern.\n * @return {!Object} Object with select block info.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.parseOrdinalBlock_ = function(pattern) {\n  var argumentIndex = '';\n  var replaceRegex = goog.i18n.MessageFormat.ORDINAL_BLOCK_RE_;\n  pattern = pattern.replace(replaceRegex, function(string, name) {\n    argumentIndex = name;\n    return '';\n  });\n\n  var result = {};\n  result.argumentIndex = argumentIndex;\n  result.argumentOffset = 0;\n\n  var parts = this.extractParts_(pattern);\n  // Looking for (key block)+ sequence.\n  var pos = 0;\n  while (pos < parts.length) {\n    var key = parts[pos].value;\n    goog.asserts.assertString(key, 'Missing ordinal key element.');\n\n    pos++;\n    goog.asserts.assert(\n        pos < parts.length, 'Missing or invalid ordinal value element.');\n\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\n      var value = this.parseBlock_(parts[pos].value);\n    } else {\n      goog.asserts.fail('Expected block type.');\n    }\n    result[key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1')] = value;\n    pos++;\n  }\n\n  goog.asserts.assertArray(\n      result[goog.i18n.MessageFormat.OTHER_],\n      'Missing other key in selectordinal statement.');\n\n  return result;\n};\n\n\n/**\n * Builds a placeholder from the last index of the array.\n * @param {!Array<string>} literals All literals encountered during parse.\n * @return {string} \\uFDDF_ + last index + _.\n * @private\n */\ngoog.i18n.MessageFormat.prototype.buildPlaceholder_ = function(literals) {\n  goog.asserts.assert(literals.length > 0, 'Literal array is empty.');\n\n  var index = (literals.length - 1).toString(10);\n  return goog.i18n.MessageFormat.LITERAL_PLACEHOLDER_ + index + '_';\n};\n","~:compiled-at",1574163696269,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.i18n.messageformat.js\",\n\"lineCount\":442,\n\"mappings\":\"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\",\n\"sources\":[\"goog/i18n/messageformat.js\"],\n\"sourcesContent\":[\"// Copyright 2010 The Closure Library Authors. All Rights Reserved\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Message/plural format library with locale support.\\n *\\n * Message format grammar:\\n *\\n * messageFormatPattern := string ( \\\"{\\\" messageFormatElement \\\"}\\\" string )*\\n * messageFormatElement := argumentIndex [ \\\",\\\" elementFormat ]\\n * elementFormat := \\\"plural\\\" \\\",\\\" pluralStyle\\n *                  | \\\"selectordinal\\\" \\\",\\\" ordinalStyle\\n *                  | \\\"select\\\" \\\",\\\" selectStyle\\n * pluralStyle :=  pluralFormatPattern\\n * ordinalStyle :=  selectFormatPattern\\n * selectStyle :=  selectFormatPattern\\n * pluralFormatPattern := [ \\\"offset\\\" \\\":\\\" offsetIndex ] pluralForms*\\n * selectFormatPattern := pluralForms*\\n * pluralForms := stringKey \\\"{\\\" ( \\\"{\\\" messageFormatElement \\\"}\\\"|string )* \\\"}\\\"\\n *\\n * This is a subset of the ICU MessageFormatSyntax:\\n *   http://userguide.icu-project.org/formatparse/messages\\n * See also http://go/plurals and http://go/ordinals for internal details.\\n *\\n *\\n * Message example:\\n *\\n * I see {NUM_PEOPLE, plural, offset:1\\n *         =0 {no one at all}\\n *         =1 {{WHO}}\\n *         one {{WHO} and one other person}\\n *         other {{WHO} and # other people}}\\n * in {PLACE}.\\n *\\n * Calling format({'NUM_PEOPLE': 2, 'WHO': 'Mark', 'PLACE': 'Athens'}) would\\n * produce \\\"I see Mark and one other person in Athens.\\\" as output.\\n *\\n * OR:\\n *\\n * {NUM_FLOOR, selectordinal,\\n *   one {Take the elevator to the #st floor.}\\n *   two {Take the elevator to the #nd floor.}\\n *   few {Take the elevator to the #rd floor.}\\n *   other {Take the elevator to the #th floor.}}\\n *\\n * Calling format({'NUM_FLOOR': 22}) would produce\\n * \\\"Take the elevator to the 22nd floor\\\".\\n *\\n * See messageformat_test.html for more examples.\\n */\\n\\ngoog.provide('goog.i18n.MessageFormat');\\n\\ngoog.require('goog.array');\\ngoog.require('goog.asserts');\\ngoog.require('goog.i18n.CompactNumberFormatSymbols');\\ngoog.require('goog.i18n.NumberFormat');\\ngoog.require('goog.i18n.NumberFormatSymbols');\\ngoog.require('goog.i18n.ordinalRules');\\ngoog.require('goog.i18n.pluralRules');\\n\\n\\n\\n/**\\n * Constructor of MessageFormat.\\n * @param {string} pattern The pattern we parse and apply positional parameters\\n *     to.\\n * @constructor\\n * @final\\n */\\ngoog.i18n.MessageFormat = function(pattern) {\\n  /**\\n   * The pattern we parse and apply positional parameters to.\\n   * @type {?string}\\n   * @private\\n   */\\n  this.pattern_ = pattern;\\n\\n  /**\\n   * All encountered literals during parse stage. Indices tell us the order of\\n   * replacement.\\n   * @type {?Array<string>}\\n   * @private\\n   */\\n  this.initialLiterals_ = null;\\n\\n  /**\\n   * Working array with all encountered literals during parse and format stages.\\n   * Indices tell us the order of replacement.\\n   * @type {?Array<string>}\\n   * @private\\n   */\\n  this.literals_ = null;\\n\\n  /**\\n   * Input pattern gets parsed into objects for faster formatting.\\n   * @type {?Array<!Object>}\\n   * @private\\n   */\\n  this.parsedPattern_ = null;\\n\\n  /**\\n   * Locale aware number formatter.\\n   * @type {!goog.i18n.NumberFormat}\\n   * @private\\n   */\\n  this.numberFormatter_ = goog.i18n.MessageFormat.getNumberFormatter_();\\n};\\n\\n\\n/**\\n * Locale associated with the most recently created NumberFormat.\\n * @type {?Object}\\n * @private\\n */\\ngoog.i18n.MessageFormat.numberFormatterSymbols_ = null;\\n\\n\\n/**\\n * Locale associated with the most recently created NumberFormat.\\n * @type {?Object}\\n * @private\\n */\\ngoog.i18n.MessageFormat.compactNumberFormatterSymbols_ = null;\\n\\n\\n/**\\n * Locale aware number formatter. Reference to the most recently created\\n * NumberFormat for sharing between MessageFormat instances.\\n * @type {?goog.i18n.NumberFormat}\\n * @private\\n */\\ngoog.i18n.MessageFormat.numberFormatter_ = null;\\n\\n\\n/**\\n * Literal strings, including '', are replaced with \\\\uFDDF_x_ for\\n * parsing purposes, and recovered during format phase.\\n * \\\\uFDDF is a Unicode nonprinting character, not expected to be found in the\\n * typical message.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.MessageFormat.LITERAL_PLACEHOLDER_ = '\\\\uFDDF_';\\n\\n\\n/**\\n * Marks a string and block during parsing.\\n * @enum {number}\\n * @private\\n */\\ngoog.i18n.MessageFormat.Element_ = {\\n  STRING: 0,\\n  BLOCK: 1\\n};\\n\\n\\n/**\\n * Block type.\\n * @enum {number}\\n * @private\\n */\\ngoog.i18n.MessageFormat.BlockType_ = {\\n  PLURAL: 0,\\n  ORDINAL: 1,\\n  SELECT: 2,\\n  SIMPLE: 3,\\n  STRING: 4,\\n  UNKNOWN: 5\\n};\\n\\n\\n/**\\n * Mandatory option in both select and plural form.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.MessageFormat.OTHER_ = 'other';\\n\\n\\n/**\\n * Regular expression for looking for string literals.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.MessageFormat.REGEX_LITERAL_ = new RegExp(\\\"'([{}#].*?)'\\\", 'g');\\n\\n\\n/**\\n * Regular expression for looking for '' in the message.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.MessageFormat.REGEX_DOUBLE_APOSTROPHE_ = new RegExp(\\\"''\\\", 'g');\\n\\n/** @typedef {{ type: goog.i18n.MessageFormat.Element_, value: ? }} */\\ngoog.i18n.MessageFormat.TypeVal_;\\n\\n\\n/**\\n * Gets the a NumberFormat instance for the current locale.\\n * If the locale is the same as the previous invocation, returns the same\\n * NumberFormat instance. Otherwise, creates a new one.\\n * @return {!goog.i18n.NumberFormat}\\n * @private\\n */\\ngoog.i18n.MessageFormat.getNumberFormatter_ = function() {\\n  var currentSymbols = goog.i18n.NumberFormatSymbols;\\n  var currentCompactSymbols = goog.i18n.CompactNumberFormatSymbols;\\n\\n  if (goog.i18n.MessageFormat.numberFormatterSymbols_ !== currentSymbols ||\\n      goog.i18n.MessageFormat.compactNumberFormatterSymbols_ !==\\n          currentCompactSymbols) {\\n    goog.i18n.MessageFormat.numberFormatterSymbols_ = currentSymbols;\\n    goog.i18n.MessageFormat.compactNumberFormatterSymbols_ =\\n        currentCompactSymbols;\\n    goog.i18n.MessageFormat.numberFormatter_ =\\n        new goog.i18n.NumberFormat(goog.i18n.NumberFormat.Format.DECIMAL);\\n  }\\n\\n  return /** @type {!goog.i18n.NumberFormat} */ (\\n      goog.i18n.MessageFormat.numberFormatter_);\\n};\\n\\n\\n/**\\n * Formats a message, treating '#' with special meaning representing\\n * the number (plural_variable - offset).\\n * @param {!Object} namedParameters Parameters that either\\n *     influence the formatting or are used as actual data.\\n *     I.e. in call to fmt.format({'NUM_PEOPLE': 5, 'NAME': 'Angela'}),\\n *     object {'NUM_PEOPLE': 5, 'NAME': 'Angela'} holds positional parameters.\\n *     1st parameter could mean 5 people, which could influence plural format,\\n *     and 2nd parameter is just a data to be printed out in proper position.\\n * @return {string} Formatted message.\\n */\\ngoog.i18n.MessageFormat.prototype.format = function(namedParameters) {\\n  return this.format_(namedParameters, false);\\n};\\n\\n\\n/**\\n * Formats a message, treating '#' as literary character.\\n * @param {!Object} namedParameters Parameters that either\\n *     influence the formatting or are used as actual data.\\n *     I.e. in call to fmt.format({'NUM_PEOPLE': 5, 'NAME': 'Angela'}),\\n *     object {'NUM_PEOPLE': 5, 'NAME': 'Angela'} holds positional parameters.\\n *     1st parameter could mean 5 people, which could influence plural format,\\n *     and 2nd parameter is just a data to be printed out in proper position.\\n * @return {string} Formatted message.\\n */\\ngoog.i18n.MessageFormat.prototype.formatIgnoringPound = function(\\n    namedParameters) {\\n  return this.format_(namedParameters, true);\\n};\\n\\n\\n/**\\n * Formats a message.\\n * @param {!Object} namedParameters Parameters that either\\n *     influence the formatting or are used as actual data.\\n *     I.e. in call to fmt.format({'NUM_PEOPLE': 5, 'NAME': 'Angela'}),\\n *     object {'NUM_PEOPLE': 5, 'NAME': 'Angela'} holds positional parameters.\\n *     1st parameter could mean 5 people, which could influence plural format,\\n *     and 2nd parameter is just a data to be printed out in proper position.\\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\\n *     literary character, else treat it as an ICU syntax character, resolving\\n *     to the number (plural_variable - offset).\\n * @return {string} Formatted message.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.format_ = function(\\n    namedParameters, ignorePound) {\\n  this.init_();\\n  if (!this.parsedPattern_ || this.parsedPattern_.length == 0) {\\n    return '';\\n  }\\n  this.literals_ = goog.array.clone(this.initialLiterals_);\\n\\n  var result = [];\\n  this.formatBlock_(this.parsedPattern_, namedParameters, ignorePound, result);\\n  var message = result.join('');\\n\\n  if (!ignorePound) {\\n    goog.asserts.assert(message.search('#') == -1, 'Not all # were replaced.');\\n  }\\n\\n  while (this.literals_.length > 0) {\\n    message = message.replace(\\n        this.buildPlaceholder_(this.literals_), this.literals_.pop());\\n  }\\n\\n  return message;\\n};\\n\\n\\n/**\\n * Parses generic block and returns a formatted string.\\n * @param {!Array<!goog.i18n.MessageFormat.TypeVal_>} parsedPattern\\n *     Holds parsed tree.\\n * @param {!Object} namedParameters Parameters that either influence\\n *     the formatting or are used as actual data.\\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\\n *     literary character, else treat it as an ICU syntax character, resolving\\n *     to the number (plural_variable - offset).\\n * @param {!Array<string>} result Each formatting stage appends its product\\n *     to the result.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.formatBlock_ = function(\\n    parsedPattern, namedParameters, ignorePound, result) {\\n  for (var i = 0; i < parsedPattern.length; i++) {\\n    switch (parsedPattern[i].type) {\\n      case goog.i18n.MessageFormat.BlockType_.STRING:\\n        result.push(parsedPattern[i].value);\\n        break;\\n      case goog.i18n.MessageFormat.BlockType_.SIMPLE:\\n        var pattern = parsedPattern[i].value;\\n        this.formatSimplePlaceholder_(pattern, namedParameters, result);\\n        break;\\n      case goog.i18n.MessageFormat.BlockType_.SELECT:\\n        var pattern = parsedPattern[i].value;\\n        this.formatSelectBlock_(pattern, namedParameters, ignorePound, result);\\n        break;\\n      case goog.i18n.MessageFormat.BlockType_.PLURAL:\\n        var pattern = parsedPattern[i].value;\\n        this.formatPluralOrdinalBlock_(\\n            pattern, namedParameters, goog.i18n.pluralRules.select, ignorePound,\\n            result);\\n        break;\\n      case goog.i18n.MessageFormat.BlockType_.ORDINAL:\\n        var pattern = parsedPattern[i].value;\\n        this.formatPluralOrdinalBlock_(\\n            pattern, namedParameters, goog.i18n.ordinalRules.select,\\n            ignorePound, result);\\n        break;\\n      default:\\n        goog.asserts.fail('Unrecognized block type: ' + parsedPattern[i].type);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Formats simple placeholder.\\n * @param {!Object} parsedPattern JSON object containing placeholder info.\\n * @param {!Object} namedParameters Parameters that are used as actual data.\\n * @param {!Array<string>} result Each formatting stage appends its product\\n *     to the result.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.formatSimplePlaceholder_ = function(\\n    parsedPattern, namedParameters, result) {\\n  var value = namedParameters[parsedPattern];\\n  if (!goog.isDef(value)) {\\n    result.push('Undefined parameter - ' + parsedPattern);\\n    return;\\n  }\\n\\n  // Don't push the value yet, it may contain any of # { } in it which\\n  // will break formatter. Insert a placeholder and replace at the end.\\n  this.literals_.push(value);\\n  result.push(this.buildPlaceholder_(this.literals_));\\n};\\n\\n\\n/**\\n * Formats select block. Only one option is selected.\\n * @param {!{argumentIndex:?}} parsedPattern JSON object containing select\\n *     block info.\\n * @param {!Object} namedParameters Parameters that either influence\\n *     the formatting or are used as actual data.\\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\\n *     literary character, else treat it as an ICU syntax character, resolving\\n *     to the number (plural_variable - offset).\\n * @param {!Array<string>} result Each formatting stage appends its product\\n *     to the result.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.formatSelectBlock_ = function(\\n    parsedPattern, namedParameters, ignorePound, result) {\\n  var argumentIndex = parsedPattern.argumentIndex;\\n  if (!goog.isDef(namedParameters[argumentIndex])) {\\n    result.push('Undefined parameter - ' + argumentIndex);\\n    return;\\n  }\\n\\n  var option = parsedPattern[namedParameters[argumentIndex]];\\n  if (!goog.isDef(option)) {\\n    option = parsedPattern[goog.i18n.MessageFormat.OTHER_];\\n    goog.asserts.assertArray(\\n        option, 'Invalid option or missing other option for select block.');\\n  }\\n\\n  this.formatBlock_(option, namedParameters, ignorePound, result);\\n};\\n\\n\\n/**\\n * Formats plural or selectordinal block. Only one option is selected and all #\\n * are replaced.\\n * @param {!{argumentIndex, argumentOffset}} parsedPattern JSON object\\n *     containing plural block info.\\n * @param {!Object} namedParameters Parameters that either influence\\n *     the formatting or are used as actual data.\\n * @param {function(number, number=):string} pluralSelector  A select function\\n *     from goog.i18n.pluralRules or goog.i18n.ordinalRules which determines\\n *     which plural/ordinal form to use based on the input number's cardinality.\\n * @param {boolean} ignorePound If true, treat '#' in plural messages as a\\n *     literary character, else treat it as an ICU syntax character, resolving\\n *     to the number (plural_variable - offset).\\n * @param {!Array<string>} result Each formatting stage appends its product\\n *     to the result.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.formatPluralOrdinalBlock_ = function(\\n    parsedPattern, namedParameters, pluralSelector, ignorePound, result) {\\n  var argumentIndex = parsedPattern.argumentIndex;\\n  var argumentOffset = parsedPattern.argumentOffset;\\n  var pluralValue = +namedParameters[argumentIndex];\\n  if (isNaN(pluralValue)) {\\n    // TODO(user): Distinguish between undefined and invalid parameters.\\n    result.push('Undefined or invalid parameter - ' + argumentIndex);\\n    return;\\n  }\\n  var diff = pluralValue - argumentOffset;\\n\\n  // Check if there is an exact match.\\n  var option = parsedPattern[namedParameters[argumentIndex]];\\n  if (!goog.isDef(option)) {\\n    goog.asserts.assert(diff >= 0, 'Argument index smaller than offset.');\\n    var item;\\n    if (this.numberFormatter_.getMinimumFractionDigits) {  // number formatter?\\n      // If we know the number of fractional digits we can make better decisions\\n      // We can decide (for instance) between \\\"1 dollar\\\" and \\\"1.00 dollars\\\".\\n      item = pluralSelector(\\n          diff, this.numberFormatter_.getMinimumFractionDigits());\\n    } else {\\n      item = pluralSelector(diff);\\n    }\\n    goog.asserts.assertString(item, 'Invalid plural key.');\\n\\n    option = parsedPattern[item];\\n\\n    // If option is not provided fall back to \\\"other\\\".\\n    if (!goog.isDef(option)) {\\n      option = parsedPattern[goog.i18n.MessageFormat.OTHER_];\\n    }\\n\\n    goog.asserts.assertArray(\\n        option, 'Invalid option or missing other option for plural block.');\\n  }\\n\\n  var pluralResult = [];\\n  this.formatBlock_(option, namedParameters, ignorePound, pluralResult);\\n  var plural = pluralResult.join('');\\n  goog.asserts.assertString(plural, 'Empty block in plural.');\\n  if (ignorePound) {\\n    result.push(plural);\\n  } else {\\n    var localeAwareDiff = this.numberFormatter_.format(diff);\\n    result.push(plural.replace(/#/g, localeAwareDiff));\\n  }\\n};\\n\\n\\n/**\\n * Set up the MessageFormat.\\n * Parses input pattern into an array, for faster reformatting with\\n * different input parameters.\\n * Parsing is locale independent.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.init_ = function() {\\n  if (this.pattern_) {\\n    this.initialLiterals_ = [];\\n    var pattern = this.insertPlaceholders_(this.pattern_);\\n\\n    this.parsedPattern_ = this.parseBlock_(pattern);\\n    this.pattern_ = null;\\n  }\\n};\\n\\n\\n/**\\n * Replaces string literals with literal placeholders.\\n * Literals are string of the form '}...', '{...' and '#...' where ... is\\n * set of characters not containing '\\n * Builds a dictionary so we can recover literals during format phase.\\n * @param {string} pattern Pattern to clean up.\\n * @return {string} Pattern with literals replaced with placeholders.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.insertPlaceholders_ = function(pattern) {\\n  var literals = this.initialLiterals_;\\n  var buildPlaceholder = goog.bind(this.buildPlaceholder_, this);\\n\\n  // First replace '' with single quote placeholder since they can be found\\n  // inside other literals.\\n  pattern = pattern.replace(\\n      goog.i18n.MessageFormat.REGEX_DOUBLE_APOSTROPHE_, function() {\\n        literals.push(\\\"'\\\");\\n        return buildPlaceholder(literals);\\n      });\\n\\n  pattern = pattern.replace(\\n      goog.i18n.MessageFormat.REGEX_LITERAL_, function(match, text) {\\n        literals.push(text);\\n        return buildPlaceholder(literals);\\n      });\\n\\n  return pattern;\\n};\\n\\n\\n/**\\n * Breaks pattern into strings and top level {...} blocks.\\n * @param {string} pattern (sub)Pattern to be broken.\\n * @return {!Array<goog.i18n.MessageFormat.TypeVal_>}\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.extractParts_ = function(pattern) {\\n  var prevPos = 0;\\n  var braceStack = [];\\n  var results = [];\\n\\n  var braces = /[{}]/g;\\n  braces.lastIndex = 0;  // lastIndex doesn't get set to 0 so we have to.\\n  var match;\\n\\n  while (match = braces.exec(pattern)) {\\n    var pos = match.index;\\n    if (match[0] == '}') {\\n      var brace = braceStack.pop();\\n      goog.asserts.assert(\\n          goog.isDef(brace) && brace == '{', 'No matching { for }.');\\n\\n      if (braceStack.length == 0) {\\n        // End of the block.\\n        var part = {};\\n        part.type = goog.i18n.MessageFormat.Element_.BLOCK;\\n        part.value = pattern.substring(prevPos, pos);\\n        results.push(part);\\n        prevPos = pos + 1;\\n      }\\n    } else {\\n      if (braceStack.length == 0) {\\n        var substring = pattern.substring(prevPos, pos);\\n        if (substring != '') {\\n          results.push({\\n            type: goog.i18n.MessageFormat.Element_.STRING,\\n            value: substring\\n          });\\n        }\\n        prevPos = pos + 1;\\n      }\\n      braceStack.push('{');\\n    }\\n  }\\n\\n  // Take care of the final string, and check if the braceStack is empty.\\n  goog.asserts.assert(\\n      braceStack.length == 0, 'There are mismatched { or } in the pattern.');\\n\\n  var substring = pattern.substring(prevPos);\\n  if (substring != '') {\\n    results.push(\\n        {type: goog.i18n.MessageFormat.Element_.STRING, value: substring});\\n  }\\n\\n  return results;\\n};\\n\\n\\n/**\\n * A regular expression to parse the plural block, extracting the argument\\n * index and offset (if any).\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.MessageFormat.PLURAL_BLOCK_RE_ =\\n    /^\\\\s*(\\\\w+)\\\\s*,\\\\s*plural\\\\s*,(?:\\\\s*offset:(\\\\d+))?/;\\n\\n\\n/**\\n * A regular expression to parse the ordinal block, extracting the argument\\n * index.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.MessageFormat.ORDINAL_BLOCK_RE_ = /^\\\\s*(\\\\w+)\\\\s*,\\\\s*selectordinal\\\\s*,/;\\n\\n\\n/**\\n * A regular expression to parse the select block, extracting the argument\\n * index.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.MessageFormat.SELECT_BLOCK_RE_ = /^\\\\s*(\\\\w+)\\\\s*,\\\\s*select\\\\s*,/;\\n\\n\\n/**\\n * Detects which type of a block is the pattern.\\n * @param {string} pattern Content of the block.\\n * @return {goog.i18n.MessageFormat.BlockType_} One of the block types.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.parseBlockType_ = function(pattern) {\\n  if (goog.i18n.MessageFormat.PLURAL_BLOCK_RE_.test(pattern)) {\\n    return goog.i18n.MessageFormat.BlockType_.PLURAL;\\n  }\\n\\n  if (goog.i18n.MessageFormat.ORDINAL_BLOCK_RE_.test(pattern)) {\\n    return goog.i18n.MessageFormat.BlockType_.ORDINAL;\\n  }\\n\\n  if (goog.i18n.MessageFormat.SELECT_BLOCK_RE_.test(pattern)) {\\n    return goog.i18n.MessageFormat.BlockType_.SELECT;\\n  }\\n\\n  if (/^\\\\s*\\\\w+\\\\s*/.test(pattern)) {\\n    return goog.i18n.MessageFormat.BlockType_.SIMPLE;\\n  }\\n\\n  return goog.i18n.MessageFormat.BlockType_.UNKNOWN;\\n};\\n\\n\\n/**\\n * Parses generic block.\\n * @param {string} pattern Content of the block to parse.\\n * @return {!Array<!Object>} Subblocks marked as strings, select...\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.parseBlock_ = function(pattern) {\\n  var result = [];\\n  var parts = this.extractParts_(pattern);\\n  for (var i = 0; i < parts.length; i++) {\\n    var block = {};\\n    if (goog.i18n.MessageFormat.Element_.STRING == parts[i].type) {\\n      block.type = goog.i18n.MessageFormat.BlockType_.STRING;\\n      block.value = parts[i].value;\\n    } else if (goog.i18n.MessageFormat.Element_.BLOCK == parts[i].type) {\\n      var blockType = this.parseBlockType_(parts[i].value);\\n\\n      switch (blockType) {\\n        case goog.i18n.MessageFormat.BlockType_.SELECT:\\n          block.type = goog.i18n.MessageFormat.BlockType_.SELECT;\\n          block.value = this.parseSelectBlock_(parts[i].value);\\n          break;\\n        case goog.i18n.MessageFormat.BlockType_.PLURAL:\\n          block.type = goog.i18n.MessageFormat.BlockType_.PLURAL;\\n          block.value = this.parsePluralBlock_(parts[i].value);\\n          break;\\n        case goog.i18n.MessageFormat.BlockType_.ORDINAL:\\n          block.type = goog.i18n.MessageFormat.BlockType_.ORDINAL;\\n          block.value = this.parseOrdinalBlock_(parts[i].value);\\n          break;\\n        case goog.i18n.MessageFormat.BlockType_.SIMPLE:\\n          block.type = goog.i18n.MessageFormat.BlockType_.SIMPLE;\\n          block.value = parts[i].value;\\n          break;\\n        default:\\n          goog.asserts.fail(\\n              'Unknown block type for pattern: ' + parts[i].value);\\n      }\\n    } else {\\n      goog.asserts.fail('Unknown part of the pattern.');\\n    }\\n    result.push(block);\\n  }\\n\\n  return result;\\n};\\n\\n\\n/**\\n * Parses a select type of a block and produces JSON object for it.\\n * @param {string} pattern Subpattern that needs to be parsed as select pattern.\\n * @return {!Object} Object with select block info.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.parseSelectBlock_ = function(pattern) {\\n  var argumentIndex = '';\\n  var replaceRegex = goog.i18n.MessageFormat.SELECT_BLOCK_RE_;\\n  pattern = pattern.replace(replaceRegex, function(string, name) {\\n    argumentIndex = name;\\n    return '';\\n  });\\n  var result = {};\\n  result.argumentIndex = argumentIndex;\\n\\n  var parts = this.extractParts_(pattern);\\n  // Looking for (key block)+ sequence. One of the keys has to be \\\"other\\\".\\n  var pos = 0;\\n  while (pos < parts.length) {\\n    var key = parts[pos].value;\\n    goog.asserts.assertString(key, 'Missing select key element.');\\n\\n    pos++;\\n    goog.asserts.assert(\\n        pos < parts.length, 'Missing or invalid select value element.');\\n\\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\\n      var value = this.parseBlock_(parts[pos].value);\\n    } else {\\n      goog.asserts.fail('Expected block type.');\\n    }\\n    result[key.replace(/\\\\s/g, '')] = value;\\n    pos++;\\n  }\\n\\n  goog.asserts.assertArray(\\n      result[goog.i18n.MessageFormat.OTHER_],\\n      'Missing other key in select statement.');\\n  return result;\\n};\\n\\n\\n/**\\n * Parses a plural type of a block and produces JSON object for it.\\n * @param {string} pattern Subpattern that needs to be parsed as plural pattern.\\n * @return {!Object} Object with select block info.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.parsePluralBlock_ = function(pattern) {\\n  var argumentIndex = '';\\n  var argumentOffset = 0;\\n  var replaceRegex = goog.i18n.MessageFormat.PLURAL_BLOCK_RE_;\\n  pattern = pattern.replace(replaceRegex, function(string, name, offset) {\\n    argumentIndex = name;\\n    if (offset) {\\n      argumentOffset = parseInt(offset, 10);\\n    }\\n    return '';\\n  });\\n\\n  var result = {};\\n  result.argumentIndex = argumentIndex;\\n  result.argumentOffset = argumentOffset;\\n\\n  var parts = this.extractParts_(pattern);\\n  // Looking for (key block)+ sequence.\\n  var pos = 0;\\n  while (pos < parts.length) {\\n    var key = parts[pos].value;\\n    goog.asserts.assertString(key, 'Missing plural key element.');\\n\\n    pos++;\\n    goog.asserts.assert(\\n        pos < parts.length, 'Missing or invalid plural value element.');\\n\\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\\n      var value = this.parseBlock_(parts[pos].value);\\n    } else {\\n      goog.asserts.fail('Expected block type.');\\n    }\\n    result[key.replace(/\\\\s*(?:=)?(\\\\w+)\\\\s*/, '$1')] = value;\\n    pos++;\\n  }\\n\\n  goog.asserts.assertArray(\\n      result[goog.i18n.MessageFormat.OTHER_],\\n      'Missing other key in plural statement.');\\n\\n  return result;\\n};\\n\\n\\n/**\\n * Parses an ordinal type of a block and produces JSON object for it.\\n * For example the input string:\\n *  '{FOO, selectordinal, one {Message A}other {Message B}}'\\n * Should result in the output object:\\n * {\\n *   argumentIndex: 'FOO',\\n *   argumentOffest: 0,\\n *   one: [ { type: 4, value: 'Message A' } ],\\n *   other: [ { type: 4, value: 'Message B' } ]\\n * }\\n * @param {string} pattern Subpattern that needs to be parsed as plural pattern.\\n * @return {!Object} Object with select block info.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.parseOrdinalBlock_ = function(pattern) {\\n  var argumentIndex = '';\\n  var replaceRegex = goog.i18n.MessageFormat.ORDINAL_BLOCK_RE_;\\n  pattern = pattern.replace(replaceRegex, function(string, name) {\\n    argumentIndex = name;\\n    return '';\\n  });\\n\\n  var result = {};\\n  result.argumentIndex = argumentIndex;\\n  result.argumentOffset = 0;\\n\\n  var parts = this.extractParts_(pattern);\\n  // Looking for (key block)+ sequence.\\n  var pos = 0;\\n  while (pos < parts.length) {\\n    var key = parts[pos].value;\\n    goog.asserts.assertString(key, 'Missing ordinal key element.');\\n\\n    pos++;\\n    goog.asserts.assert(\\n        pos < parts.length, 'Missing or invalid ordinal value element.');\\n\\n    if (goog.i18n.MessageFormat.Element_.BLOCK == parts[pos].type) {\\n      var value = this.parseBlock_(parts[pos].value);\\n    } else {\\n      goog.asserts.fail('Expected block type.');\\n    }\\n    result[key.replace(/\\\\s*(?:=)?(\\\\w+)\\\\s*/, '$1')] = value;\\n    pos++;\\n  }\\n\\n  goog.asserts.assertArray(\\n      result[goog.i18n.MessageFormat.OTHER_],\\n      'Missing other key in selectordinal statement.');\\n\\n  return result;\\n};\\n\\n\\n/**\\n * Builds a placeholder from the last index of the array.\\n * @param {!Array<string>} literals All literals encountered during parse.\\n * @return {string} \\\\uFDDF_ + last index + _.\\n * @private\\n */\\ngoog.i18n.MessageFormat.prototype.buildPlaceholder_ = function(literals) {\\n  goog.asserts.assert(literals.length > 0, 'Literal array is empty.');\\n\\n  var index = (literals.length - 1).toString(10);\\n  return goog.i18n.MessageFormat.LITERAL_PLACEHOLDER_ + index + '_';\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"i18n\",\"MessageFormat\",\"goog.i18n.MessageFormat\",\"pattern\",\"pattern_\",\"initialLiterals_\",\"literals_\",\"parsedPattern_\",\"numberFormatter_\",\"getNumberFormatter_\",\"numberFormatterSymbols_\",\"compactNumberFormatterSymbols_\",\"LITERAL_PLACEHOLDER_\",\"Element_\",\"STRING\",\"BLOCK\",\"BlockType_\",\"PLURAL\",\"ORDINAL\",\"SELECT\",\"SIMPLE\",\"UNKNOWN\",\"OTHER_\",\"REGEX_LITERAL_\",\"RegExp\",\"REGEX_DOUBLE_APOSTROPHE_\",\"TypeVal_\",\"goog.i18n.MessageFormat.getNumberFormatter_\",\"currentSymbols\",\"NumberFormatSymbols\",\"currentCompactSymbols\",\"CompactNumberFormatSymbols\",\"NumberFormat\",\"Format\",\"DECIMAL\",\"prototype\",\"format\",\"goog.i18n.MessageFormat.prototype.format\",\"namedParameters\",\"format_\",\"formatIgnoringPound\",\"goog.i18n.MessageFormat.prototype.formatIgnoringPound\",\"goog.i18n.MessageFormat.prototype.format_\",\"ignorePound\",\"init_\",\"length\",\"array\",\"clone\",\"result\",\"formatBlock_\",\"message\",\"join\",\"asserts\",\"assert\",\"search\",\"replace\",\"buildPlaceholder_\",\"pop\",\"goog.i18n.MessageFormat.prototype.formatBlock_\",\"parsedPattern\",\"i\",\"type\",\"push\",\"value\",\"formatSimplePlaceholder_\",\"formatSelectBlock_\",\"formatPluralOrdinalBlock_\",\"pluralRules\",\"select\",\"ordinalRules\",\"fail\",\"goog.i18n.MessageFormat.prototype.formatSimplePlaceholder_\",\"isDef\",\"goog.i18n.MessageFormat.prototype.formatSelectBlock_\",\"argumentIndex\",\"option\",\"assertArray\",\"goog.i18n.MessageFormat.prototype.formatPluralOrdinalBlock_\",\"pluralSelector\",\"argumentOffset\",\"pluralValue\",\"isNaN\",\"diff\",\"item\",\"getMinimumFractionDigits\",\"assertString\",\"pluralResult\",\"plural\",\"localeAwareDiff\",\"goog.i18n.MessageFormat.prototype.init_\",\"insertPlaceholders_\",\"parseBlock_\",\"goog.i18n.MessageFormat.prototype.insertPlaceholders_\",\"literals\",\"buildPlaceholder\",\"bind\",\"match\",\"text\",\"extractParts_\",\"goog.i18n.MessageFormat.prototype.extractParts_\",\"prevPos\",\"braceStack\",\"results\",\"braces\",\"lastIndex\",\"exec\",\"pos\",\"index\",\"brace\",\"part\",\"substring\",\"PLURAL_BLOCK_RE_\",\"ORDINAL_BLOCK_RE_\",\"SELECT_BLOCK_RE_\",\"parseBlockType_\",\"goog.i18n.MessageFormat.prototype.parseBlockType_\",\"test\",\"goog.i18n.MessageFormat.prototype.parseBlock_\",\"parts\",\"block\",\"blockType\",\"parseSelectBlock_\",\"parsePluralBlock_\",\"parseOrdinalBlock_\",\"goog.i18n.MessageFormat.prototype.parseSelectBlock_\",\"replaceRegex\",\"string\",\"name\",\"key\",\"goog.i18n.MessageFormat.prototype.parsePluralBlock_\",\"offset\",\"parseInt\",\"goog.i18n.MessageFormat.prototype.parseOrdinalBlock_\",\"goog.i18n.MessageFormat.prototype.buildPlaceholder_\",\"toString\"]\n}\n"]